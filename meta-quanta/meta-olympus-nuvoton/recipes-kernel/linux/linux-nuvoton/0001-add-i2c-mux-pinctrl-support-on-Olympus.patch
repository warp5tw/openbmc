From 2d9bbe2dd87c085e0420b32bb24daaae72c06f1c Mon Sep 17 00:00:00 2001
From: kfting <kfting@nuvoton.com>
Date: Fri, 8 Jan 2021 11:03:06 +0800
Subject: [PATCH] add i2c-mux-pinctrl support on Olympus

Signed-off-by: kfting <kfting@nuvoton.com>
---
 arch/arm/boot/dts/nuvoton-common-npcm7xx.dtsi |   4 +-
 .../dts/nuvoton-npcm750-runbmc-olympus.dts    |  34 ++-
 drivers/i2c/muxes/Kconfig                     |  12 +
 drivers/i2c/muxes/Makefile                    |   1 +
 drivers/i2c/muxes/i2c-mux-npcm.c              | 226 ++++++++++++++++++
 5 files changed, 274 insertions(+), 3 deletions(-)
 create mode 100644 drivers/i2c/muxes/i2c-mux-npcm.c

diff --git a/arch/arm/boot/dts/nuvoton-common-npcm7xx.dtsi b/arch/arm/boot/dts/nuvoton-common-npcm7xx.dtsi
index ae5526880b60..cf3b874c005f 100644
--- a/arch/arm/boot/dts/nuvoton-common-npcm7xx.dtsi
+++ b/arch/arm/boot/dts/nuvoton-common-npcm7xx.dtsi
@@ -538,8 +538,8 @@
 				clocks = <&clk NPCM7XX_CLK_APB2>;
 				bus-frequency = <100000>;
 				interrupts = <GIC_SPI 65 IRQ_TYPE_LEVEL_HIGH>;
-				pinctrl-names = "default";
-				pinctrl-0 = <&smb1_pins>;
+				//pinctrl-names = "default";
+				//pinctrl-0 = <&smb1_pins>;
 				status = "disabled";
 			};
 
diff --git a/arch/arm/boot/dts/nuvoton-npcm750-runbmc-olympus.dts b/arch/arm/boot/dts/nuvoton-npcm750-runbmc-olympus.dts
index 94e34b3bce7f..557e937545d9 100644
--- a/arch/arm/boot/dts/nuvoton-npcm750-runbmc-olympus.dts
+++ b/arch/arm/boot/dts/nuvoton-npcm750-runbmc-olympus.dts
@@ -305,11 +305,43 @@
 				};
 			};
 
+	    i2cmux0 {
+        compatible = "i2c-mux-npcm";
+        #address-cells = <1>;
+        #size-cells = <0>;
+
+        status = "okay";
+        i2c-parent = <&i2c1>;
+        syscon = <&gcr>;
+        nuvoton,i2c-number = <1>;
+
+        pinctrl-names = "smb1", "smb1b", "smb1c", "smb1d";
+
+        pinctrl-0 = <&smb1_pins>;
+        pinctrl-1 = <&smb1b_pins>;
+        pinctrl-2 = <&smb1c_pins>;
+        pinctrl-3 = <&smb1d_pins>;
+
+        i2c@2 {
+          reg = <2>;
+          #address-cells = <1>;
+          #size-cells = <0>;
+          status = "okay";
+
+          eeprom {
+            compatible = "atmel,24c04";
+            reg = <0x50>;
+            status = "okay";
+          };
+        };
+
+      };
+
 			i2c0: i2c@80000 {
 				#address-cells = <1>;
 				#size-cells = <0>;
 				bus-frequency = <100000>;
-				status = "disabled";
+				status = "okay";
 			};
 
 			i2c1: i2c@81000 {
diff --git a/drivers/i2c/muxes/Kconfig b/drivers/i2c/muxes/Kconfig
index c6040aa839ac..b44c1ed001a4 100644
--- a/drivers/i2c/muxes/Kconfig
+++ b/drivers/i2c/muxes/Kconfig
@@ -119,4 +119,16 @@ config I2C_MUX_MLXCPLD
           This driver can also be built as a module.  If so, the module
           will be called i2c-mux-mlxcpld.
 
+config I2C_MUX_NPCM
+	tristate "NPCM I2C Mux/switches"
+	depends on OF || COMPILE_TEST
+	depends on ARCH_NPCM
+	depends on PINCTRL
+	help
+	  If you say yes here you get support for the NPCM I2C Master
+	  Selector.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called i2c-mux-npcm.
+
 endmenu
diff --git a/drivers/i2c/muxes/Makefile b/drivers/i2c/muxes/Makefile
index 6d9d865e8518..08d446bcbeae 100644
--- a/drivers/i2c/muxes/Makefile
+++ b/drivers/i2c/muxes/Makefile
@@ -14,5 +14,6 @@ obj-$(CONFIG_I2C_MUX_PCA9541)	+= i2c-mux-pca9541.o
 obj-$(CONFIG_I2C_MUX_PCA954x)	+= i2c-mux-pca954x.o
 obj-$(CONFIG_I2C_MUX_PINCTRL)	+= i2c-mux-pinctrl.o
 obj-$(CONFIG_I2C_MUX_REG)	+= i2c-mux-reg.o
+obj-$(CONFIG_I2C_MUX_NPCM)	+= i2c-mux-npcm.o
 
 ccflags-$(CONFIG_I2C_DEBUG_BUS) := -DDEBUG
diff --git a/drivers/i2c/muxes/i2c-mux-npcm.c b/drivers/i2c/muxes/i2c-mux-npcm.c
new file mode 100644
index 000000000000..64897edd596f
--- /dev/null
+++ b/drivers/i2c/muxes/i2c-mux-npcm.c
@@ -0,0 +1,226 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * I2C NPCM multiplexer 
+ */
+
+#include <linux/i2c.h>
+#include <linux/i2c-mux.h>
+#include <linux/module.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+#include "../../pinctrl/core.h"
+
+#define NPCM_GCR_I2CSEGCTL	0xE4
+
+struct i2c_mux_npcm {
+	struct pinctrl *pinctrl;
+	struct regmap *gcr_regmap;
+	u32 i2c_number;
+	struct pinctrl_state *states[];
+};
+
+static int i2c_mux_npcm_select(struct i2c_mux_core *muxc, u32 chan)
+{
+	struct i2c_mux_npcm *mux = i2c_mux_priv(muxc);
+	u32 smb_ch = chan << (mux->i2c_number * 2);
+	u32 smbxss = 0;
+	int ret;
+
+	ret = pinctrl_select_state(mux->pinctrl, mux->states[chan]);
+	if (ret)
+		return ret;
+	
+	/* Adding WENxSS */
+	smbxss |= BIT(mux->i2c_number + 12);
+	/* Setting smb segment select */
+	smbxss |= smb_ch;
+	regmap_write(mux->gcr_regmap, NPCM_GCR_I2CSEGCTL, smbxss);
+
+	return 0;
+}
+
+static int i2c_mux_npcm_deselect(struct i2c_mux_core *muxc, u32 chan)
+{
+	return i2c_mux_npcm_select(muxc, muxc->num_adapters);
+}
+
+static struct i2c_adapter *i2c_mux_npcm_root_adapter(
+	struct pinctrl_state *state)
+{
+	struct i2c_adapter *root = NULL;
+	struct pinctrl_setting *setting;
+	struct i2c_adapter *pin_root;
+
+	list_for_each_entry(setting, &state->settings, node) {
+		pin_root = i2c_root_adapter(setting->pctldev->dev);
+		if (!pin_root)
+			return NULL;
+		if (!root)
+			root = pin_root;
+		else if (root != pin_root)
+			return NULL;
+	}
+
+	return root;
+}
+
+static struct i2c_adapter *i2c_mux_npcm_parent_adapter(struct device *dev)
+{
+	struct device_node *np = dev->of_node;
+	struct device_node *parent_np;
+	struct i2c_adapter *parent;
+
+	parent_np = of_parse_phandle(np, "i2c-parent", 0);
+	if (!parent_np) {
+		dev_err(dev, "Cannot parse i2c-parent\n");
+		return ERR_PTR(-ENODEV);
+	}
+	parent = of_find_i2c_adapter_by_node(parent_np);
+	of_node_put(parent_np);
+	if (!parent)
+		return ERR_PTR(-EPROBE_DEFER);
+
+	return parent;
+}
+
+static int i2c_mux_npcm_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct i2c_mux_core *muxc;
+	struct i2c_mux_npcm *mux;
+	struct i2c_adapter *parent;
+	struct i2c_adapter *root;
+	int num_names, i, ret;
+	const char *name;
+
+	num_names = of_property_count_strings(np, "pinctrl-names");
+	if (num_names < 0) {
+		dev_err(dev, "Cannot parse pinctrl-names: %d\n",
+			num_names);
+		return num_names;
+	}
+
+	parent = i2c_mux_npcm_parent_adapter(dev);
+	if (IS_ERR(parent))
+		return PTR_ERR(parent);
+
+	muxc = i2c_mux_alloc(parent, dev, num_names,
+			     struct_size(mux, states, num_names),
+			     0, i2c_mux_npcm_select, NULL);
+	if (!muxc) {
+		ret = -ENOMEM;
+		goto err_put_parent;
+	}
+	mux = i2c_mux_priv(muxc);
+
+	mux->gcr_regmap = syscon_regmap_lookup_by_phandle(np, "syscon");
+	if (IS_ERR(mux->gcr_regmap)) {
+		dev_err(&pdev->dev, "Failed to find syscon\n");
+		return PTR_ERR(mux->gcr_regmap);
+	}
+
+	if (of_property_read_u32(pdev->dev.of_node, "nuvoton,i2c-number",
+				  &mux->i2c_number)) {
+		dev_err(&pdev->dev, "nuvoton,i2c-number not found");
+		return -ENODEV;
+	}
+
+	platform_set_drvdata(pdev, muxc);
+
+	mux->pinctrl = devm_pinctrl_get(dev);
+	if (IS_ERR(mux->pinctrl)) {
+		ret = PTR_ERR(mux->pinctrl);
+		dev_err(dev, "Cannot get pinctrl: %d\n", ret);
+		goto err_put_parent;
+	}
+
+	for (i = 0; i < num_names; i++) {
+		ret = of_property_read_string_index(np, "pinctrl-names", i,
+						    &name);
+		if (ret < 0) {
+			dev_err(dev, "Cannot parse pinctrl-names: %d\n", ret);
+			goto err_put_parent;
+		}
+
+		mux->states[i] = pinctrl_lookup_state(mux->pinctrl, name);
+		if (IS_ERR(mux->states[i])) {
+			ret = PTR_ERR(mux->states[i]);
+			dev_err(dev, "Cannot look up pinctrl state %s: %d\n",
+				name, ret);
+			goto err_put_parent;
+		}
+
+		if (strcmp(name, "idle"))
+			continue;
+
+		if (i != num_names - 1) {
+			dev_err(dev, "idle state must be last\n");
+			ret = -EINVAL;
+			goto err_put_parent;
+		}
+		muxc->deselect = i2c_mux_npcm_deselect;
+	}
+
+	root = i2c_root_adapter(&muxc->parent->dev);
+
+	muxc->mux_locked = true;
+	for (i = 0; i < num_names; i++) {
+		if (root != i2c_mux_npcm_root_adapter(mux->states[i])) {
+			muxc->mux_locked = false;
+			break;
+		}
+	}
+	if (muxc->mux_locked)
+		dev_info(dev, "mux-locked i2c mux\n");
+
+	/* Do not add any adapter for the idle state (if it's there at all). */
+	for (i = 0; i < num_names - !!muxc->deselect; i++) {
+		ret = i2c_mux_add_adapter(muxc, 0, i, 0);
+		if (ret)
+			goto err_del_adapter;
+	}
+
+	return 0;
+
+err_del_adapter:
+	i2c_mux_del_adapters(muxc);
+err_put_parent:
+	i2c_put_adapter(parent);
+
+	return ret;
+}
+
+static int i2c_mux_npcm_remove(struct platform_device *pdev)
+{
+	struct i2c_mux_core *muxc = platform_get_drvdata(pdev);
+
+	i2c_mux_del_adapters(muxc);
+	i2c_put_adapter(muxc->parent);
+
+	return 0;
+}
+
+static const struct of_device_id i2c_mux_npcm_of_match[] = {
+	{ .compatible = "i2c-mux-npcm", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, i2c_mux_npcm_of_match);
+
+static struct platform_driver i2c_mux_npcm_driver = {
+	.driver	= {
+		.name	= "i2c-mux-npcm",
+		.of_match_table = of_match_ptr(i2c_mux_npcm_of_match),
+	},
+	.probe	= i2c_mux_npcm_probe,
+	.remove	= i2c_mux_npcm_remove,
+};
+module_platform_driver(i2c_mux_npcm_driver);
+
+MODULE_DESCRIPTION("npcm-based I2C multiplexer driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:i2c-mux-npcm");
-- 
2.17.1

