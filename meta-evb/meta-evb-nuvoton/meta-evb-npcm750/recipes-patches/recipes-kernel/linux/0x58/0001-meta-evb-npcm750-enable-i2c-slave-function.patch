From f1ba226eb3309aa91e6cca76ab0b16b9225bc92e Mon Sep 17 00:00:00 2001
From: kfting <kfting@nuvoton.com>
Date: Mon, 5 Nov 2018 14:54:39 +0800
Subject: [PATCH] meta-evb-npcm750: enable i2c slave function

1. Ported from kernel 4.13
2. It's only used for ipmb verification
3. Please do not submit it to the upstream
---
 arch/arm/boot/dts/nuvoton-npcm750-evb.dts |    7 +-
 drivers/i2c/Kconfig                       |   26 +
 drivers/i2c/Makefile                      |    1 +
 drivers/i2c/busses/i2c-npcm7xx.c          | 4361 ++++++++++++++++++++---------
 drivers/i2c/i2c-slave-mqueue.c            |  215 ++
 5 files changed, 3288 insertions(+), 1322 deletions(-)
 create mode 100644 drivers/i2c/i2c-slave-mqueue.c

diff --git a/arch/arm/boot/dts/nuvoton-npcm750-evb.dts b/arch/arm/boot/dts/nuvoton-npcm750-evb.dts
index 1316d6a..cf2c1c9 100644
--- a/arch/arm/boot/dts/nuvoton-npcm750-evb.dts
+++ b/arch/arm/boot/dts/nuvoton-npcm750-evb.dts
@@ -342,7 +342,12 @@
 				#address-cells = <1>;
 				#size-cells = <0>;
 				bus-frequency = <100000>;
-				status = "disabled";
+				status = "okay";
+
+				ipmb@40000058 {
+				    compatible = "slave-mqueue";
+				    reg = <0x40000058>;
+				};
 			};
 
 			i2c5: i2c-bus@85000 {
diff --git a/drivers/i2c/Kconfig b/drivers/i2c/Kconfig
index efc3354..3afc94a9 100644
--- a/drivers/i2c/Kconfig
+++ b/drivers/i2c/Kconfig
@@ -118,6 +118,32 @@ if I2C_SLAVE
 config I2C_SLAVE_EEPROM
 	tristate "I2C eeprom slave driver"
 
+config I2C_SLAVE_MQUEUE_MESSAGE_SIZE
+	int "The message size of I2C mqueue slave"
+	default 120
+
+config I2C_SLAVE_MQUEUE_QUEUE_SIZE
+	int "The queue size of I2C mqueue slave"
+	default 32
+	help
+	  This number MUST be power of 2.
+
+config I2C_SLAVE_MQUEUE
+	tristate "I2C mqueue (message queue) slave driver"
+	select I2C_SLAVE_MQUEUE_MESSAGE_SIZE
+	select I2C_SLAVE_MQUEUE_QUEUE_SIZE
+	help
+	  Some protocols over I2C are designed for bi-directional transferring
+	  messages by using I2C Master Write protocol. This driver is used to
+	  receive and queue messages from the remote I2C device.
+
+	  Userspace can get the messages by reading sysfs file that this driver
+	  exposes.
+
+	  This support is also available as a module. If so, the module will be
+	  called i2c-slave-mqueue.
+
+
 endif
 
 config I2C_DEBUG_CORE
diff --git a/drivers/i2c/Makefile b/drivers/i2c/Makefile
index 72c94c6..7ec287b 100644
--- a/drivers/i2c/Makefile
+++ b/drivers/i2c/Makefile
@@ -16,6 +16,7 @@ obj-$(CONFIG_I2C_MUX)		+= i2c-mux.o
 obj-y				+= algos/ busses/ muxes/
 obj-$(CONFIG_I2C_STUB)		+= i2c-stub.o
 obj-$(CONFIG_I2C_SLAVE_EEPROM)	+= i2c-slave-eeprom.o
+obj-$(CONFIG_I2C_SLAVE_MQUEUE)	+= i2c-slave-mqueue.o
 
 ccflags-$(CONFIG_I2C_DEBUG_CORE) := -DDEBUG
 CFLAGS_i2c-core-base.o := -Wno-deprecated-declarations
diff --git a/drivers/i2c/busses/i2c-npcm7xx.c b/drivers/i2c/busses/i2c-npcm7xx.c
index 89c22ce..dafed3c 100644
--- a/drivers/i2c/busses/i2c-npcm7xx.c
+++ b/drivers/i2c/busses/i2c-npcm7xx.c
@@ -4,33 +4,116 @@
  *
  * Copyright (C) 2018 Nuvoton Technologies tali.perry@nuvoton.com
  */
-#include <linux/bitfield.h>
+
+#include <linux/kernel.h>
 #include <linux/clk.h>
-#include <linux/clk/nuvoton.h>
-#include <linux/crc8.h>
+#include <linux/jiffies.h>
+#include <linux/completion.h>
+#include <linux/err.h>
 #include <linux/errno.h>
 #include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
 #include <linux/interrupt.h>
+#include <linux/io.h>
 #include <linux/irq.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/irqdomain.h>
 #include <linux/kernel.h>
-#include <linux/mfd/syscon.h>
 #include <linux/module.h>
-#include <linux/of.h>
+#include <linux/delay.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
 #include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/clk/nuvoton.h>
+#include <linux/bitops.h>
+#include <linux/bitfield.h>
+
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/dma-mapping.h>
+
 #include <linux/regmap.h>
+#include <linux/mfd/syscon.h>
+
+static struct regmap *gcr_regmap = NULL;
+static struct regmap *clk_regmap = NULL;
+
+#define  I2CSEGCTL_OFFSET 0xE4
+
+#define NPCM7XX_SECCNT          (0x68)
+#define NPCM7XX_CNTR25M         (0x6C)
+
+#define  I2CSEGCTL_VAL	0x0333F000
+
+#define ENABLE	1
+#define DISABLE	0
+
+#define _1Hz_		 1UL
+#define _1KHz_		(1000 * _1Hz_)
+#define _1MHz_		(1000 * _1KHz_)
+#define _1GHz_		(1000 * _1MHz_)
+
+#ifndef ASSERT
+#ifdef DEBUG
+#define ASSERT(cond)  {if (!(cond)) for (;;) ; }
+#else
+#define ASSERT(cond)
+#endif
+#endif
+
+#define ROUND_UP(val, n)	(((val)+(n)-1) & ~((n)-1))
+#define DIV_CEILING(a, b)	 (((a) + ((b)-1)) / (b))
+
+#define I2C_VERSION "0.0.2"
+
+#define I2C_DEBUG2(f, x...)
+
+//  TODO: use this config:  I2C_DEBUG_BUS
+#define CONFIG_NPCM750_I2C_DEBUG
+#ifdef CONFIG_NPCM750_I2C_DEBUG
+#define dev_err(a, f, x...) pr_err("NPCM750-I2C: %s() dev_err:" f, __func__, \
+## x)
+#define I2C_DEBUG(f, x...) pr_info("NPCM750-I2C: %s():%d " f, __func__, \
+	__LINE__, ## x)
+#else
+#define I2C_DEBUG(f, x...)
+#endif
+#define HAL_PRINT(f, x...)		printk(f, ## x)
+
+
+#define SMB_CAPABILITY_END_OF_BUSY_SUPPORT
+// #define SMB_CAPABILITY_TIMEOUT_SUPPORT
+
+// Using SW PEC instead of HW PEC:
+//#define SMB_CAPABILITY_HW_PEC_SUPPORT
+#define SMB_RECOVERY_SUPPORT
+
+// override HW SMBus may fail to supply stop condition in Master Write operation
+#define SMB_SW_BYPASS_HW_ISSUE_SMB_STOP
+
+// if end device reads more data than avalilable, ask issuer or request for more data.
+#define SMB_WRAP_AROUND_BUFFER
 
-#define I2C_VERSION "0.0.4"
+#define SMB_QUICK_PROT	 0xFFFF
+#define SMB_BLOCK_PROT	 0xFFFE
+#define SMB_EXCLUDE_BLOCK_SIZE_FROM_BUF	0xFFFD
 
-enum smb_mode {
+
+typedef enum {
 	SMB_SLAVE = 1,
 	SMB_MASTER
-};
+} SMB_MODE_T;
 
 /*
- * External SMB Interface driver xfer indication values, which indicate status
- * of the bus.
+ * External SMB Interface driver states values, which indicate to the
+ * upper-level layer the status of the
+ * operation it initiated or wake up events from one of the buses
  */
-enum smb_state_ind {
+typedef enum {
 	SMB_NO_STATUS_IND = 0,
 	SMB_SLAVE_RCV_IND = 1,
 	SMB_SLAVE_XMIT_IND = 2,
@@ -43,26 +126,31 @@ enum smb_state_ind {
 	SMB_BUS_ERR_IND = 9,
 	SMB_WAKE_UP_IND = 10,
 	SMB_MASTER_PEC_ERR_IND = 11,
-	SMB_BLOCK_BYTES_ERR_IND = 12,
+	SMB_MASTER_BLOCK_BYTES_ERR_IND = 12,
 	SMB_SLAVE_PEC_ERR_IND = 13,
+#ifdef SMB_WRAP_AROUND_BUFFER
 	SMB_SLAVE_RCV_MISSING_DATA_IND = 14,
-};
+#endif
+} SMB_STATE_IND_T;
 
 // SMBus Operation type values
-enum smb_oper {
+typedef enum {
 	SMB_NO_OPER = 0,
 	SMB_WRITE_OPER = 1,
 	SMB_READ_OPER = 2
-};
+} SMB_OPERATION_T;
+
+
 
 // SMBus Bank (FIFO mode)
-enum smb_bank {
+
+typedef enum {
 	SMB_BANK_0 = 0,
 	SMB_BANK_1 = 1
-};
+} SMB_BANK_T;
 
-// Internal SMB states values (for the SMB module state machine).
-enum smb_state {
+// Internal SMB states values, which reflect events which occurred on the bus
+typedef enum {
 	SMB_DISABLE = 0,
 	SMB_IDLE,
 	SMB_MASTER_START,
@@ -70,10 +158,10 @@ enum smb_state {
 	SMB_OPER_STARTED,
 	SMB_REPEATED_START,
 	SMB_STOP_PENDING
-};
+} SMB_STATE_T;
+
 
-// Module supports setting multiple own slave addresses:
-enum smb_addr {
+typedef enum {
 	SMB_SLAVE_ADDR1 = 0,
 	SMB_SLAVE_ADDR2,
 	SMB_SLAVE_ADDR3,
@@ -86,1085 +174,2051 @@ enum smb_addr {
 	SMB_SLAVE_ADDR10,
 	SMB_GC_ADDR,
 	SMB_ARP_ADDR
-};
+} SMB_ADDR_T;
 
-// global regs
-static struct regmap *gcr_regmap;
-static struct regmap *clk_regmap;
 
-#define NPCM_I2CSEGCTL  0xE4
-#define NPCM_SECCNT	0x68
-#define NPCM_CNTR25M	0x6C
-#define I2CSEGCTL_VAL	0x0333F000
 
 // Common regs
-#define NPCM_SMBSDA			0x000
-#define NPCM_SMBST			0x002
-#define NPCM_SMBCST			0x004
-#define NPCM_SMBCTL1			0x006
-#define NPCM_SMBADDR1			0x008
-#define NPCM_SMBCTL2			0x00A
-#define NPCM_SMBADDR2			0x00C
-#define NPCM_SMBCTL3			0x00E
-#define NPCM_SMBCST2			0x018
-#define NPCM_SMBCST3			0x019
-#define SMB_VER				0x01F
+#define NPCM7XX_SMBSDA(bus)		(bus->base + 0x000)
+#define NPCM7XX_SMBST(bus)		(bus->base + 0x002)
+#define NPCM7XX_SMBCST(bus)		(bus->base + 0x004)
+#define NPCM7XX_SMBCTL1(bus)		(bus->base + 0x006)
+#define NPCM7XX_SMBADDR1(bus)		(bus->base + 0x008)
+#define NPCM7XX_SMBCTL2(bus)		(bus->base + 0x00A)
+#define NPCM7XX_SMBADDR2(bus)		(bus->base + 0x00C)
+#define NPCM7XX_SMBCTL3(bus)		(bus->base + 0x00E)
+#define NPCM7XX_SMBCST2(bus)		(bus->base + 0x018)  // Control Status 2
+#define NPCM7XX_SMBCST3(bus)		(bus->base + 0x019)  // Control Status 3
+#define SMB_VER(bus)			(bus->base + 0x01F)  // SMB Version reg
 
 // BANK 0 regs
-#define NPCM_SMBADDR3			0x010
-#define NPCM_SMBADDR7			0x011
-#define NPCM_SMBADDR4			0x012
-#define NPCM_SMBADDR8			0x013
-#define NPCM_SMBADDR5			0x014
-#define NPCM_SMBADDR9			0x015
-#define NPCM_SMBADDR6			0x016
-#define NPCM_SMBADDR10			0x017
-
-// SMBADDR array: because the addr regs are sprincled all over the address space
-const int  NPCM_SMBADDR[10] = {NPCM_SMBADDR1, NPCM_SMBADDR2, NPCM_SMBADDR3,
-			       NPCM_SMBADDR4, NPCM_SMBADDR5, NPCM_SMBADDR6,
-			       NPCM_SMBADDR7, NPCM_SMBADDR8, NPCM_SMBADDR9,
-			       NPCM_SMBADDR10};
-
-#define NPCM_SMBCTL4			0x01A
-#define NPCM_SMBCTL5			0x01B
-#define NPCM_SMBSCLLT			0x01C // SCL Low Time
-#define NPCM_SMBFIF_CTL			0x01D // FIFO Control
-#define NPCM_SMBSCLHT			0x01E // SCL High Time
+#define NPCM7XX_SMBADDR3(bus)		(bus->base + 0x010)
+#define NPCM7XX_SMBADDR7(bus)		(bus->base + 0x011)
+#define NPCM7XX_SMBADDR4(bus)		(bus->base + 0x012)
+#define NPCM7XX_SMBADDR8(bus)		(bus->base + 0x013)
+#define NPCM7XX_SMBADDR5(bus)		(bus->base + 0x014)
+#define NPCM7XX_SMBADDR9(bus)		(bus->base + 0x015)
+#define NPCM7XX_SMBADDR6(bus)		(bus->base + 0x016)
+#define NPCM7XX_SMBADDR10(bus)		(bus->base + 0x017)
+#define NPCM7XX_SMBADDR(bus, i)	(bus->base + 0x008 + \
+	(u32)(((int)i * 4) + (((int)i < 2) ? 0 : \
+	((int)i - 2)*(-2)) + (((int)i < 6) ? 0 : (-7))))
+
+#define NPCM7XX_SMBCTL4(bus)		(bus->base + 0x01A)
+#define NPCM7XX_SMBCTL5(bus)		(bus->base + 0x01B)
+#define NPCM7XX_SMBSCLLT(bus)		(bus->base + 0x01C)  // SCL Low Time
+#define NPCM7XX_SMBFIF_CTL(bus)		(bus->base + 0x01D)  // FIFO Control
+#define NPCM7XX_SMBSCLHT(bus)		(bus->base + 0x01E)  // SCL High Time
 
 // BANK 1 regs
-#define NPCM_SMBFIF_CTS			0x010 // FIFO Control
-#define NPCM_SMBTXF_CTL			0x012 // Tx-FIFO Control
-#define NPCM_SMBT_OUT			0x014 // Bus T.O.
-#define NPCM_SMBPEC			0x016 // PEC Data
-#define NPCM_SMBTXF_STS			0x01A // Tx-FIFO Status
-#define NPCM_SMBRXF_STS			0x01C // Rx-FIFO Status
-#define NPCM_SMBRXF_CTL			0x01E // Rx-FIFO Control
-
-// NPCM_SMBST reg fields
-#define NPCM_SMBST_XMIT			BIT(0)
-#define NPCM_SMBST_MASTER		BIT(1)
-#define NPCM_SMBST_NMATCH		BIT(2)
-#define NPCM_SMBST_STASTR		BIT(3)
-#define NPCM_SMBST_NEGACK		BIT(4)
-#define NPCM_SMBST_BER			BIT(5)
-#define NPCM_SMBST_SDAST		BIT(6)
-#define NPCM_SMBST_SLVSTP		BIT(7)
-
-// NPCM_SMBCST reg fields
-#define NPCM_SMBCST_BUSY		BIT(0)
-#define NPCM_SMBCST_BB			BIT(1)
-#define NPCM_SMBCST_MATCH		BIT(2)
-#define NPCM_SMBCST_GCMATCH		BIT(3)
-#define NPCM_SMBCST_TSDA		BIT(4)
-#define NPCM_SMBCST_TGSCL		BIT(5)
-#define NPCM_SMBCST_MATCHAF		BIT(6)
-#define NPCM_SMBCST_ARPMATCH		BIT(7)
-
-// NPCM_SMBCTL1 reg fields
-#define NPCM_SMBCTL1_START		BIT(0)
-#define NPCM_SMBCTL1_STOP		BIT(1)
-#define NPCM_SMBCTL1_INTEN		BIT(2)
-#define NPCM_SMBCTL1_EOBINTE		BIT(3)
-#define NPCM_SMBCTL1_ACK		BIT(4)
-#define NPCM_SMBCTL1_GCMEN		BIT(5)
-#define NPCM_SMBCTL1_NMINTE		BIT(6)
-#define NPCM_SMBCTL1_STASTRE		BIT(7)
-
-// RW1S fields (inside a RW reg):
-#define NPCM_SMBCTL1_RWS_FIELDS	  (NPCM_SMBCTL1_START | NPCM_SMBCTL1_STOP | \
-				   NPCM_SMBCTL1_ACK)
-// NPCM_SMBADDR reg fields
-#define NPCM_SMBADDR_ADDR		GENMASK(6, 0)
-#define NPCM_SMBADDR_SAEN		BIT(7)
-
-// NPCM_SMBCTL2 reg fields
-#define SMBCTL2_ENABLE			BIT(0)
-#define SMBCTL2_SCLFRQ6_0		GENMASK(7, 1)
-
-// NPCM_SMBCTL3 reg fields
-#define SMBCTL3_SCLFRQ8_7		GENMASK(1, 0)
-#define SMBCTL3_ARPMEN			BIT(2)
-#define SMBCTL3_IDL_START		BIT(3)
-#define SMBCTL3_400K_MODE		BIT(4)
-#define SMBCTL3_BNK_SEL			BIT(5)
-#define SMBCTL3_SDA_LVL			BIT(6)
-#define SMBCTL3_SCL_LVL			BIT(7)
-
-// NPCM_SMBCST2 reg fields
-#define NPCM_SMBCST2_MATCHA1F		BIT(0)
-#define NPCM_SMBCST2_MATCHA2F		BIT(1)
-#define NPCM_SMBCST2_MATCHA3F		BIT(2)
-#define NPCM_SMBCST2_MATCHA4F		BIT(3)
-#define NPCM_SMBCST2_MATCHA5F		BIT(4)
-#define NPCM_SMBCST2_MATCHA6F		BIT(5)
-#define NPCM_SMBCST2_MATCHA7F		BIT(5)
-#define NPCM_SMBCST2_INTSTS		BIT(7)
-
-// NPCM_SMBCST3 reg fields
-#define NPCM_SMBCST3_MATCHA8F		BIT(0)
-#define NPCM_SMBCST3_MATCHA9F		BIT(1)
-#define NPCM_SMBCST3_MATCHA10F		BIT(2)
-#define NPCM_SMBCST3_EO_BUSY		BIT(7)
-
-// NPCM_SMBCTL4 reg fields
-#define SMBCTL4_HLDT			GENMASK(5, 0)
-#define SMBCTL4_LVL_WE			BIT(7)
-
-// NPCM_SMBCTL5 reg fields
-#define SMBCTL5_DBNCT			GENMASK(3, 0)
-
-// NPCM_SMBFIF_CTS reg fields
-#define NPCM_SMBFIF_CTS_RXF_TXE		BIT(1)
-#define NPCM_SMBFIF_CTS_RFTE_IE		BIT(3)
-#define NPCM_SMBFIF_CTS_CLR_FIFO	BIT(6)
-#define NPCM_SMBFIF_CTS_SLVRSTR		BIT(7)
-
-// NPCM_SMBTXF_CTL reg fields
+#define NPCM7XX_SMBFIF_CTS(bus)		 (bus->base + 0x010)  // FIFO Control
+#define NPCM7XX_SMBTXF_CTL(bus)		 (bus->base + 0x012)  // Tx-FIFO Control
+#if defined (SMB_CAPABILITY_TIMEOUT_SUPPORT)
+#define NPCM7XX_SMBT_OUT(bus)			(bus->base + 0x014)  // Bus T.O.
+#endif
+#if defined (SMB_CAPABILITY_HW_PEC_SUPPORT)
+#define NPCM7XX_SMBPEC(bus)			 (bus->base + 0x016) // PEC Data
+#endif
+#define NPCM7XX_SMBTXF_STS(bus)		 (bus->base + 0x01A)  // Tx-FIFO Status
+#define NPCM7XX_SMBRXF_STS(bus)		 (bus->base + 0x01C)  // Rx-FIFO Status
+#define NPCM7XX_SMBRXF_CTL(bus)		 (bus->base + 0x01E)  // Rx-FIFO Control
+
+
+
+// NPCM7XX_SMBST reg fields
+#define NPCM7XX_SMBST_XMIT			BIT(0)
+#define NPCM7XX_SMBST_MASTER			BIT(1)
+#define NPCM7XX_SMBST_NMATCH			BIT(2)
+#define NPCM7XX_SMBST_STASTR			BIT(3)
+#define NPCM7XX_SMBST_NEGACK			BIT(4)
+#define NPCM7XX_SMBST_BER			BIT(5)
+#define NPCM7XX_SMBST_SDAST			BIT(6)
+#define NPCM7XX_SMBST_SLVSTP			BIT(7)
+
+// NPCM7XX_SMBCST reg fields
+#define NPCM7XX_SMBCST_BUSY			BIT(0)
+#define NPCM7XX_SMBCST_BB			BIT(1)
+#define NPCM7XX_SMBCST_MATCH			BIT(2)
+#define NPCM7XX_SMBCST_GCMATCH			BIT(3)
+#define NPCM7XX_SMBCST_TSDA			BIT(4)
+#define NPCM7XX_SMBCST_TGSCL			BIT(5)
+#define NPCM7XX_SMBCST_MATCHAF			BIT(6)
+#define NPCM7XX_SMBCST_ARPMATCH			BIT(7)
+
+// NPCM7XX_SMBCTL1 reg fields
+#define NPCM7XX_SMBCTL1_START			BIT(0)
+#define NPCM7XX_SMBCTL1_STOP			BIT(1)
+#define NPCM7XX_SMBCTL1_INTEN			BIT(2)
+#define NPCM7XX_SMBCTL1_EOBINTE			BIT(3)
+#define NPCM7XX_SMBCTL1_ACK			BIT(4)
+#define NPCM7XX_SMBCTL1_GCMEN			BIT(5)
+#define NPCM7XX_SMBCTL1_NMINTE			BIT(6)
+#define NPCM7XX_SMBCTL1_STASTRE			BIT(7)
+
+// NPCM7XX_SMBADDRx reg fields
+#define NPCM7XX_SMBADDRx_ADDR			GENMASK(6, 0)
+#define NPCM7XX_SMBADDRx_SAEN			BIT(7)
+
+// NPCM7XX_SMBCTL2 reg fields
+#define SMBCTL2_ENABLE				BIT(0)
+#define SMBCTL2_SCLFRQ6_0			GENMASK(7, 1)
+
+// NPCM7XX_SMBCTL3 reg fields
+#define SMBCTL3_SCLFRQ8_7			GENMASK(1, 0)
+#define SMBCTL3_ARPMEN				BIT(2)
+#define SMBCTL3_IDL_START			BIT(3)
+#define SMBCTL3_400K_MODE			BIT(4)
+#define SMBCTL3_BNK_SEL				BIT(5)
+#define SMBCTL3_SDA_LVL				BIT(6)
+#define SMBCTL3_SCL_LVL				BIT(7)
+
+// NPCM7XX_SMBCST2 reg fields
+#define NPCM7XX_SMBCST2_MATCHA1F		BIT(0)
+#define NPCM7XX_SMBCST2_MATCHA2F		BIT(1)
+#define NPCM7XX_SMBCST2_MATCHA3F		BIT(2)
+#define NPCM7XX_SMBCST2_MATCHA4F		BIT(3)
+#define NPCM7XX_SMBCST2_MATCHA5F		BIT(4)
+#define NPCM7XX_SMBCST2_MATCHA6F		BIT(5)
+#define NPCM7XX_SMBCST2_MATCHA7F		BIT(5)
+#define NPCM7XX_SMBCST2_INTSTS			BIT(7)
+
+// NPCM7XX_SMBCST3 reg fields
+#define NPCM7XX_SMBCST3_MATCHA8F		BIT(0)
+#define NPCM7XX_SMBCST3_MATCHA9F		BIT(1)
+#define NPCM7XX_SMBCST3_MATCHA10F		BIT(2)
+#define NPCM7XX_SMBCST3_EO_BUSY			BIT(7)
+
+
+// NPCM7XX_SMBCTL4 reg fields
+#define SMBCTL4_HLDT				GENMASK(5, 0)
+#ifdef SMB_CAPABILITY_FORCE_SCL_SDA
+#define SMBCTL4_LVL_WE				BIT(7)
+#endif
+
+// NPCM7XX_SMBCTL5 reg fields
+#define SMBCTL5_DBNCT				GENMASK(3, 0)
+
+// NPCM7XX_SMBFIF_CTS reg fields
+#define NPCM7XX_SMBFIF_CTS_RXF_TXE		BIT(1)
+#define NPCM7XX_SMBFIF_CTS_RFTE_IE		BIT(3)
+#define NPCM7XX_SMBFIF_CTS_CLR_FIFO		BIT(6)
+#define NPCM7XX_SMBFIF_CTS_SLVRSTR		BIT(7)
+
+// NPCM7XX_SMBTXF_CTL reg fields
 #ifdef SMB_CAPABILITY_32B_FIFO
-#define NPCM_SMBTXF_CTL_TX_THR		GENMASK(5, 0)
+#define NPCM7XX_SMBTXF_CTL_TX_THR		GENMASK(5, 0)
 #else
-#define NPCM_SMBTXF_CTL_TX_THR		GENMASK(4, 0)
+#define NPCM7XX_SMBTXF_CTL_TX_THR		GENMASK(4, 0)
 #endif
-#define NPCM_SMBTXF_CTL_THR_TXIE	BIT(6)
+#define NPCM7XX_SMBTXF_CTL_THR_TXIE		BIT(6)
 
-// NPCM_SMBT_OUT reg fields
-#define NPCM_SMBT_OUT_TO_CKDIV		GENMASK(5, 0)
-#define NPCM_SMBT_OUT_T_OUTIE		BIT(6)
-#define NPCM_SMBT_OUT_T_OUTST		BIT(7)
+#if defined (SMB_CAPABILITY_TIMEOUT_SUPPORT)
 
-// NPCM_SMBTXF_STS reg fields
+// NPCM7XX_SMBT_OUT reg fields
+#define NPCM7XX_SMBT_OUT_TO_CKDIV		GENMASK(5, 0)
+#define NPCM7XX_SMBT_OUT_T_OUTIE		BIT(6)
+#define NPCM7XX_SMBT_OUT_T_OUTST		BIT(7)
+#endif
+
+// NPCM7XX_SMBTXF_STS reg fields
 #ifdef SMB_CAPABILITY_32B_FIFO
-#define NPCM_SMBTXF_STS_TX_BYTES	GENMASK(5, 0)
+#define NPCM7XX_SMBTXF_STS_TX_BYTES		GENMASK(5, 0)
 #else
-#define NPCM_SMBTXF_STS_TX_BYTES	GENMASK(4, 0)
+#define NPCM7XX_SMBTXF_STS_TX_BYTES		GENMASK(4, 0)
 #endif
-#define NPCM_SMBTXF_STS_TX_THST		BIT(6)
+#define NPCM7XX_SMBTXF_STS_TX_THST		BIT(6)
 
-// NPCM_SMBRXF_STS reg fields
+// NPCM7XX_SMBRXF_STS reg fields
 #ifdef SMB_CAPABILITY_32B_FIFO
-#define NPCM_SMBRXF_STS_RX_BYTES	GENMASK(5, 0)
+#define NPCM7XX_SMBRXF_STS_RX_BYTES		GENMASK(5, 0)
 #else
-#define NPCM_SMBRXF_STS_RX_BYTES	GENMASK(4, 0)
+#define NPCM7XX_SMBRXF_STS_RX_BYTES		GENMASK(4, 0)
 #endif
-#define NPCM_SMBRXF_STS_RX_THST		BIT(6)
+#define NPCM7XX_SMBRXF_STS_RX_THST		BIT(6)
 
-// NPCM_SMBFIF_CTL reg fields
-#define NPCM_SMBFIF_CTL_FIFO_EN		BIT(4)
+// NPCM7XX_SMBFIF_CTL reg fields
+#define NPCM7XX_SMBFIF_CTL_FIFO_EN		BIT(4)
 
-// NPCM_SMBRXF_CTL reg fields
+// NPCM7XX_SMBRXF_CTL reg fields
 // Note: on the next HW version of this module, this HW is about to switch to
-//	 32 bytes FIFO. This size will be set using a config.
-//	 on current version 16 bytes FIFO is set using a define
+//       32 bytes FIFO. This size will be set using a config.
+//       on current version 16 bytes FIFO is set using a define
 #ifdef SMB_CAPABILITY_32B_FIFO
-#define NPCM_SMBRXF_CTL_RX_THR		GENMASK(5, 0)
-#define NPCM_SMBRXF_CTL_THR_RXIE	BIT(6)
-#define NPCM_SMBRXF_CTL_LAST_PEC	BIT(7)
-#define SMBUS_FIFO_SIZE			32
+#define NPCM7XX_SMBRXF_CTL_RX_THR		GENMASK(5, 0)
+#define NPCM7XX_SMBRXF_CTL_THR_RXIE		BIT(6)
+#define NPCM7XX_SMBRXF_CTL_LAST_PEC		BIT(7)
+#define SMBUS_FIFO_SIZE				32
 #else
-#define NPCM_SMBRXF_CTL_RX_THR		GENMASK(4, 0)
-#define NPCM_SMBRXF_CTL_LAST_PEC	BIT(5)
-#define NPCM_SMBRXF_CTL_THR_RXIE	BIT(6)
-#define SMBUS_FIFO_SIZE			16
+#define NPCM7XX_SMBRXF_CTL_RX_THR		GENMASK(4, 0)
+#define NPCM7XX_SMBRXF_CTL_LAST_PEC		BIT(5)
+#define NPCM7XX_SMBRXF_CTL_THR_RXIE		BIT(6)
+#define SMBUS_FIFO_SIZE				16
 #endif
 
 // SMB_VER reg fields
-#define SMB_VER_VERSION			GENMASK(6, 0)
-#define SMB_VER_FIFO_EN			BIT(7)
+#define SMB_VER_VERSION				GENMASK(6, 0)
+#define SMB_VER_FIFO_EN				BIT(7)
+
+
 
 // stall/stuck timeout
 const unsigned int DEFAULT_STALL_COUNT =	25;
 
+
 // Data abort timeout
 const unsigned int ABORT_TIMEOUT =	 1000;
 
-// SMBus spec. values in KHZ
-const unsigned int SMBUS_FREQ_MIN = 10;
-const unsigned int SMBUS_FREQ_MAX = 1000;
-const unsigned int SMBUS_FREQ_100KHZ = 100;
-const unsigned int SMBUS_FREQ_400KHZ = 400;
-const unsigned int SMBUS_FREQ_1MHZ = 1000;
+// SMBus spec. values in KHz
+const unsigned int SMBUS_FREQ_MIN =	10;
+
+const unsigned int SMBUS_FREQ_MAX =	1000;
+const unsigned int SMBUS_FREQ_100KHz = 100;
+const unsigned int SMBUS_FREQ_400KHz =   400;
+const unsigned int SMBUS_FREQ_1MHz =	1000;
+
+
 
 // SCLFRQ min/max field values
-const unsigned int SCLFRQ_MIN = 10;
-const unsigned int SCLFRQ_MAX = 511;
+const unsigned int SCLFRQ_MIN =		10;
+const unsigned int SCLFRQ_MAX =		511;
 
 // SCLFRQ field position
 #define SCLFRQ_0_TO_6		GENMASK(6, 0)
 #define SCLFRQ_7_TO_8		GENMASK(8, 7)
 
 // SMB Maximum Retry Trials (on Bus Arbitration Loss)
-const unsigned int SMB_RETRY_MAX_COUNT = 2;
-const unsigned int SMB_NUM_OF_ADDR = 10;
+const unsigned int SMB_RETRY_MAX_COUNT =	2;
 
-// for logging:
-#define NPCM_I2C_EVENT_START	BIT(0)
-#define NPCM_I2C_EVENT_STOP	BIT(1)
-#define NPCM_I2C_EVENT_ABORT	BIT(2)
-#define NPCM_I2C_EVENT_WRITE	BIT(3)
-#define NPCM_I2C_EVENT_READ	BIT(4)
-#define NPCM_I2C_EVENT_BER	BIT(5)
-#define NPCM_I2C_EVENT_NACK	BIT(6)
-#define NPCM_I2C_EVENT_TO	BIT(7)
-#define NPCM_I2C_EVENT_EOB	BIT(8)
-
-#define NPCM_I2C_EVENT_LOG(event)   (bus->event_log |= event)
 
-#define SMB_RECOVERY_SUPPORT
+const unsigned int SMB_NUM_OF_ADDR =		10 ;// TBD move to device tree
+#define SMB_FIFO(bus)		true       // All modules support FIFO
 
-// slave mode: if end device reads more data than available, ask issuer or
-// request for more data:
-#define SMB_WRAP_AROUND_BUFFER
+
+// for logging:
+#define NPCM7XX_I2C_EVENT_START   BIT(0)
+#define NPCM7XX_I2C_EVENT_STOP    BIT(1)
+#define NPCM7XX_I2C_EVENT_ABORT   BIT(2)
+#define NPCM7XX_I2C_EVENT_WRITE   BIT(3)
+#define NPCM7XX_I2C_EVENT_READ    BIT(4)
+#define NPCM7XX_I2C_EVENT_BER     BIT(5)
+#define NPCM7XX_I2C_EVENT_NACK    BIT(6)
+#define NPCM7XX_I2C_EVENT_TO      BIT(7)
+#define NPCM7XX_I2C_EVENT_EOB     BIT(8)
+
+#define NPCM7XX_I2C_EVENT_LOG(event)   bus->event_log |= event
 
 // Status of one SMBus module
-struct npcm_i2c {
-	struct i2c_adapter	adap;
-	struct device		*dev;
-	unsigned char __iomem	*reg;
-	spinlock_t		lock;   /* IRQ synchronization */
-	struct completion	cmd_complete;
-	int			irq;
-	int			cmd_err;
-	struct i2c_msg		*msgs;
-	int			msgs_num;
-	int			num;
-	u32			apb_clk;
-	enum smb_state		state;
-	enum smb_oper		operation;
-	enum smb_mode		master_or_slave;
-	enum smb_state_ind	stop_ind;
-	u8			dest_addr;
-	u8			*rd_buf;
-	u16			rd_size;
-	u16			rd_ind;
-	u8			*wr_buf;
-	u16			wr_size;
-	u16			wr_ind;
-	bool			fifo_use;
-	u8			threshold_fifo;
+struct NPCM7XX_i2c {
+	struct i2c_adapter		adap;
+	struct device			*dev;
+	unsigned char __iomem		*base;
+	// Synchronizes I/O mem access to base.
+	spinlock_t			lock;
+	struct completion		cmd_complete;
+	int				irq;
+	int				cmd_err;
+	struct i2c_msg			*msgs;
+	int				msgs_num;
+	int				num;
+	u32				apb_clk;
+#if IS_ENABLED(CONFIG_I2C_SLAVE)
+	struct i2c_client		*slave;
+#endif // CONFIG_I2C_SLAVE
+
+	// Current state of SMBus
+	volatile SMB_STATE_T  		state;
+
+	// Type of the last SMBus operation
+	SMB_OPERATION_T			operation;
+
+	// Mode of operation on SMBus
+	SMB_MODE_T			master_or_slave;
+
+	// The indication to the hi level after Master Stop
+	SMB_STATE_IND_T                 stop_ind;
+
+	// SMBus slave device's Slave Address in 8-bit format -for master xfer
+	u8				dest_addr;
+
+	// Buffer where read data should be placed
+	u8                              *read_data_buf;
+
+	// Number of bytes to be read
+	u16				rd_size;
+
+	// Number of bytes already read
+	u16				rd_ind;
+
+	// Buffer with data to be written
+	u8                              *write_data_buf;
+
+	// Number of bytes to write
+	u16				wr_size;
+
+	// Number of bytes already written
+	u16				wr_ind;
+
+	// use fifo hardware or not
+	bool				fifo_use;
+
+	// fifo threshold size
+	u8				threshold_fifo;
 
 	// PEC bit mask per slave address.
-	//		1: use PEC for this address,
-	//		0: do not use PEC for this address
-	u16			PEC_mask;
-	bool			PEC_use;
-	u8			crc_data;
-	bool			read_block_use;
-	u8			retry_count;
-	u8			int_cnt;
-	u32			event_log;
-	u32			clk_period_us;
-	u32			int_time_stamp[2];
+	// 		1: use PEC for this address,
+	// 		0: do not use PEC for this address
+	u16				PEC_mask;
+
+	// Use PEC CRC
+	bool				PEC_use;
+
+	// PEC CRC data
+	u8				crc_data;
+
+	// Use read block
+	bool				read_block_use;
+
+	// Number of retries remaining
+	u8				retry_count;
+
+	// int counter
+	u8				int_cnt;
+
+	// log events, fir debugging
+	u32				event_log;
+
+#if IS_ENABLED(CONFIG_I2C_SLAVE)
+	u8				own_slave_addr;
+#endif
+
+
+	// override HW issue :SMBus may fail to supply stop condition in
+	// Master Write operation.
+#ifdef SMB_SW_BYPASS_HW_ISSUE_SMB_STOP
+	// The indication to the hi level after Master Stop
+	u32				clk_period_us;
+	u32				int_time_stamp[2];
+#endif
 };
 
-static inline void _npcm7xx_get_time_stamp(u32 *time_quad0, u32 *time_quad1)
-{
-	u32 seconds, seconds_last;
-	u32 ref_clock;
 
-	regmap_read(clk_regmap, NPCM_SECCNT, &seconds_last);
+static bool NPCM7XX_smb_init_module(struct NPCM7XX_i2c *bus,
+				    SMB_MODE_T mode, u16 bus_freq);
 
-	do {
-		regmap_read(clk_regmap, NPCM_SECCNT, &seconds);
-		regmap_read(clk_regmap, NPCM_CNTR25M, &ref_clock);
-		regmap_read(clk_regmap, NPCM_SECCNT, &seconds_last);
-	} while (seconds_last != seconds);
+static bool NPCM7XX_smb_master_start_xmit(struct NPCM7XX_i2c
+					  *bus, u8 slave_addr,
+					  u16 nwrite, u16 nread,
+					  u8 *write_data, u8 *read_data,
+					  bool use_PEC);
+static int  NPCM7XX_smb_master_abort(struct NPCM7XX_i2c *bus);
 
-	*time_quad0 = ref_clock;
-	*time_quad1 = seconds;
-}
+static int  NPCM7XX_smb_recovery(struct i2c_adapter *_adap);
 
-#define EXT_CLOCK_FREQUENCY_MHZ 25
-#define CNTR25M_ACCURECY	EXT_CLOCK_FREQUENCY_MHZ  // minimum accurecy
+#if IS_ENABLED(CONFIG_I2C_SLAVE)
 
-// Function:	 _npcm7xx_delay_relative
-// Parameters:
-//		 us_delay -  number of microseconds to delay since t0_time.
-//				  if zero: no delay.
-//
-//		t0_time	      - start time , to measure time from.
-// get a time stamp, delay us_delay from it. If us_delay has already passed
-// since the time stamp , then no delay is executed. returns the time elapsed
-// since t0_time
+static int  NPCM7XX_i2c_reg_slave(struct i2c_client *client);
+static int  NPCM7XX_smb_slave_global_call_enable(struct NPCM7XX_i2c *bus,
+						 bool enable);
 
-static inline u32 _npcm7xx_delay_relative(u32 us_delay, u32 t0_time0,
-					  u32 t0_time1)
-{
-	u32 t1_time_0, t1_time_1;
-	u32 time_elapsed;
-	u32 minimum_delay = (us_delay * EXT_CLOCK_FREQUENCY_MHZ)
-		+ CNTR25M_ACCURECY;
+static int  NPCM7XX_smb_slave_ARP_enable(struct NPCM7XX_i2c *bus, bool enable);
+static bool NPCM7XX_smb_slave_start_receive(struct NPCM7XX_i2c *bus, u16 nread,
+					    u8 *read_data);
+static bool NPCM7XX_smb_slave_start_xmit(struct NPCM7XX_i2c *bus, u16 nwrite,
+					 u8 *write_data);
 
-	// this is equivalent to microSec/0.64 + minimal tic length.
-	do {
-		_npcm7xx_get_time_stamp(&t1_time_0, &t1_time_1);
-		time_elapsed = ((EXT_CLOCK_FREQUENCY_MHZ * 1000000) *
-				(t1_time_1 - t0_time1)) +
-				(t1_time_0 - t0_time0);
-	} while (time_elapsed < minimum_delay);
+static int  NPCM7XX_smb_get_current_slave_addr(struct NPCM7XX_i2c *bus,
+					       u8 *currSlaveAddr);
 
-	// return elapsed time
-	return (u32)(time_elapsed / EXT_CLOCK_FREQUENCY_MHZ);
-}
+static int  NPCM7XX_smb_remove_slave_addr(struct NPCM7XX_i2c *bus,
+					  u8 slaveAddrToRemove);
 
-static inline void npcm_smb_select_bank(struct npcm_i2c *bus,
-					enum smb_bank bank)
-{
-	if (bus->fifo_use)
-		iowrite8((ioread8(bus->reg + NPCM_SMBCTL3) & ~SMBCTL3_BNK_SEL) |
-			 FIELD_PREP(SMBCTL3_BNK_SEL, bank),
-			 bus->reg + NPCM_SMBCTL3);
-}
+static int  NPCM7XX_smb_add_slave_addr(struct NPCM7XX_i2c *bus,
+				       u8 slaveAddrToAssign, bool use_PEC);
 
-DECLARE_CRC8_TABLE(npcm7xx_crc8);
+static bool NPCM7XX_smb_is_slave_addr_exist(struct NPCM7XX_i2c *bus, u8 addr);
+static void NPCM7XX_smb_disable(struct NPCM7XX_i2c *bus);
+#if defined (SMB_CAPABILITY_TIMEOUT_SUPPORT)
+static void NPCM7XX_smb_enable_timeout(struct NPCM7XX_i2c *bus, bool enable);
+#endif
+#endif  // CONFIG_I2C_SLAVE
 
-static u8 npcm_smb_calc_crc8(u8 crc_data, u8 data)
-{
-	crc_data = crc8(npcm7xx_crc8, &data, 1, crc_data);
-	return crc_data;
-}
 
-static void npcm_smb_calc_PEC(struct npcm_i2c *bus, u8 data)
-{
-	if (bus->PEC_use)
-		bus->crc_data = npcm_smb_calc_crc8(bus->crc_data, data);
-}
+#ifdef TBD
+static bool NPCM7XX_smb_module_is_busy(struct NPCM7XX_i2c *bus);
+static bool NPCM7XX_smb_bus_is_busy(struct NPCM7XX_i2c *bus);
+static void NPCM7XX_smb_re_enable_module(struct NPCM7XX_i2c *bus);
+static bool NPCM7XX_smb_int_is_pending(void);
+#endif
 
-static inline void npcm_smb_wr_byte(struct npcm_i2c *bus, u8 data)
-{
-	iowrite8(data, bus->reg + NPCM_SMBSDA);
-	npcm_smb_calc_PEC(bus, data);
-}
 
-static inline void npcm_smb_rd_byte(struct npcm_i2c *bus, u8 *data)
-{
-	*data = ioread8(bus->reg + NPCM_SMBSDA);
-	npcm_smb_calc_PEC(bus, *data);
-}
+static void NPCM7XX_smb_set_SCL(struct i2c_adapter *_adap, int level);
+static int  NPCM7XX_smb_get_SCL(struct i2c_adapter *_adap);
+static int  NPCM7XX_smb_get_SDA(struct i2c_adapter *_adap);
 
-static inline u8 npcm_smb_get_PEC(struct npcm_i2c *bus)
-{
-	if (bus->PEC_use)
-		return bus->crc_data;
-	else
-		return 0;
-}
 
-static inline void npcm_smb_write_PEC(struct npcm_i2c *bus)
-{
-	if (bus->PEC_use) {
-		// get PAC value and write to the bus:
-		npcm_smb_wr_byte(bus, npcm_smb_get_PEC(bus));
-	}
-}
 
-//
-//  NPCM7XX SMB module allows writing to SCL and SDA pins directly
-//  without the need to change muxing of pins.
-//  This feature will be used for recovery sequences i.e.
-//
-static void npcm_smb_set_SCL(struct i2c_adapter *_adap, int level)
-{
-#ifdef SMB_CAPABILITY_FORCE_SCL_SDA
-	unsigned long flags;
-	struct npcm_i2c *bus = container_of(_adap, struct npcm_i2c, adap);
+typedef void(*SMB_CALLBACK_T)(struct NPCM7XX_i2c *bus, SMB_STATE_IND_T op_status,
+			      u16 info);
 
-	// Select Bank 0 to access NPCM_SMBCTL4
-	spin_lock_irqsave(&bus->lock, flags);
-	npcm_smb_select_bank(bus, SMB_BANK_0);
+static inline void NPCM7XX_smb_write_byte(struct NPCM7XX_i2c *bus, u8 data);
+static inline bool NPCM7XX_smb_read_byte(struct NPCM7XX_i2c *bus, u8 *data);
+static inline void NPCM7XX_smb_select_bank(struct NPCM7XX_i2c *bus,
+						SMB_BANK_T bank);
+static inline u16  NPCM7XX_smb_get_index(struct NPCM7XX_i2c *bus);
+static inline void NPCM7XX_smb_master_start(struct NPCM7XX_i2c *bus);
+static inline void NPCM7XX_smb_master_stop(struct NPCM7XX_i2c *bus);
+static inline void NPCM7XX_smb_abort_data(struct NPCM7XX_i2c *bus);
+static inline void NPCM7XX_smb_stall_after_start(struct NPCM7XX_i2c *bus,
+						 bool stall);
+static inline void NPCM7XX_smb_nack(struct NPCM7XX_i2c *bus);
+static	void NPCM7XX_smb_reset(struct NPCM7XX_i2c *bus);
+static	void NPCM7XX_smb_int_enable(struct NPCM7XX_i2c *bus, bool enable);
+static	bool NPCM7XX_smb_init_clk(struct NPCM7XX_i2c *bus, SMB_MODE_T mode,
+					  u16 bus_freq);
+static	void NPCM7XX_smb_int_master_handler(struct NPCM7XX_i2c *bus);
+static 	void NPCM7XX_smb_int_master_handler_write(struct NPCM7XX_i2c *bus);
+static 	void NPCM7XX_smb_int_master_handler_read(struct NPCM7XX_i2c *bus);
 
-	// Set SCL_LVL, SDA_LVL bits as Read/Write (R/W)
-	iowrite8(ioread8(bus->reg + NPCM_SMBCTL4) | SMBCTL4_LVL_WE,
-		 bus->reg + NPCM_SMBCTL4);
 
-	// Set level
-	iowrite8((ioread8(bus->reg + NPCM_SMBCTL3)
-		& ~SMBCTL3_SCL_LVL) | FIELD_PREP(SMBCTL3_SCL_LVL,
-		level), bus->reg + NPCM_SMBCTL3);
 
-	// Set SCL_LVL, SDA_LVL bits as Read Only (RO)
-	iowrite8(ioread8(bus->reg + NPCM_SMBCTL4)
-		 & ~SMBCTL4_LVL_WE, bus->reg + NPCM_SMBCTL4);
 
-	// Return to Bank 1
-	npcm_smb_select_bank(bus, SMB_BANK_1);
-	spin_unlock_irqrestore(&bus->lock, flags);
-#endif
-}
+#if IS_ENABLED(CONFIG_I2C_SLAVE)
+static	int  NPCM7XX_smb_int_slave_handler(struct NPCM7XX_i2c *bus);
+static	u8   NPCM7XX_smb_get_slave_addr_l(struct NPCM7XX_i2c *bus,
+						  SMB_ADDR_T addrEnum);
+#endif // CONFIG_I2C_SLAVE
 
-static int npcm_smb_get_SCL(struct i2c_adapter *_adap)
-{
-	unsigned long flags;
-	unsigned int ret = 0;
-	struct npcm_i2c *bus = container_of(_adap, struct npcm_i2c, adap);
+static inline 	void NPCM7XX_smb_eob_int(struct NPCM7XX_i2c *bus, bool enable);
 
-	// Select Bank 0 to access NPCM_SMBCTL4
-	spin_lock_irqsave(&bus->lock, flags);
-	npcm_smb_select_bank(bus, SMB_BANK_0);
+static		void NPCM7XX_smb_write_to_fifo(struct NPCM7XX_i2c *bus,
+					       u16 max_bytes_to_send);
+static inline 	bool NPCM7XX_smb_tx_fifo_full(struct NPCM7XX_i2c *bus);
+static inline 	bool NPCM7XX_smb_rx_fifo_full(struct NPCM7XX_i2c *bus);
+static inline 	void NPCM7XX_smb_clear_tx_fifo(struct NPCM7XX_i2c *bus);
+static inline 	void NPCM7XX_smb_clear_rx_fifo(struct NPCM7XX_i2c *bus);
 
-	// Get SCL level
-	ret = FIELD_GET(SMBCTL3_SCL_LVL,  ioread8(bus->reg + NPCM_SMBCTL3));
 
-	// Return to Bank 1
-	npcm_smb_select_bank(bus, SMB_BANK_1);
-	spin_unlock_irqrestore(&bus->lock, flags);
-	return ret;
-}
+static 		void NPCM7XX_smb_set_fifo(struct NPCM7XX_i2c *bus,
+				int bytes_read, int bytes_write);
+static		void NPCM7XX_smb_calc_PEC(struct NPCM7XX_i2c *bus, u8 data);
+static inline   void NPCM7XX_smb_write_PEC(struct NPCM7XX_i2c *bus);
+static inline   u8   NPCM7XX_smb_get_PEC(struct NPCM7XX_i2c *bus);
+static		void NPCM7XX_smb_callback(struct NPCM7XX_i2c *bus,
+					  SMB_STATE_IND_T op_status, u16 info);
 
-static int npcm_smb_get_SDA(struct i2c_adapter *_adap)
-{
-	unsigned long flags;
-	unsigned int ret = 0;
-	struct npcm_i2c *bus = container_of(_adap, struct npcm_i2c, adap);
 
-	// Select Bank 0 to access NPCM_SMBCTL4
-	spin_lock_irqsave(&bus->lock, flags);
-	npcm_smb_select_bank(bus, SMB_BANK_0);
+// SMB Recovery of the SMBus interface driver
+#if IS_ENABLED(CONFIG_I2C_SLAVE) && defined SMB_RECOVERY_SUPPORT
+static		void	NPCM7XX_smb_slave_abort(struct NPCM7XX_i2c *bus);
+#endif
 
-	// Get SDA level
-	ret = FIELD_GET(SMBCTL3_SDA_LVL,  ioread8(bus->reg + NPCM_SMBCTL3));
+static void inline _npcm7xx_get_time_stamp(u32 time_quad[2]);
+static u32  inline _npcm7xx_delay_relative(u32 us_delay, u32 t0_time[2]);
 
-	// Return to Bank 1
-	npcm_smb_select_bank(bus, SMB_BANK_1);
-	spin_unlock_irqrestore(&bus->lock, flags);
-	return ret;
-}
 
-static inline u16 npcm_smb_get_index(struct npcm_i2c *bus)
+static void inline _npcm7xx_get_time_stamp(u32 time_quad[2])
 {
-	u16 index = 0;
+	u32 seconds, seconds_last;
+	u32 ref_clock;
 
-	if (bus->operation == SMB_READ_OPER)
-		index = bus->rd_ind;
-	else if (bus->operation == SMB_WRITE_OPER)
-		index = bus->wr_ind;
+	regmap_read(clk_regmap, NPCM7XX_SECCNT, &seconds_last);
 
-	return index;
-}
+	do{
+		regmap_read(clk_regmap, NPCM7XX_SECCNT, &seconds);
+		regmap_read(clk_regmap, NPCM7XX_CNTR25M, &ref_clock);
+		regmap_read(clk_regmap, NPCM7XX_SECCNT, &seconds_last);
+	} while (seconds_last != seconds);
 
-// quick protocol:
-static inline bool npcm_smb_is_quick(struct npcm_i2c *bus)
-{
-	if (bus->wr_size == 0 && bus->rd_size == 0)
-		return true;
-	return false;
+	time_quad[0] = ref_clock;
+	time_quad[1] = seconds;
 }
 
-static void npcm_smb_disable(struct npcm_i2c *bus)
-{
-	int i;
+#define EXT_CLOCK_FREQUENCY_MHZ 25
+#define  CNTR25M_ACCURECY  EXT_CLOCK_FREQUENCY_MHZ  // minimum accurecy
 
-	// select bank 0 for SMB addresses
-	npcm_smb_select_bank(bus, SMB_BANK_0);
 
-	// Slave Addresses Removal
-	for (i = SMB_SLAVE_ADDR1; i < SMB_NUM_OF_ADDR; i++)
-		iowrite8(0, bus->reg + NPCM_SMBADDR[i]);
 
-	// select bank 0 for SMB addresses
-	npcm_smb_select_bank(bus, SMB_BANK_1);
+// Function:     _npcm7xx_delay_relative
+// Parameters:
+//               us_delay -  number of microseconds to delay since t0_time.
+//                                if zero: no delay.
+//
+//              t0_time       - start time , to measure time from.
+// get a time stamp, delay us_delay from it. If us_delay has already passed
+// since the time stamp , then no delay is executed. returns the time elapsed
+// since t0_time
+
+static u32  inline _npcm7xx_delay_relative(u32 us_delay, u32 t0_time[2]){
 
-	// Disable module.
-	iowrite8(ioread8(bus->reg + NPCM_SMBCTL2) & ~SMBCTL2_ENABLE,
-		 bus->reg + NPCM_SMBCTL2);
+	u32 iUsCnt2[2];
+	u32 timeElapsedSince;  // Acctual delay generated by FW
+	u32 minimum_delay = (us_delay * EXT_CLOCK_FREQUENCY_MHZ)
+		+ CNTR25M_ACCURECY;
 
-	// Set module disable
-	bus->state = SMB_DISABLE;
-}
+	// this is equivalent to microSec/0.64 + minimal tic length.
+	do {
+		_npcm7xx_get_time_stamp(iUsCnt2);
+		timeElapsedSince = ((EXT_CLOCK_FREQUENCY_MHZ*_1MHz_)*
+				    (iUsCnt2[1] - t0_time[1])) +
+				    (iUsCnt2[0] - t0_time[0]);
+	} while (timeElapsedSince < minimum_delay);
 
-static void npcm_smb_enable(struct npcm_i2c *bus)
-{
-	iowrite8((ioread8(bus->reg + NPCM_SMBCTL2) | SMBCTL2_ENABLE),
-		 bus->reg + NPCM_SMBCTL2);
+	// return elapsed time
+	return (u32)(timeElapsedSince / EXT_CLOCK_FREQUENCY_MHZ);
 }
 
-// enable\disable end of busy (EOB) interrupt
-static inline void npcm_smb_eob_int(struct npcm_i2c *bus, bool enable)
-{
-	if (enable) {
-		iowrite8((ioread8(bus->reg + NPCM_SMBCTL1) |
-			 NPCM_SMBCTL1_EOBINTE)  & ~NPCM_SMBCTL1_RWS_FIELDS,
-			 bus->reg + NPCM_SMBCTL1);
-	} else {
-		iowrite8(ioread8(bus->reg + NPCM_SMBCTL1) &
-			 ~NPCM_SMBCTL1_EOBINTE & ~NPCM_SMBCTL1_RWS_FIELDS,
-			 bus->reg + NPCM_SMBCTL1);
 
-		// Clear EO_BUSY pending bit:
-		iowrite8(ioread8(bus->reg + NPCM_SMBCST3) |
-			 NPCM_SMBCST3_EO_BUSY, bus->reg + NPCM_SMBCST3);
-	}
-}
 
-static inline bool npcm_smb_tx_fifo_full(struct npcm_i2c *bus)
+static inline void NPCM7XX_smb_write_byte(struct NPCM7XX_i2c *bus, u8 data)
 {
-	// check if TX FIFO full:
-	return (bool)FIELD_GET(NPCM_SMBTXF_STS_TX_THST,
-			       ioread8(bus->reg + NPCM_SMBTXF_STS));
-}
+	I2C_DEBUG2("\t\tSDA master bus%d wr 0x%x\n", bus->num, data);
 
-static inline bool npcm_smb_rx_fifo_full(struct npcm_i2c *bus)
-{
-	// check if RX FIFO full:
-	return (bool)FIELD_GET(NPCM_SMBRXF_STS_RX_THST,
-			       ioread8(bus->reg + NPCM_SMBRXF_STS));
+	iowrite8(data, NPCM7XX_SMBSDA(bus));
+	NPCM7XX_smb_calc_PEC(bus, data);
 }
 
-static inline void npcm_smb_clear_tx_fifo(struct npcm_i2c *bus)
+static inline bool NPCM7XX_smb_read_byte(struct NPCM7XX_i2c *bus, u8 *data)
 {
-	// clear TX FIFO:
-	iowrite8(ioread8(bus->reg + NPCM_SMBTXF_STS) |
-		 NPCM_SMBTXF_STS_TX_THST,
-		 bus->reg + NPCM_SMBTXF_STS);
+	*data = ioread8(NPCM7XX_SMBSDA(bus));
+	I2C_DEBUG2("\t\tSDA master bus%d rd 0x%x\n", bus->num, *data);
+	NPCM7XX_smb_calc_PEC(bus, *data);
+	return true;
 }
 
-static inline void npcm_smb_clear_rx_fifo(struct npcm_i2c *bus)
+static inline void NPCM7XX_smb_select_bank(struct NPCM7XX_i2c *bus,
+						SMB_BANK_T  bank)
 {
-	// clear RX FIFO:
-	iowrite8(ioread8(bus->reg + NPCM_SMBRXF_STS) |
-			 NPCM_SMBRXF_STS_RX_THST,
-			 bus->reg + NPCM_SMBRXF_STS);
+	if (bus->fifo_use == true)
+		iowrite8((ioread8(NPCM7XX_SMBCTL3(bus)) & ~SMBCTL3_BNK_SEL) |
+		FIELD_PREP(SMBCTL3_BNK_SEL, bank), NPCM7XX_SMBCTL3(bus));
 }
 
-static void npcm_smb_int_enable(struct npcm_i2c *bus, bool enable)
+
+static inline u16 NPCM7XX_smb_get_index(struct NPCM7XX_i2c *bus)
 {
-	if (enable)
-		iowrite8((ioread8(bus->reg + NPCM_SMBCTL1) |
-			 NPCM_SMBCTL1_INTEN) & ~NPCM_SMBCTL1_RWS_FIELDS,
-			 bus->reg + NPCM_SMBCTL1);
+	u16 index = 0;
+
+	if (bus->operation == SMB_READ_OPER)
+		index = bus->rd_ind;
 	else
-		iowrite8((ioread8(bus->reg + NPCM_SMBCTL1) &
-			 ~NPCM_SMBCTL1_INTEN) & ~NPCM_SMBCTL1_RWS_FIELDS,
-			 bus->reg + NPCM_SMBCTL1);
+	if (bus->operation == SMB_WRITE_OPER)
+		index = bus->wr_ind;
+
+	return index;
 }
 
-static inline void npcm_smb_master_start(struct npcm_i2c *bus)
+
+
+static inline void NPCM7XX_smb_master_start(struct NPCM7XX_i2c *bus)
 {
-	NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_START);
+	NPCM7XX_I2C_EVENT_LOG(NPCM7XX_I2C_EVENT_START);
+
+	iowrite8(ioread8(NPCM7XX_SMBCTL1(bus)) | NPCM7XX_SMBCTL1_START,
+		 NPCM7XX_SMBCTL1(bus));
 
-	iowrite8((ioread8(bus->reg + NPCM_SMBCTL1) | NPCM_SMBCTL1_START) &
-		 ~(NPCM_SMBCTL1_STOP | NPCM_SMBCTL1_ACK),
-		 bus->reg + NPCM_SMBCTL1);
 }
 
-static inline void npcm_smb_master_stop(struct npcm_i2c *bus)
+static inline void NPCM7XX_smb_master_stop(struct NPCM7XX_i2c *bus)
 {
-	NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_STOP);
+	NPCM7XX_I2C_EVENT_LOG(NPCM7XX_I2C_EVENT_STOP);
 
+#ifdef SMB_SW_BYPASS_HW_ISSUE_SMB_STOP
 	// override HW issue: SMBus may fail to supply stop condition in Master
 	// Write operation.
 	// Need to delay at least 5 us from the last int, before issueing a stop
-	_npcm7xx_delay_relative(5, bus->int_time_stamp[0],
-				bus->int_time_stamp[1]);
+	_npcm7xx_delay_relative(5, bus->int_time_stamp);
+
+#endif //   SMB_SW_BYPASS_HW_ISSUE_SMB_STOP
+
+	iowrite8(ioread8(NPCM7XX_SMBCTL1(bus)) | NPCM7XX_SMBCTL1_STOP,
+		 NPCM7XX_SMBCTL1(bus));
 
-	iowrite8((ioread8(bus->reg + NPCM_SMBCTL1) | NPCM_SMBCTL1_STOP) &
-		 ~(NPCM_SMBCTL1_START | NPCM_SMBCTL1_ACK),
-		 bus->reg + NPCM_SMBCTL1);
 
 	if (bus->fifo_use) {
-		npcm_smb_select_bank(bus, SMB_BANK_1);
+		NPCM7XX_smb_select_bank(bus, SMB_BANK_1);
 
-		if (bus->operation == SMB_READ_OPER)
-			npcm_smb_clear_rx_fifo(bus);
-		else
-			npcm_smb_clear_tx_fifo(bus);
+		NPCM7XX_smb_clear_rx_fifo(bus);
 
-		iowrite8(ioread8(bus->reg + NPCM_SMBFIF_CTS) |
-				 NPCM_SMBFIF_CTS_SLVRSTR |
-				 NPCM_SMBFIF_CTS_RXF_TXE,
-				 bus->reg + NPCM_SMBFIF_CTS);
+		iowrite8(ioread8(NPCM7XX_SMBFIF_CTS(bus)) |
+				 NPCM7XX_SMBFIF_CTS_SLVRSTR |
+				 NPCM7XX_SMBFIF_CTS_RXF_TXE,
+				 NPCM7XX_SMBFIF_CTS(bus));
 
-		iowrite8(0, bus->reg + NPCM_SMBTXF_CTL);
+		iowrite8(0, NPCM7XX_SMBTXF_CTL(bus));
 	}
+
+
 }
 
-static inline void npcm_smb_abort_data(struct npcm_i2c *bus)
+static inline void NPCM7XX_smb_abort_data(struct NPCM7XX_i2c *bus)
 {
-	unsigned int timeout = ABORT_TIMEOUT;
-	u8 data;
+	volatile unsigned int timeout = ABORT_TIMEOUT;
+
+	NPCM7XX_I2C_EVENT_LOG(NPCM7XX_I2C_EVENT_ABORT);
 
-	NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_ABORT);
 	// Generate a STOP condition
-	npcm_smb_master_stop(bus);
-	npcm_smb_rd_byte(bus, &data);
+	NPCM7XX_smb_master_stop(bus);
 
 	// Clear NEGACK, STASTR and BER bits
-	iowrite8(NPCM_SMBST_STASTR | NPCM_SMBST_NEGACK |
-		NPCM_SMBST_BER, bus->reg + NPCM_SMBST);
+	iowrite8(NPCM7XX_SMBST_STASTR | NPCM7XX_SMBST_NEGACK | NPCM7XX_SMBST_BER,
+		 NPCM7XX_SMBST(bus));
 
 	// Wait till STOP condition is generated
-	while (FIELD_GET(NPCM_SMBCTL1_STOP, ioread8(bus->reg + NPCM_SMBCTL1))) {
-		timeout--;
-		if (!FIELD_GET(NPCM_SMBCTL1_STOP,
-			       ioread8(bus->reg + NPCM_SMBCTL1)))
-			break;
-		if (timeout <= 1) {
-			dev_err(bus->dev, "%s, abort timeout!\n", __func__);
-			break;
-		}
-	}
+	while (--timeout)
+	if (!FIELD_GET(NPCM7XX_SMBCTL1_STOP, ioread8(NPCM7XX_SMBCTL1(bus))))
+		break;
+
+	if (timeout <= 1)
+		printk("NPCM7XX_smb_abort_data: abort timeout!\n");
 }
 
-static inline void npcm_smb_stall_after_start(struct npcm_i2c *bus, bool stall)
+
+static inline void NPCM7XX_smb_stall_after_start(struct NPCM7XX_i2c *bus,
+			bool stall)
 {
-	if (stall)
-		iowrite8((ioread8(bus->reg + NPCM_SMBCTL1) |
-			 NPCM_SMBCTL1_STASTRE)  & ~NPCM_SMBCTL1_RWS_FIELDS,
-			 bus->reg + NPCM_SMBCTL1);
-	else
-		iowrite8((ioread8(bus->reg + NPCM_SMBCTL1) &
-			 ~NPCM_SMBCTL1_STASTRE)  & ~NPCM_SMBCTL1_RWS_FIELDS,
-			 bus->reg + NPCM_SMBCTL1);
+	I2C_DEBUG2("\t\tSDA stall bus%d\n", bus->num);
+	iowrite8((ioread8(NPCM7XX_SMBCTL1(bus))
+		& ~NPCM7XX_SMBCTL1_STASTRE)
+		| FIELD_PREP(NPCM7XX_SMBCTL1_STASTRE, stall),
+		NPCM7XX_SMBCTL1(bus));
 }
 
-static inline void npcm_smb_nack(struct npcm_i2c *bus)
+static inline void NPCM7XX_smb_nack(struct NPCM7XX_i2c *bus)
 {
 	if (bus->rd_ind < (bus->rd_size - 1))
-		dev_info(bus->dev,
-			 "\tNACK err bus%d, SA=0x%x, rd(%d\%d), op=%d st=%d\n",
-			 bus->num, bus->dest_addr, bus->rd_ind, bus->rd_size,
-			 bus->operation, bus->state);
-	iowrite8((ioread8(bus->reg + NPCM_SMBCTL1) | NPCM_SMBCTL1_ACK) &
-		 ~(NPCM_SMBCTL1_STOP | NPCM_SMBCTL1_START),
-		 bus->reg + NPCM_SMBCTL1);
+		I2C_DEBUG("\tNACK error! bus%d, SA=0x%x, read (%d, from %d), op=%d state=%d\n",
+				bus->num, bus->dest_addr,bus->rd_ind, bus->rd_size ,
+				bus->operation, bus->state);
+	iowrite8(ioread8(NPCM7XX_SMBCTL1(bus)) | NPCM7XX_SMBCTL1_ACK,
+		 NPCM7XX_SMBCTL1(bus));
 }
 
-static void npcm_smb_reset(struct npcm_i2c *bus)
+
+static void NPCM7XX_smb_disable(struct NPCM7XX_i2c *bus)
 {
-	// Save NPCM_SMBCTL1 relevant bits. It is being cleared when the
-	// module is disabled
-	u8 smbctl1 = ioread8(bus->reg + NPCM_SMBCTL1) & (NPCM_SMBCTL1_GCMEN
-						      | NPCM_SMBCTL1_INTEN
-						      | NPCM_SMBCTL1_NMINTE);
+	int i;
 
-	// Disable the SMB module
-	iowrite8((ioread8(bus->reg + NPCM_SMBCTL2) & ~SMBCTL2_ENABLE),
-		 bus->reg + NPCM_SMBCTL2);
+	// Slave Addresses Removal
+	for (i = SMB_SLAVE_ADDR1; i < SMB_NUM_OF_ADDR; i++)
+		iowrite8(0, NPCM7XX_SMBADDR(bus, i));
 
-	// Enable the SMB module
-	npcm_smb_enable(bus);
+	// Disable module.
+	iowrite8((ioread8(NPCM7XX_SMBCTL2(bus))
+		& ~SMBCTL2_ENABLE) | FIELD_PREP(SMBCTL2_ENABLE,
+		DISABLE), NPCM7XX_SMBCTL2(bus));
 
-	// Restore NPCM_SMBCTL1 status
-	iowrite8(smbctl1 & ~NPCM_SMBCTL1_RWS_FIELDS, bus->reg + NPCM_SMBCTL1);
+	// Set module disable
+	bus->state = SMB_DISABLE;
+}
 
-	// Reset driver status
-	bus->state = SMB_IDLE;
-	//
-	// Configure FIFO disabled mode so slave will not use fifo
-	//  (master will set it on if supported)
-	iowrite8(ioread8(bus->reg + NPCM_SMBFIF_CTL) &
-		~NPCM_SMBFIF_CTL_FIFO_EN,
-		bus->reg + NPCM_SMBFIF_CTL);
-	bus->fifo_use = false;
+static bool NPCM7XX_smb_enable(struct NPCM7XX_i2c *bus)
+{
+	iowrite8((ioread8(NPCM7XX_SMBCTL2(bus)) & ~SMBCTL2_ENABLE) |
+		 FIELD_PREP(SMBCTL2_ENABLE,
+		 ENABLE), NPCM7XX_SMBCTL2(bus));
+	return true;
 }
 
-static inline bool npcm_smb_is_master(struct npcm_i2c *bus)
+static bool NPCM7XX_smb_init_module(struct NPCM7XX_i2c *bus, SMB_MODE_T mode,
+				    u16 bus_freq)
 {
-	return (bool)FIELD_GET(NPCM_SMBST_MASTER,
-			       ioread8(bus->reg + NPCM_SMBST));
+	int	i;
+
+	// Check whether module already enabled or frequency is out of bounds
+	if (((bus->state != SMB_DISABLE) &&
+		(bus->state != SMB_IDLE)) ||
+		(bus_freq < SMBUS_FREQ_MIN) || (bus_freq > SMBUS_FREQ_MAX))
+		return false;
+
+
+	// Configure FIFO disabled mode so slave will not use fifo
+	// (maste will set it on if supported)
+
+	bus->threshold_fifo = SMBUS_FIFO_SIZE;
+	//@@: fifo_use is true in the previous version.
+	//iowrite8(ioread8(NPCM7XX_SMBFIF_CTL(bus)) & ~NPCM7XX_SMBFIF_CTL_FIFO_EN,
+	//	 NPCM7XX_SMBFIF_CTL(bus));
+    //@@: fifo_use is true in the previous version.
+	//bus->fifo_use = false;
+	if (SMB_FIFO(bus) && FIELD_GET(SMB_VER_FIFO_EN, ioread8(SMB_VER(bus)))){
+		bus->fifo_use = true;
+		iowrite8(ioread8(NPCM7XX_SMBFIF_CTL(bus)) | NPCM7XX_SMBFIF_CTL_FIFO_EN,
+			 NPCM7XX_SMBFIF_CTL(bus));
+	}
+
+	// Configure SMB module clock frequency
+	if (!NPCM7XX_smb_init_clk(bus, mode, bus_freq)) {
+		pr_err("NPCM7XX_smb_init_clk failed\n");
+		return false;
+	}
+
+	NPCM7XX_smb_select_bank(bus, SMB_BANK_0); // select bank 0 for SMB addresses
+
+	// Configure slave addresses (by default they are disabled)
+	for (i = 0; i < SMB_NUM_OF_ADDR; i++)
+		iowrite8(0, NPCM7XX_SMBADDR(bus, i));
+
+	NPCM7XX_smb_select_bank(bus, SMB_BANK_1); // by default most access is in bank 1
+
+	// Enable module - before configuring CTL1 !
+	if (!NPCM7XX_smb_enable(bus))
+		return false;
+	else
+		bus->state = SMB_IDLE;
+
+	// Enable SMB int and New Address Match int source
+	iowrite8((ioread8(NPCM7XX_SMBCTL1(bus)) & ~NPCM7XX_SMBCTL1_NMINTE)
+		 | FIELD_PREP(NPCM7XX_SMBCTL1_NMINTE,
+		 ENABLE), NPCM7XX_SMBCTL1(bus));
+	NPCM7XX_smb_int_enable(bus, true);
+
+	return true;
 }
 
-static int npcm_smb_master_abort(struct npcm_i2c *bus)
+
+#if IS_ENABLED(CONFIG_I2C_SLAVE)
+static int  NPCM7XX_smb_slave_enable_l(struct NPCM7XX_i2c *bus,
+				       SMB_ADDR_T addr_type, u8 addr, bool enable)
 {
-	int ret = -(EIO);
+	u8 SmbAddrX_Addr = FIELD_PREP(NPCM7XX_SMBADDRx_ADDR, addr) |
+		FIELD_PREP(NPCM7XX_SMBADDRx_SAEN, enable);
+
+	if (addr_type == SMB_GC_ADDR) {
+		iowrite8((ioread8(NPCM7XX_SMBCTL1(bus)) &
+			~NPCM7XX_SMBCTL1_GCMEN) |
+			FIELD_PREP(NPCM7XX_SMBCTL1_GCMEN, enable),
+			NPCM7XX_SMBCTL1(bus));
+		return 0;
+	}
+	if (addr_type == SMB_ARP_ADDR) {
 
-	// Only current master is allowed to issue Stop Condition
-	if (npcm_smb_is_master(bus)) {
-		npcm_smb_abort_data(bus);
-		ret = 0;
+		iowrite8((ioread8(NPCM7XX_SMBCTL3(bus)) &
+			~SMBCTL3_ARPMEN) |
+			FIELD_PREP(SMBCTL3_ARPMEN, enable),
+			NPCM7XX_SMBCTL3(bus));
+		return 0;
 	}
+	if (addr_type >= SMB_NUM_OF_ADDR)
+		return -EFAULT;
 
-	npcm_smb_reset(bus);
+	// Disable ints and select bank 0 for address 3 to ...
+	NPCM7XX_smb_select_bank(bus, SMB_BANK_0);
 
-	return ret;
+	// Set and enable the address
+	iowrite8(SmbAddrX_Addr, NPCM7XX_SMBADDR(bus, addr_type));
+
+	// return to bank 1 and enable ints (if needed)
+	NPCM7XX_smb_select_bank(bus, SMB_BANK_1);
+
+	return 0;
 }
 
-static void npcm_smb_callback(struct npcm_i2c *bus,
-			      enum smb_state_ind op_status, u16 info)
+static u8 NPCM7XX_smb_get_slave_addr_l(struct NPCM7XX_i2c *bus,
+				       SMB_ADDR_T addrEnum)
 {
-	struct i2c_msg *msgs = bus->msgs;
-	int msgs_num = bus->msgs_num;
+	unsigned long flags;
+	u8 slaveAddress;
 
-	switch (op_status) {
-	case SMB_MASTER_DONE_IND:
-	// Master transaction finished and all transmit bytes were sent
-	// info: number of bytes actually received after the Master
-	//	receive operation (if Master didn't issue receive it
-	//	should be 0)
-	// Notify that not all data was received on Master or Slave
-	// info:
-	//	on receive: number of actual bytes received
-	//	when PEC is used even if 'info' is the expected number
-	//	of bytes, it means that PEC error occurred.
-	{
-		if (msgs[0].flags & I2C_M_RD)
-			msgs[0].len = info;
-		else if (msgs_num == 2 && msgs[1].flags & I2C_M_RD)
-			msgs[1].len = info;
-
-		bus->cmd_err = 0;
-		complete(&bus->cmd_complete);
-	}
-	break;
-
-	case SMB_NO_DATA_IND:
-	// Notify that not all data was received on Master or Slave
-	// info:
-	//on receive: number of actual bytes received
-	//	when PEC is used even if 'info' is the expected number
-	//	of bytes,it means that PEC error occurred.
-	{
-		if (msgs[0].flags & I2C_M_RD)
-			msgs[0].len = info;
-		else if (msgs_num == 2 && msgs[1].flags & I2C_M_RD)
-			msgs[1].len = info;
+	// disable ints and select bank 0 for address 3 to ...
+	spin_lock_irqsave(&bus->lock, flags);
+	NPCM7XX_smb_select_bank(bus, SMB_BANK_0);
+
+	slaveAddress = ioread8(NPCM7XX_SMBADDR(bus, addrEnum));
+
+	// return to bank 1 and enable ints (if needed)
+	NPCM7XX_smb_select_bank(bus, SMB_BANK_1);
+	spin_unlock_irqrestore(&bus->lock, flags);
+
+	return  slaveAddress;
+}
+
+static bool NPCM7XX_smb_is_slave_addr_exist(struct NPCM7XX_i2c *bus, u8 addr)
+{
+	int i;
+
+	addr |= 0x80; //Set the enable bit
+
+	for (i = SMB_SLAVE_ADDR1; i < SMB_NUM_OF_ADDR; i++)
+		if (addr == NPCM7XX_smb_get_slave_addr_l(bus, (SMB_ADDR_T)i))
+			return true;
 
-		bus->cmd_err = -EFAULT;
-		complete(&bus->cmd_complete);
+	return false;
+}
+
+static int  NPCM7XX_smb_add_slave_addr(struct NPCM7XX_i2c *bus,
+				       u8 slaveAddrToAssign, bool use_PEC)
+{
+	u16 i;
+	int ret = -EFAULT;
+	I2C_DEBUG("slaveAddrToAssign = %02X\n", slaveAddrToAssign);
+
+    //@@: right shift 1 bit for the register format.
+    slaveAddrToAssign >>= 1;
+	slaveAddrToAssign |= 0x80; //set the enable bit
+
+	for (i = SMB_SLAVE_ADDR1; i < SMB_NUM_OF_ADDR; i++) {
+		u8 currentSlaveAddr = NPCM7XX_smb_get_slave_addr_l(bus,
+								   (SMB_ADDR_T)i);
+		//@@:
+        //printk("currentSlaveAddr: %02X\r\n", currentSlaveAddr);
+		if (currentSlaveAddr == slaveAddrToAssign) {
+			ret = 0;
+			break;
+		}
+		else if ((currentSlaveAddr & 0x7F) == 0) {
+			ret = NPCM7XX_smb_slave_enable_l(bus,
+							 (SMB_ADDR_T)i, slaveAddrToAssign, true);
+			break;
+		}
 	}
-	break;
-	case SMB_NACK_IND:
-		// MASTER transmit got a NAK before transmitting all bytes
-		// info: number of transmitted bytes
-		bus->cmd_err = -EAGAIN;
-		complete(&bus->cmd_complete);
 
-		break;
-	case SMB_BUS_ERR_IND:
-		// Bus error
-		// info: has no meaning
-		bus->cmd_err = -EIO;
-		complete(&bus->cmd_complete);
-		break;
-	case SMB_WAKE_UP_IND:
-		// SMBus wake up
-		// info: has no meaning
-		break;
-	default:
-		break;
+	if (ret == 0) {
+		if (use_PEC)
+			bus->PEC_mask |= 1 << i;
+		else
+			bus->PEC_mask &= ~(1 << i);
 	}
+	return ret;
 }
 
-static u32 npcm_smb_get_fifo_fullness(struct npcm_i2c *bus)
+static int  NPCM7XX_smb_remove_slave_addr(struct NPCM7XX_i2c *bus,
+					  u8 slaveAddrToRemove)
 {
-	if (bus->operation == SMB_WRITE_OPER)
-		return FIELD_GET(NPCM_SMBTXF_STS_TX_BYTES,
-				 ioread8(bus->reg + NPCM_SMBTXF_STS));
-	else if (bus->operation == SMB_READ_OPER)
-		return FIELD_GET(NPCM_SMBRXF_STS_RX_BYTES,
-				 ioread8(bus->reg + NPCM_SMBRXF_STS));
+	int i;
+	unsigned long flags;
+
+	slaveAddrToRemove |= 0x80; //Set the enable bit
+
+	// disable ints and select bank 0 for address 3 to ...
+	spin_lock_irqsave(&bus->lock, flags);
+	NPCM7XX_smb_select_bank(bus, SMB_BANK_0);
+
+	for (i = SMB_SLAVE_ADDR1; i < SMB_NUM_OF_ADDR; i++) {
+		if (ioread8(NPCM7XX_SMBADDR(bus, i)) == slaveAddrToRemove)
+			iowrite8(0, NPCM7XX_SMBADDR(bus, i));
+	}
+
+	// return to bank 1 and enable ints (if needed)
+	NPCM7XX_smb_select_bank(bus, SMB_BANK_1);
+	spin_unlock_irqrestore(&bus->lock, flags);
+
 	return 0;
 }
 
-static void npcm_smb_write_to_fifo(struct npcm_i2c *bus, u16 max_bytes_to_send)
+static int  NPCM7XX_smb_slave_global_call_enable(struct NPCM7XX_i2c *bus,
+						 bool enable)
+{
+	return NPCM7XX_smb_slave_enable_l(bus, SMB_GC_ADDR, 0, enable);
+}
+
+static int  NPCM7XX_smb_slave_ARP_enable(struct NPCM7XX_i2c *bus, bool enable)
+{
+	return NPCM7XX_smb_slave_enable_l(bus, SMB_ARP_ADDR, 0, enable);
+}
+
+#endif  // CONFIG_I2C_SLAVE
+
+
+
+
+static bool NPCM7XX_smb_master_start_xmit(struct NPCM7XX_i2c *bus, u8 slave_addr,
+					  u16 nwrite, u16 nread, u8 *write_data,
+					  u8 *read_data, bool use_PEC)
+{
+#ifdef CONFIG_NPCM750_I2C_DEBUG
+	I2C_DEBUG2("bus%d slave_addr=%x nwrite=%d nread=%d write_data=%p "
+		   "read_data=%p use_PEC=%d",
+		   bus->num, slave_addr, nwrite, nread, write_data,
+		   read_data, use_PEC);
+	if (nwrite && nwrite != SMB_QUICK_PROT) {
+		int i;
+		char str[32 * 3 + 4];
+		char *s = str;
+		for (i = 0; (i < nwrite && i < 32); i++)
+			s += sprintf(s, "%02x ", write_data[i]);
+		I2C_DEBUG2("\t\t\twrite_data = %s\n", str);
+	}
+#endif
+
+	//
+	// Allow only if bus is not busy
+	//
+	if ((bus->state != SMB_IDLE)
+#if defined SMBUS_SIZE_CHECK
+	    ||
+	    ((nwrite >= _32KB_)
+	    && (nwrite != SMB_QUICK_PROT)) ||
+	    ((nread >= _32KB_) && (nread != SMB_BLOCK_PROT)
+	    && (nread != SMB_QUICK_PROT))
+#endif
+	    )	{
+		I2C_DEBUG("\tbus%d->state != SMB_IDLE\n", bus->num);
+		return false;
+	}
+
+
+	//
+	// Configure FIFO mode only for master mode Slave mode for linux will not use fifo
+	//
+	if (SMB_FIFO(bus) && FIELD_GET(SMB_VER_FIFO_EN, ioread8(SMB_VER(bus)))){
+		bus->fifo_use = true;
+		iowrite8(ioread8(NPCM7XX_SMBFIF_CTL(bus)) | NPCM7XX_SMBFIF_CTL_FIFO_EN,
+			 NPCM7XX_SMBFIF_CTL(bus));
+	}
+	else
+		bus->fifo_use = false;
+
+
+	// Update driver state
+	bus->master_or_slave = SMB_MASTER;
+	//printk("line:%d master on bus%d\n", __LINE__, bus->num);
+	bus->state = SMB_MASTER_START;
+	if (nwrite > 0)
+		bus->operation = SMB_WRITE_OPER;
+	else
+		bus->operation = SMB_READ_OPER;
+
+
+
+	if ((nwrite == 0) && (nread == 0))
+		nwrite = nread = SMB_QUICK_PROT;
+
+
+	bus->dest_addr = (u8)(slave_addr << 1);// Translate 7bit to 8bit format
+	bus->write_data_buf = write_data;
+	bus->wr_size = nwrite;
+	bus->wr_ind = 0;
+	bus->read_data_buf = read_data;
+	bus->rd_size = nread;
+	bus->rd_ind = 0;
+	bus->PEC_use = use_PEC;
+	bus->read_block_use = false;
+	bus->retry_count = SMB_RETRY_MAX_COUNT;
+
+	// Check if transaction uses Block read protocol
+	if ((bus->rd_size == SMB_BLOCK_PROT) ||
+	    (bus->rd_size == SMB_EXCLUDE_BLOCK_SIZE_FROM_BUF)) {
+		bus->read_block_use = true;
+
+		// Change nread in order to configure receive threshold to 1
+		nread = 1;
+	}
+
+	// clear BER just in case it is set due to a previous transaction
+	iowrite8(NPCM7XX_SMBST_BER, NPCM7XX_SMBST(bus));
+
+
+	// Initiate SMBus master transaction
+	// Generate a Start condition on the SMBus
+	if (bus->fifo_use == true) {
+		// select bank 1 for FIFO regs
+		NPCM7XX_smb_select_bank(bus, SMB_BANK_1);
+
+		// clear FIFO and relevant status bits.
+		iowrite8(ioread8(NPCM7XX_SMBFIF_CTS(bus))
+			 | NPCM7XX_SMBFIF_CTS_SLVRSTR
+			 | NPCM7XX_SMBFIF_CTS_CLR_FIFO
+			 | NPCM7XX_SMBFIF_CTS_RXF_TXE, NPCM7XX_SMBFIF_CTS(bus));
+
+		if (bus->operation == SMB_READ_OPER) {
+			//This is a read only operation. Configure the FIFO
+			//threshold according to the needed # of bytes to read.
+
+			NPCM7XX_smb_set_fifo(bus, nread, -1);
+
+		}
+		else if (bus->operation == SMB_WRITE_OPER) {
+			NPCM7XX_smb_set_fifo(bus, -1, nwrite);
+		}
+	}
+
+	bus->int_cnt = 100;
+	bus->event_log = 0;
+
+	NPCM7XX_smb_master_start(bus);
+
+	return true;
+}
+
+
+
+#if IS_ENABLED(CONFIG_I2C_SLAVE)
+static bool NPCM7XX_smb_slave_start_receive(struct NPCM7XX_i2c *bus, u16 nread,
+					    u8 *read_data)
+{
+
+	// Allow only if bus is not busy
+	if ((bus->state != SMB_SLAVE_MATCH)
+#if defined SMBUS_SIZE_CHECK
+	    ||
+	    ((nread >= _32KB_) && (nread != SMB_BLOCK_PROT)
+	    && (nread != SMB_QUICK_PROT))
+#endif
+	    )
+	    return false;
+
+	// Update driver state
+	bus->state = SMB_OPER_STARTED;
+	bus->operation	 = SMB_READ_OPER;
+	bus->read_data_buf   = read_data;
+	bus->rd_size	 = nread;
+	bus->rd_ind	= 0;
+	bus->wr_size	= 0;
+	bus->wr_ind	= 0;
+
+	if (bus->fifo_use == true) {
+		if (nread > 0) {
+			u8 smbrxf_ctl;
+
+			if (nread <= SMBUS_FIFO_SIZE) {
+				smbrxf_ctl =
+					FIELD_PREP(NPCM7XX_SMBRXF_CTL_THR_RXIE, 0);
+				smbrxf_ctl |= FIELD_PREP(NPCM7XX_SMBRXF_CTL_RX_THR, nread);
+			}
+			else {
+				// if threshold_fifo != SMBUS_FIFO_SIZE set NPCM7XX_SMBRXF_CTL.THR_RXIE to 1 otherwise to 0
+				smbrxf_ctl =
+					FIELD_PREP(NPCM7XX_SMBRXF_CTL_RX_THR, bus->threshold_fifo) |
+					FIELD_PREP(NPCM7XX_SMBRXF_CTL_THR_RXIE, (bool)(bus->threshold_fifo != SMBUS_FIFO_SIZE));
+			}
+			iowrite8(smbrxf_ctl, NPCM7XX_SMBRXF_CTL(bus));
+		}
+
+		// triggers new data reception
+		iowrite8(NPCM7XX_SMBST_NMATCH, NPCM7XX_SMBST(bus));
+	}
+
+	//-------------------------------------------------------------------------------------------------
+	// triggers new data reception (relevant both when fifo is used or not used)
+	//-------------------------------------------------------------------------------------------------
+	//@@: Unsure, just comment out for now.
+	//iowrite8(NPCM7XX_SMBST_NMATCH, NPCM7XX_SMBST(bus));
+
+	return true;
+}
+
+static bool NPCM7XX_smb_slave_start_xmit(struct NPCM7XX_i2c *bus, u16 nwrite,
+					 u8 *write_data)
+{
+
+	// Allow only if bus is not busy
+	if ((bus->state != SMB_SLAVE_MATCH) || (nwrite == 0))
+		return false;
+
+
+	// Update driver state
+	if (bus->PEC_use)
+		nwrite++;
+
+	bus->state = SMB_OPER_STARTED;
+	bus->operation	 = SMB_WRITE_OPER;
+	bus->write_data_buf  = write_data;
+	bus->wr_size	= nwrite;
+	bus->wr_ind	= 0;
+
+	if (bus->fifo_use == true) {
+		// triggers new data reception
+		iowrite8(NPCM7XX_SMBST_NMATCH, NPCM7XX_SMBST(bus));
+
+		if (nwrite > 0) {
+			u8 smbtxf_ctl;
+
+			if (nwrite <= SMBUS_FIFO_SIZE)
+				smbtxf_ctl = FIELD_PREP(NPCM7XX_SMBTXF_CTL_THR_TXIE, 0)
+				| FIELD_PREP(NPCM7XX_SMBTXF_CTL_TX_THR, 0);
+			else
+				// if threshold_fifo != SMBUS_FIFO_SIZE set NPCM7XX_SMBTXF_CTL.THR_TXIE to 1 otherwise to 0
+				smbtxf_ctl = FIELD_PREP
+				(NPCM7XX_SMBTXF_CTL_THR_TXIE,
+				(bool)(bus->threshold_fifo != SMBUS_FIFO_SIZE))
+				| FIELD_PREP(NPCM7XX_SMBTXF_CTL_TX_THR,
+				SMBUS_FIFO_SIZE - bus->threshold_fifo);
+
+			iowrite8(smbtxf_ctl, NPCM7XX_SMBTXF_CTL(bus));
+
+			// TODO: replace with :	NPCM7XX_smb_set_fifo(bus, -1, wcount);
+
+			// Fill the FIFO with data
+			NPCM7XX_smb_write_to_fifo(bus, min((u16)SMBUS_FIFO_SIZE, nwrite));
+		}
+	}
+	else // bus->fifo_use == FALSE
+		NPCM7XX_smb_write_byte(bus, bus->write_data_buf[bus->wr_ind++]);
+
+	return true;
+}
+#endif  // CONFIG_I2C_SLAVE
+
+#ifdef TBD
+static bool NPCM7XX_smb_module_is_busy(struct NPCM7XX_i2c *bus)
+{
+	return (FIELD_GET(NPCM7XX_SMBCST_BUSY, ioread8( NPCM7XX_SMBCST(bus) ||
+		FIELD_GET(NPCM7XX_SMBST_SLVSTP, ioread8( NPCM7XX_SMBCST(bus));
+}
+
+static bool NPCM7XX_smb_bus_is_busy(struct NPCM7XX_i2c *bus)
+{
+	return FIELD_GET(NPCM7XX_SMBCST_BB, ioread8( NPCM7XX_SMBCST(bus));
+}
+#endif //TBD
+
+#if IS_ENABLED(CONFIG_I2C_SLAVE)
+static int  NPCM7XX_smb_get_current_slave_addr(struct NPCM7XX_i2c *bus,
+					       u8 *currSlaveAddr)
+{
+	if (currSlaveAddr != NULL) {
+		*currSlaveAddr = bus->own_slave_addr;
+		return 0;
+	}
+
+	return -EFAULT;
+}
+#endif
+
+// enable\disable end of busy (EOB) interrupt
+static inline void NPCM7XX_smb_eob_int(struct NPCM7XX_i2c *bus, bool enable)
+{
+#ifdef SMB_CAPABILITY_END_OF_BUSY_SUPPORT
+	if (enable == true)
+		iowrite8(ioread8(NPCM7XX_SMBCTL1(bus)) |
+			NPCM7XX_SMBCTL1_EOBINTE, NPCM7XX_SMBCTL1(bus));
+	else {
+		iowrite8(ioread8(NPCM7XX_SMBCTL1(bus)) &
+			(~NPCM7XX_SMBCTL1_EOBINTE), NPCM7XX_SMBCTL1(bus));
+
+		// Clear EO_BUSY pending bit:
+		iowrite8(ioread8(NPCM7XX_SMBCST3(bus)) |
+			NPCM7XX_SMBCST3_EO_BUSY, NPCM7XX_SMBCST3(bus));
+	}
+
+#endif
+
+}
+
+
+static inline bool NPCM7XX_smb_tx_fifo_full(struct NPCM7XX_i2c *bus)
+{
+	// check if TX FIFO full:
+	return (bool)FIELD_GET(NPCM7XX_SMBTXF_STS_TX_THST,
+			ioread8(NPCM7XX_SMBTXF_STS(bus)));
+}
+
+
+static inline bool NPCM7XX_smb_rx_fifo_full(struct NPCM7XX_i2c *bus)
+{
+	// check if RX FIFO full:
+	return (bool)FIELD_GET(NPCM7XX_SMBRXF_STS_RX_THST,
+			ioread8(NPCM7XX_SMBRXF_STS(bus)));
+}
+
+static inline void NPCM7XX_smb_clear_tx_fifo(struct NPCM7XX_i2c *bus)
+{
+	// clear TX FIFO:
+	iowrite8(ioread8(NPCM7XX_SMBTXF_STS(bus)) |
+		 NPCM7XX_SMBTXF_STS_TX_THST,
+		 NPCM7XX_SMBTXF_STS(bus));
+	return;
+
+
+}
+
+
+static inline void NPCM7XX_smb_clear_rx_fifo(struct NPCM7XX_i2c *bus)
+{
+	// clear RX FIFO:
+	iowrite8(ioread8(NPCM7XX_SMBRXF_STS(bus)) |
+			 NPCM7XX_SMBRXF_STS_RX_THST,
+			 NPCM7XX_SMBRXF_STS(bus));
+	return;
+}
+
+
+
+// configure the FIFO before using it. If nread is -1 RX FIFO will not be
+// configured. same for  nwrite
+static void NPCM7XX_smb_set_fifo(struct NPCM7XX_i2c *bus, int nread,
+			int nwrite)
+{
+	if (bus->fifo_use == false)
+		return;
+
+	NPCM7XX_smb_select_bank(bus, SMB_BANK_1);
+
+	NPCM7XX_smb_clear_tx_fifo(bus);
+	NPCM7XX_smb_clear_rx_fifo(bus);
+
+	// configure RX FIFO
+	if (nread > 0){
+		// clear LAST bit:
+		iowrite8(ioread8(NPCM7XX_SMBRXF_CTL(bus)) &
+				    	(~NPCM7XX_SMBRXF_CTL_LAST_PEC),
+				    	NPCM7XX_SMBRXF_CTL(bus));
+
+
+
+		if (nread > SMBUS_FIFO_SIZE && (nread != SMB_QUICK_PROT))
+			iowrite8((ioread8(NPCM7XX_SMBRXF_CTL(bus)) &
+				~NPCM7XX_SMBRXF_CTL_RX_THR)
+				| FIELD_PREP(NPCM7XX_SMBRXF_CTL_RX_THR,
+				SMBUS_FIFO_SIZE), NPCM7XX_SMBRXF_CTL(bus));
+		else {
+			iowrite8((ioread8(NPCM7XX_SMBRXF_CTL(bus)) &
+				~NPCM7XX_SMBRXF_CTL_RX_THR)
+				| FIELD_PREP(NPCM7XX_SMBRXF_CTL_RX_THR,
+				(u8)(nread)), NPCM7XX_SMBRXF_CTL(bus));
+
+		}
+
+		if ((nread <= SMBUS_FIFO_SIZE)	 &&
+			(bus->rd_size != SMB_BLOCK_PROT) &&
+			(bus->rd_size != SMB_EXCLUDE_BLOCK_SIZE_FROM_BUF))
+				iowrite8(ioread8(NPCM7XX_SMBRXF_CTL(bus)) |
+				    	NPCM7XX_SMBRXF_CTL_LAST_PEC,
+				    	NPCM7XX_SMBRXF_CTL(bus));
+
+	}
+
+
+
+	// configure TX FIFO
+	if (nwrite > 0){
+		// TODO
+
+		if (nwrite > SMBUS_FIFO_SIZE)
+				// data to send is more then FIFO size.
+				// Configure the FIFO int to be mid of FIFO.
+				iowrite8(NPCM7XX_SMBTXF_CTL_THR_TXIE | (SMBUS_FIFO_SIZE / 2), NPCM7XX_SMBTXF_CTL(bus));
+			else if ((nwrite > SMBUS_FIFO_SIZE / 2) && (bus->wr_ind != 0))
+				// wr_ind != 0 means that this is not the first write.
+				// since int is in the mid of FIFO, only half of the fifo is empty.
+				// Continue to configure the FIFO int to be mid of FIFO.
+				iowrite8(NPCM7XX_SMBTXF_CTL_THR_TXIE | (SMBUS_FIFO_SIZE / 2), NPCM7XX_SMBTXF_CTL(bus));
+			else {
+#if defined (SMB_CAPABILITY_HW_PEC_SUPPORT)
+				if ((bus->PEC_use) && (nwrite > 1))
+					nwrite--; //put the PEC byte last after the FIFO becomes empty.
+#endif
+				// This is the either first write (wr_ind = 0) and data to send
+				// is less or equal to FIFO size.
+				// Or this is the last write and data to send is less or equal half FIFO
+				// size.
+				// In both cases disable the FIFO threshold int.
+				// The next int will happen after the FIFO will get empty.
+				iowrite8((u8)0, NPCM7XX_SMBTXF_CTL(bus));
+			}
+            //@@: Do it according to the previous version.
+			//NPCM7XX_smb_clear_tx_fifo(bus);
+
+	}
+
+	// NPCM7XX_smb_select_bank(bus, SMB_BANK_0);
+
+
+}
+
+static void NPCM7XX_smb_read_from_fifo(struct NPCM7XX_i2c *bus, u8 bytes_in_fifo)
+{
+	while (bytes_in_fifo--) {
+		// Keep read data
+		u8 data = ioread8(NPCM7XX_SMBSDA(bus));
+
+		NPCM7XX_smb_calc_PEC(bus, data);
+		if (bus->rd_ind < bus->rd_size) {
+			bus->read_data_buf[bus->rd_ind++] = data;
+			if ((bus->rd_ind == 1) &&
+			    bus->rd_size == SMB_BLOCK_PROT)
+			    // First byte indicates length in block protocol
+			    bus->rd_size = data;
+		}
+	}
+}
+
+static void NPCM7XX_smb_master_fifo_read(struct NPCM7XX_i2c *bus)
+{
+	u16 rcount;
+	u8 fifo_bytes;
+	SMB_STATE_IND_T ind = SMB_MASTER_DONE_IND;
+
+	rcount = bus->rd_size - bus->rd_ind;
+
+
+	// In order not to change the RX_TRH during transaction (we found that this might
+	// be problematic if it takes too much time to read the FIFO) we read the data in the
+	// following way. If the number of bytes to read == FIFO Size + C (where C < FIFO Size)
+	// then first read C bytes and in the next int we read rest of the data.
+	if ((rcount < (2 * SMBUS_FIFO_SIZE)) && (rcount > SMBUS_FIFO_SIZE))
+		fifo_bytes = (u8)(rcount - SMBUS_FIFO_SIZE);
+	else
+		fifo_bytes = FIELD_GET(NPCM7XX_SMBRXF_STS_RX_BYTES, ioread8(
+		NPCM7XX_SMBRXF_STS(bus)));
+
+	if (rcount - fifo_bytes == 0) {
+		// last byte is about to be read - end of transaction.
+		// Stop should be set before reading last byte.
+		NPCM7XX_smb_eob_int(bus, true);
+
+		NPCM7XX_smb_master_stop(bus);
+
+		NPCM7XX_smb_read_from_fifo(bus, fifo_bytes);
+
+		if (NPCM7XX_smb_get_PEC(bus) != 0)
+			ind = SMB_MASTER_PEC_ERR_IND;
+
+#ifdef SMB_CAPABILITY_END_OF_BUSY_SUPPORT
+		bus->state = SMB_STOP_PENDING;
+		bus->stop_ind = ind;
+#else
+		// Reset state for new transaction
+		bus->state = SMB_IDLE;
+
+		// Notify upper layer of transaction completion
+		NPCM7XX_smb_callback(bus, ind, bus->rd_ind);
+#endif
+	}
+	else {
+		NPCM7XX_smb_read_from_fifo(bus, fifo_bytes);
+		rcount = bus->rd_size - bus->rd_ind;
+
+		NPCM7XX_smb_set_fifo(bus, rcount, -1);
+	}
+
+}
+
+
+static void NPCM7XX_smb_write_to_fifo(struct NPCM7XX_i2c *bus,
+				      u16 max_bytes_to_send)
 {
-	// Fill the FIFO, while the FIFO is not full and there are more bytes to
-	// write
+	I2C_DEBUG2("\t\t\tSDA master bus%d fifo wr %d bytes\n", bus->num,
+		   max_bytes_to_send);
+
+	// Fill the FIFO , while the FIFO is not full and there are more bytes to write
 	while ((max_bytes_to_send--) && (SMBUS_FIFO_SIZE -
-					 npcm_smb_get_fifo_fullness(bus))) {
+		FIELD_GET(NPCM7XX_SMBTXF_STS_TX_BYTES,
+		ioread8(NPCM7XX_SMBTXF_STS(bus)))))
+	{
 		// write the data
 		if (bus->wr_ind < bus->wr_size) {
-			if (bus->PEC_use &&
-			    (bus->wr_ind + 1 == bus->wr_size) &&
-			    (bus->rd_size == 0 ||
-			     bus->master_or_slave == SMB_SLAVE)) {
-				// Master send PEC in write protocol, Slave send
-				// PEC in read protocol.
-				npcm_smb_write_PEC(bus);
+			if ((bus->PEC_use == true) &&
+			    ((bus->wr_ind + 1) == bus->wr_size) &&
+			    ((bus->rd_size == 0) ||
+			    (bus->master_or_slave == SMB_SLAVE))) {
+				// Master send PEC in write protocol, Slave send PEC in read protocol.
+				NPCM7XX_smb_write_PEC(bus);
 				bus->wr_ind++;
-			} else {
-				npcm_smb_wr_byte(bus,
-						 bus->wr_buf[bus->wr_ind++]);
 			}
-		} else {
+			else
+				NPCM7XX_smb_write_byte(bus,
+				bus->write_data_buf[bus->wr_ind++]);
+		}
+		else {
+
+			// define this at hal_cfg or
+			/// chip file, if one wishes to use this feature. Otherwise
+			// driver will xmit 0xFF
+
 #ifdef SMB_WRAP_AROUND_BUFFER
 			// We're out of bytes. Ask the higher level for
 			// more bytes. Let it know that driver
 			// used all its' bytes
 
-			npcm_smb_clear_tx_fifo(bus);
+			NPCM7XX_smb_clear_tx_fifo(bus);
 
 			// Reset state for the remaining bytes transaction
 			bus->state = SMB_SLAVE_MATCH;
 
 			// Notify upper layer of transaction completion
-			npcm_smb_callback(bus, SMB_SLAVE_XMIT_MISSING_DATA_IND,
-					  bus->wr_ind);
+			NPCM7XX_smb_callback(bus, SMB_SLAVE_XMIT_MISSING_DATA_IND,
+					     bus->wr_ind);
 
-			iowrite8(NPCM_SMBST_SDAST, bus->reg + NPCM_SMBST);
+			iowrite8(NPCM7XX_SMBST_SDAST, NPCM7XX_SMBST(bus));
 #else
-			npcm_smb_wr_byte(bus, 0xFF);
+			NPCM7XX_smb_write_byte(bus, 0xFF);
 #endif
 		}
 	}
 }
 
-// configure the FIFO before using it. If nread is -1 RX FIFO will not be
-// configured. same for	nwrite
-static void npcm_smb_set_fifo(struct npcm_i2c *bus, int nread, int nwrite)
+
+static bool NPCM7XX_smb_init_clk(struct NPCM7XX_i2c *bus, SMB_MODE_T mode,
+				 u16 bus_freq)
 {
-	if (!bus->fifo_use)
-		return;
-	npcm_smb_select_bank(bus, SMB_BANK_1);
-	npcm_smb_clear_tx_fifo(bus);
-	npcm_smb_clear_rx_fifo(bus);
+	u16  k1 = 0;
+	u16  k2 = 0;
+	u8   dbnct = 0;
+	u16  sclfrq = 0;
+	u8   hldt = 7;
+	bool fastMode = false;
+	u32  source_clock_freq;
 
-	// configure RX FIFO
-	if (nread > 0) {
-		// clear LAST bit:
-		iowrite8(ioread8(bus->reg + NPCM_SMBRXF_CTL) &
-					(~NPCM_SMBRXF_CTL_LAST_PEC),
-					bus->reg + NPCM_SMBRXF_CTL);
-
-		if (nread > SMBUS_FIFO_SIZE)
-			iowrite8((ioread8(bus->reg + NPCM_SMBRXF_CTL) &
-				~NPCM_SMBRXF_CTL_RX_THR)
-				| FIELD_PREP(NPCM_SMBRXF_CTL_RX_THR,
-				SMBUS_FIFO_SIZE), bus->reg + NPCM_SMBRXF_CTL);
+	source_clock_freq = bus->apb_clk;
+
+
+	// Frequency is less or equal to 100 KHz
+	if (bus_freq <= SMBUS_FREQ_100KHz) {
+		// Set frequency:
+		// SCLFRQ = T(SCL)/4/T(CLK) = FREQ(CLK)/4/FREQ(SCL) = FREQ(CLK) / ( FREQ(SCL)*4 )
+		sclfrq = (u16)((source_clock_freq / ((u32)bus_freq * _1KHz_ * 4)));   // bus_freq is KHz
+
+		// Check whether requested frequency can be achieved in current CLK
+		if ((sclfrq < SCLFRQ_MIN) || (sclfrq > SCLFRQ_MAX))
+			return false;
+
+		if (source_clock_freq >= 40000000)
+			hldt = 17;
+		else if (source_clock_freq >= 12500000)
+			hldt = 15;
 		else
-			iowrite8((ioread8(bus->reg + NPCM_SMBRXF_CTL) &
-					  ~NPCM_SMBRXF_CTL_RX_THR) |
-					  FIELD_PREP(NPCM_SMBRXF_CTL_RX_THR,
-						     (u8)(nread)),
-				 bus->reg + NPCM_SMBRXF_CTL);
+			hldt = 7;
+	}
+
+	// Frequency equal to 400 KHz
+	else if (bus_freq == SMBUS_FREQ_400KHz) {
+		sclfrq = 0;
+		fastMode = true;
+
+		if ((mode == SMB_MASTER && source_clock_freq < 7500000) ||
+		    (mode == SMB_SLAVE  && source_clock_freq < 10000000))
+		    // 400KHz cannot be supported for master core clock < 7.5 MHz or slave core clock < 10 MHz
+		    return false;
+
+		// Master or Slave with frequency > 25 MHz
+		if (mode == SMB_MASTER || source_clock_freq > 25000000) {
+			// Set HLDT:
+			// SDA hold time:  (HLDT-7) * T(CLK) >= 300
+			// HLDT = 300/T(CLK) + 7 = 300 * FREQ(CLK) + 7
+			hldt = (u8)DIV_CEILING((300 *
+				(source_clock_freq / _1KHz_)), ((u32)_1MHz_)) + 7;
+
+			if (mode == SMB_MASTER) {
+				// Set k1:
+				// Clock low time: k1 * T(CLK) - T(SMBFO) >= 1300
+				// T(SMBRO) = T(SMBFO) = 300
+				// k1 = (1300 + T(SMBFO)) / T(CLK) = 1600 * FREQ(CLK)
+				k1 = ROUND_UP(((u16)DIV_CEILING((1600 *
+					(source_clock_freq / _1KHz_)),
+					((u32)_1MHz_))), 2);
+
+				// Set k2:
+				// START setup: (k2 - 1) * T(CLK) - T(SMBFO) >= 600
+				// T(SMBRO) = T(SMBFO) = 300
+				// k2 = (600 + T(SMBFO)) / T(CLK) + 1 = 900 * FREQ(CLK) + 1
+				k2 = ROUND_UP(((u16)DIV_CEILING((900 * (source_clock_freq / _1KHz_)), ((u32)_1MHz_)) + 1), 2);
+
+				// Check whether requested frequency can be achieved in current CLK
+				if ((k1 < SCLFRQ_MIN) || (k1 > SCLFRQ_MAX) ||
+				    (k2 < SCLFRQ_MIN) || (k2 > SCLFRQ_MAX))
+				    return false;
+			}
+		}
 
-		if (nread <= SMBUS_FIFO_SIZE && !bus->read_block_use)
-			iowrite8(ioread8(bus->reg + NPCM_SMBRXF_CTL) |
-				 NPCM_SMBRXF_CTL_LAST_PEC,
-				 bus->reg + NPCM_SMBRXF_CTL);
+		// Slave with frequency 10-25 MHz
+		else {
+			hldt = 7;
+			dbnct = 2;
+		}
 	}
 
-	// configure TX FIFO
-	if (nwrite > 0) {
-		if (nwrite > SMBUS_FIFO_SIZE)
-			// data to send is more then FIFO size.
-			// Configure the FIFO int to be mid of FIFO.
-			iowrite8(NPCM_SMBTXF_CTL_THR_TXIE |
-				(SMBUS_FIFO_SIZE / 2),
-				bus->reg + NPCM_SMBTXF_CTL);
-		else if (nwrite > (SMBUS_FIFO_SIZE / 2) &&
-			 bus->wr_ind != 0)
-			// wr_ind != 0 means that this is not the first
-			// write. since int is in the mid of FIFO, only
-			// half of the fifo is empty.
-			// Continue to configure the FIFO int to be mid
-			// of FIFO.
-			iowrite8(NPCM_SMBTXF_CTL_THR_TXIE |
-				 (SMBUS_FIFO_SIZE / 2),
-				 bus->reg + NPCM_SMBTXF_CTL);
+	// Frequency equal to 1 MHz
+	else if (bus_freq == SMBUS_FREQ_1MHz) {
+		sclfrq = 0;
+		fastMode = true;
+
+		if ((mode == SMB_MASTER && source_clock_freq < 15000000) ||
+		    (mode == SMB_SLAVE  && source_clock_freq < 24000000))
+
+		    // 1MHz cannot be supported for master core clock < 15 MHz or slave core clock < 24 MHz
+		    return false;
+
+		// Master or Slave with frequency > 40 MHz
+		if (mode == SMB_MASTER || source_clock_freq > 40000000) {
+
+			// Set HLDT:
+			// SDA hold time:  (HLDT-7) * T(CLK) >= 120
+			// HLDT = 120/T(CLK) + 7 = 120 * FREQ(CLK) + 7
+			hldt = (u8)DIV_CEILING((120 *
+				(source_clock_freq / _1KHz_)),
+				((u32)_1MHz_)) + 7;
+
+			if (mode == SMB_MASTER) {
+
+				// Set k1:
+				// Clock low time: k1 * T(CLK) - T(SMBFO) >= 500
+				// T(SMBRO) = T(SMBFO) = 120
+				// k1 = (500 + T(SMBFO)) / T(CLK) = 620 * FREQ(CLK)
+				k1 = ROUND_UP(((u16)DIV_CEILING((620 *
+					(source_clock_freq / _1KHz_)),
+					((u32)_1MHz_))), 2);
+
+
+				// Set k2:
+				// START setup: (k2 - 1) * T(CLK) - T(SMBFO) >= 260
+				// T(SMBRO) = T(SMBFO) = 120
+				// k2 = (260 + T(SMBFO)) / T(CLK) + 1 = 380 * FREQ(CLK) + 1
+				k2 = ROUND_UP(((u16)DIV_CEILING((380
+					* (source_clock_freq / _1KHz_)), ((u32)_1MHz_))
+					+ 1), 2);
+
+
+				// Check whether requested frequency can be achieved in current CLK
+				if ((k1 < SCLFRQ_MIN) || (k1 > SCLFRQ_MAX) ||
+				    (k2 < SCLFRQ_MIN) || (k2 > SCLFRQ_MAX)) {
+					return false;
+				}
+			}
+		}
+
+		// Slave with frequency 24-40 MHz
+		else {
+			hldt = 7;
+			dbnct = 2;
+		}
+	}
+
+	// Frequency larger than 1 MHz
+	else
+		return false;
+
+
+
+	// After clock parameters calculation update the reg
+	iowrite8((ioread8(NPCM7XX_SMBCTL2(bus))
+		& ~SMBCTL2_SCLFRQ6_0) | FIELD_PREP(SMBCTL2_SCLFRQ6_0,
+		sclfrq & 0x7F), NPCM7XX_SMBCTL2(bus));
+
+	iowrite8((ioread8(NPCM7XX_SMBCTL3(bus)) & ~SMBCTL3_SCLFRQ8_7) |
+		 FIELD_PREP(SMBCTL3_SCLFRQ8_7,
+		 (sclfrq >> 7) & 0x3), NPCM7XX_SMBCTL3(bus));
+
+	iowrite8((ioread8(NPCM7XX_SMBCTL3(bus))
+		& ~SMBCTL3_400K_MODE) | FIELD_PREP(SMBCTL3_400K_MODE,
+		fastMode), NPCM7XX_SMBCTL3(bus));
+
+	iowrite8((ioread8(NPCM7XX_SMBCTL3(bus)) & ~SMBCTL3_400K_MODE) |
+		 FIELD_PREP(SMBCTL3_400K_MODE, fastMode), NPCM7XX_SMBCTL3(bus));
+
+
+	// Select Bank 0 to access NPCM7XX_SMBCTL4/NPCM7XX_SMBCTL5
+	NPCM7XX_smb_select_bank(bus, SMB_BANK_0);
+
+	if (bus_freq >= SMBUS_FREQ_400KHz) {
+
+		// k1 and k2 are relevant for master mode only
+		if (mode == SMB_MASTER) {
+
+			// Set SCL Low/High Time:
+			// k1 = 2 * SCLLT7-0 -> Low Time  = k1 / 2
+			// k2 = 2 * SCLLT7-0 -> High Time = k2 / 2
+			iowrite8((u8)k1 / 2, NPCM7XX_SMBSCLLT(bus));
+			iowrite8((u8)k2 / 2, NPCM7XX_SMBSCLHT(bus));
+		}
+
+		// DBNCT is relevant for slave mode only
 		else
-			// This is the either first write (wr_ind = 0)
-			// and data to send is less or equal to FIFO
-			// size.
-			// Or this is the last write and data to send
-			// is less or equal half FIFO size.
-			// In both cases disable the FIFO threshold int.
-			// The next int will happen after the FIFO will
-			// get empty.
-			iowrite8(0, bus->reg + NPCM_SMBTXF_CTL);
-		npcm_smb_clear_tx_fifo(bus);
+			iowrite8((ioread8(NPCM7XX_SMBCTL5(bus)) & ~SMBCTL5_DBNCT)
+			| FIELD_PREP(SMBCTL5_DBNCT, dbnct),
+			NPCM7XX_SMBCTL5(bus));
 	}
+
+	iowrite8((ioread8(NPCM7XX_SMBCTL4(bus)) & ~SMBCTL4_HLDT)
+		 | FIELD_PREP(SMBCTL4_HLDT,
+		 hldt), NPCM7XX_SMBCTL4(bus));
+
+	I2C_DEBUG2("I2C%d  sclfrq = %d, hldt = %d, dbnct = %d, bus_freq = %d,"
+	       " SMBCTL2= 0x%x,SMBCTL3= 0x%x, SMBCTL4= 0x%x, SMBCTL5= 0x%x\n",
+	       bus->num, sclfrq, hldt, dbnct, bus_freq, ioread8(NPCM7XX_SMBCTL2(bus)),
+	       ioread8(NPCM7XX_SMBCTL3(bus)), ioread8(NPCM7XX_SMBCTL4(bus)),
+	       ioread8(NPCM7XX_SMBCTL5(bus)));
+
+
+	// Return to Bank 1
+	NPCM7XX_smb_select_bank(bus, SMB_BANK_1);
+
+	return true;
 }
 
-static void npcm_smb_read_from_fifo(struct npcm_i2c *bus, u8 bytes_in_fifo)
+
+#if defined (SMB_CAPABILITY_TIMEOUT_SUPPORT)
+static void NPCM7XX_smb_enable_timeout(struct NPCM7XX_i2c *bus, bool enable)
 {
-	while (bytes_in_fifo--) {
-		// Keep read data
-		u8 data = ioread8(bus->reg + NPCM_SMBSDA);
+	u8 toCkDiv;
+	u8 smbEnabled;
+	u8 smbctl1 = 0;
 
-		npcm_smb_calc_PEC(bus, data);
-		if (bus->rd_ind < bus->rd_size) {
-			bus->rd_buf[bus->rd_ind++] = data;
-			if (bus->rd_ind == 1 && bus->read_block_use)
-				// First byte indicates length in block protocol
-				bus->rd_size = data;
+
+	I2C_DEBUG("\t\t\tSDA master bus%d enable TO %d\n", bus->num,
+		  enable);
+
+	if (enable) {
+
+		// TO_CKDIV may be changed only when the SMB is disabled
+		smbEnabled = FIELD_GET(SMBCTL2_ENABLE, ioread8( NPCM7XX_SMBCTL2(bus)));
+
+		// If SMB is enabled - disable the SMB module
+		if (smbEnabled) {
+
+			// Save NPCM7XX_SMBCTL1 relevant bits. It is being cleared when the module is disabled
+			smbctl1 = ioread8(NPCM7XX_SMBCTL1(bus)) & (NPCM7XX_SMBCTL1_GCMEN
+								   | NPCM7XX_SMBCTL1_INTEN
+								   | NPCM7XX_SMBCTL1_NMINTE);
+
+			// Disable the SMB module
+			iowrite8((ioread8(NPCM7XX_SMBCTL2(bus)) & ~SMBCTL2_ENABLE) | FIELD_PREP(SMBCTL2_ENABLE,
+				DISABLE), NPCM7XX_SMBCTL2(bus));
+		}
+
+		// Clear EO_BUSY pending bit
+		iowrite8(ioread8(NPCM7XX_SMBT_OUT(bus)) | NPCM7XX_SMBT_OUT_T_OUTST,
+			 NPCM7XX_SMBT_OUT(bus));
+
+		// Configure the division of the SMB Module Basic clock (BCLK) to generate the 1 KHz clock of the
+		// timeout detector.
+		// The timeout detector has an n+1 divider, controlled by TO_CKDIV and a fixed divider by 1000.
+		// Together they generate the 1 ms clock cycle
+		toCkDiv = (u8)(((bus->apb_clk / _1KHz_) / 1000) - 1);
+
+		// Set the bus timeout clock divisor
+		iowrite8((ioread8(NPCM7XX_SMBT_OUT(bus)) & ~NPCM7XX_SMBT_OUT_TO_CKDIV)
+			 | FIELD_PREP(NPCM7XX_SMBT_OUT_TO_CKDIV,
+			 toCkDiv), NPCM7XX_SMBT_OUT(bus));
+
+		// If SMB was enabled - re-enable the SMB module
+		if (smbEnabled) {
+
+			// Enable the SMB module
+			(void)NPCM7XX_smb_enable(bus);
+
+			// Restore NPCM7XX_SMBCTL1 status
+			iowrite8(smbctl1, NPCM7XX_SMBCTL1(bus));
 		}
 	}
+
+
+	// Enable/Disable the bus timeout int
+	iowrite8((ioread8(NPCM7XX_SMBT_OUT(bus)) & ~NPCM7XX_SMBT_OUT_T_OUTIE)
+		 | FIELD_PREP(NPCM7XX_SMBT_OUT_T_OUTIE,
+		 enable), NPCM7XX_SMBT_OUT(bus));
 }
+#endif
 
-static void npcm_smb_master_fifo_read(struct npcm_i2c *bus)
+static void NPCM7XX_smb_int_master_handler(struct NPCM7XX_i2c *bus)
 {
-	u16 rcount;
-	u8 fifo_bytes;
-	enum smb_state_ind ind = SMB_MASTER_DONE_IND;
 
-	rcount = bus->rd_size - bus->rd_ind;
+	// A negative acknowledge has occurred
+	if (FIELD_GET(NPCM7XX_SMBST_NEGACK, ioread8(NPCM7XX_SMBST(bus)))) {
+		I2C_DEBUG2("\tNACK bus = %d\n", bus->num);
+		NPCM7XX_I2C_EVENT_LOG(NPCM7XX_I2C_EVENT_NACK);
+		if (bus->fifo_use) {
+			// if there are still untransmitted bytes in TX FIFO reduce them from wr_ind
+			bus->wr_ind -= FIELD_GET(NPCM7XX_SMBTXF_STS_TX_BYTES,
+						      ioread8(NPCM7XX_SMBTXF_STS(bus)));
 
-	// In order not to change the RX_TRH during transaction (we found that
-	// this might be problematic if it takes too much time to read the FIFO)
-	//  we read the data in the following way. If the number of bytes to
-	// read == FIFO Size + C (where C < FIFO Size)then first read C bytes
-	// and in the next int we read rest of the data.
-	if (rcount < (2 * SMBUS_FIFO_SIZE) && rcount > SMBUS_FIFO_SIZE)
-		fifo_bytes = (u8)(rcount - SMBUS_FIFO_SIZE);
-	else
-		fifo_bytes = npcm_smb_get_fifo_fullness(bus);
+			I2C_DEBUG2("\tNACK bus%d fifo, wr_ind = %d\n",
+				   bus->num, bus->wr_ind);
 
-	if (rcount - fifo_bytes == 0) {
-		// last byte is about to be read - end of transaction.
-		// Stop should be set before reading last byte.
-		npcm_smb_eob_int(bus, true);
-		npcm_smb_master_stop(bus);
-		npcm_smb_read_from_fifo(bus, fifo_bytes);
+			// clear the FIFO
+			iowrite8(NPCM7XX_SMBFIF_CTS_CLR_FIFO, NPCM7XX_SMBFIF_CTS(bus));
+		}
 
-		if (npcm_smb_get_PEC(bus) != 0)
-			ind = SMB_MASTER_PEC_ERR_IND;
-		bus->state = SMB_STOP_PENDING;
-		bus->stop_ind = ind;
+		// In master write operation, NACK is a problem
 
-	} else {
-		npcm_smb_read_from_fifo(bus, fifo_bytes);
-		rcount = bus->rd_size - bus->rd_ind;
-		npcm_smb_set_fifo(bus, rcount, -1);
+		// number of bytes sent to master less than required
+		// notify upper layer.
+		NPCM7XX_smb_master_abort(bus);
+
+		// iowrite8(NPCM7XX_SMBST_NEGACK, NPCM7XX_SMBST(bus));
+		bus->state = SMB_IDLE;
+
+		// In Master mode, NEGACK should be cleared only after generating STOP.
+		// In such case, the bus is released from stall only after the software clears NEGACK
+		// bit. Then a Stop condition is sent.
+		iowrite8(NPCM7XX_SMBST_NEGACK, NPCM7XX_SMBST(bus));
+
+		NPCM7XX_smb_callback(bus, SMB_NACK_IND, bus->wr_ind);
+
+		return;
+	}
+
+
+	// Master mode: a Bus Error has been identified
+	if (FIELD_GET(NPCM7XX_SMBST_BER, ioread8(NPCM7XX_SMBST(bus)))) {
+		// Check whether bus arbitration or Start or Stop during data xfer
+
+		printk("I2C%d BER interrupt  SA=0x%x nwrite=%d, nread=%d, state "
+		       "%d, op=%d, ind=%d, int_cnt=%d, log=0x%x\n",
+		       bus->num, bus->dest_addr,
+		       bus->wr_size, bus->rd_size, bus->state,
+		       bus->operation, bus->stop_ind,
+		       bus->int_cnt, bus->event_log);
+		NPCM7XX_I2C_EVENT_LOG(NPCM7XX_I2C_EVENT_BER);
+
+		// Bus arbitration problem should not result in recovery
+		if (FIELD_GET(NPCM7XX_SMBST_MASTER, ioread8(NPCM7XX_SMBST(bus))))
+			// Only current master is allowed to issue Stop Condition
+			NPCM7XX_smb_master_abort(bus);
+		else {
+
+			// Bus arbitration loss
+			if (bus->retry_count-- > 0) {
+				printk("\tretry bus%d\n", bus->num);
+				// Perform a retry (generate a Start condition as soon as the SMBus is free)
+				iowrite8(NPCM7XX_SMBST_BER, NPCM7XX_SMBST(bus));
+				NPCM7XX_smb_master_start(bus);
+				return;
+			}
+		}
+		iowrite8(NPCM7XX_SMBST_BER, NPCM7XX_SMBST(bus));
+		bus->state = SMB_IDLE;
+		NPCM7XX_smb_callback(bus, SMB_BUS_ERR_IND, NPCM7XX_smb_get_index(bus));
+		return;
+	}
+
+#if defined (SMB_CAPABILITY_TIMEOUT_SUPPORT)
+	// A Bus Timeout has been identified
+	if ((FIELD_GET(NPCM7XX_SMBT_OUT_T_OUTIE,
+		ioread8(NPCM7XX_SMBT_OUT(bus))) == 1)
+		&&  // bus timeout int is on
+		(FIELD_GET(NPCM7XX_SMBT_OUT_T_OUTST, ioread8(NPCM7XX_SMBT_OUT(bus)) ))) {         // and bus timeout status is set
+		NPCM7XX_smb_master_abort(bus);
+		NPCM7XX_I2C_EVENT_LOG(NPCM7XX_I2C_EVENT_TO);
+		iowrite8(ioread8(NPCM7XX_SMBT_OUT(bus)) | NPCM7XX_SMBT_OUT_T_OUTST, NPCM7XX_SMBT_OUT(bus));// Clear EO_BUSY pending bit
+		bus->state = SMB_IDLE;
+		NPCM7XX_smb_callback(bus, SMB_BUS_ERR_IND, NPCM7XX_smb_get_index(bus));
+		return;
+	}
+#endif
+
+#ifdef SMB_CAPABILITY_END_OF_BUSY_SUPPORT
+
+	// A Master End of Busy (meaning Stop Condition happened)
+	if ((FIELD_GET(NPCM7XX_SMBCTL1_EOBINTE, ioread8(NPCM7XX_SMBCTL1(bus))) == 1) &&  // End of Busy int is on
+	    (FIELD_GET(NPCM7XX_SMBCST3_EO_BUSY, ioread8(NPCM7XX_SMBCST3(bus))))) {        // and End of Busy is set
+		I2C_DEBUG2("\tEnd of busy bus = %d\n", bus->num);
+
+		NPCM7XX_I2C_EVENT_LOG(NPCM7XX_I2C_EVENT_EOB);
+
+		NPCM7XX_smb_eob_int(bus, false);
+
+		bus->state = SMB_IDLE;
+
+		if ((bus->wr_size == SMB_QUICK_PROT) ||
+		    (bus->rd_size == SMB_QUICK_PROT) ||
+		    (bus->rd_size == 0)) {
+			NPCM7XX_smb_callback(bus, bus->stop_ind, 0);
+		}
+		else {
+			NPCM7XX_smb_callback(bus, bus->stop_ind, bus->rd_ind);
+		}
+		return;
+	}
+#endif
+
+
+	// Address sent and requested stall occurred (Master mode)
+	if (FIELD_GET(NPCM7XX_SMBST_STASTR, ioread8(NPCM7XX_SMBST(bus)))){
+		I2C_DEBUG2("\tmaster stall bus = %d\n", bus->num);
+
+		ASSERT(FIELD_GET(NPCM7XX_SMBST_MASTER, ioread8(NPCM7XX_SMBST(bus))));
+
+		// Check for Quick Command SMBus protocol (block protocol)
+		if ((bus->wr_size == SMB_QUICK_PROT)
+		    ||
+		    (bus->rd_size == SMB_QUICK_PROT)) {
+
+			// No need to write any data bytes -
+			//  reached here only in Quick Command
+			NPCM7XX_smb_eob_int(bus, true);
+
+			NPCM7XX_smb_master_stop(bus);
+
+
+			// Update status
+#ifdef SMB_CAPABILITY_END_OF_BUSY_SUPPORT
+			bus->state = SMB_STOP_PENDING;
+			bus->stop_ind = SMB_MASTER_DONE_IND;
+#else
+			bus->state = SMB_IDLE;
+
+			// Notify upper layer
+			NPCM7XX_smb_callback(bus, SMB_MASTER_DONE_IND, 0);
+#endif
+		}
+		else if (bus->rd_size == 1)
+
+			// Receiving one byte only - set NACK after ensuring slave ACKed the address byte
+			NPCM7XX_smb_nack(bus);
+
+		// Reset stall-after-address-byte
+		NPCM7XX_smb_stall_after_start(bus, false);
+
+		// Clear stall only after setting STOP
+		iowrite8(NPCM7XX_SMBST_STASTR, NPCM7XX_SMBST(bus));
+		return;
 	}
+
+
+	// SDA status is set - transmit or receive, master
+	if (FIELD_GET(NPCM7XX_SMBST_SDAST, ioread8(NPCM7XX_SMBST(bus))) ||
+		    (bus->fifo_use &&
+		    (NPCM7XX_smb_tx_fifo_full(bus) ||
+		     NPCM7XX_smb_rx_fifo_full(bus)) ))
+		      {
+
+		// Status Bit is cleared by writing to or reading from SDA (depending on current direction)
+		I2C_DEBUG2("\tSDA master set bus%d addr 0x%x state=%d op=%d\n",
+			   bus->num, bus->dest_addr, bus->state, bus->operation);
+
+		switch (bus->state){
+
+		// Handle unsuccessful bus mastership
+		case SMB_IDLE:
+			// Perform SMB recovery in Master mode, where state is IDLE,
+			//	which is an illegal state
+			//if (NPCM7XX_smb_master_abort(bus) == 0){
+				//NPCM7XX_smb_callback(bus, SMB_BUS_ERR_IND, 0);
+				//pr_err("\tSDA master bus%d, addr 0x%x, is idle\n",
+				//		bus->num, bus->dest_addr);
+			//}
+			NPCM7XX_smb_master_abort(bus);
+			return;
+			break;
+
+
+		case SMB_MASTER_START:
+			if (FIELD_GET(NPCM7XX_SMBST_MASTER,
+				ioread8(NPCM7XX_SMBST(bus)))) {
+				u8 addr_byte = bus->dest_addr;
+
+				I2C_DEBUG2("\tSDA master bus%d master start\n", bus->num);
+
+
+				bus->crc_data = 0;
+				// Check for Quick Command SMBus protocol
+				if ((bus->wr_size == SMB_QUICK_PROT)
+				    ||
+				    (bus->rd_size == SMB_QUICK_PROT))
+				    // Need to stall after successful completion of sending address byte
+				    NPCM7XX_smb_stall_after_start(bus, true);
+				// Prepare address byte
+				if (bus->wr_size == 0) {
+					if (bus->rd_size == 1)
+						// Receiving one byte only - stall after successful completion of sending
+						// address byte. If we NACK here, and slave doesn't ACK the address, we might
+						// unintentionally NACK the next multi-byte read
+						NPCM7XX_smb_stall_after_start(bus, true);
+
+					// Set direction to Read
+					addr_byte |= (u8)0x1;
+					bus->operation = SMB_READ_OPER;  // TaliP: no need for this !!!
+				}
+				else
+					bus->operation = SMB_WRITE_OPER;  // TaliP: no need for this !!!
+				// Write the address to the bus
+				bus->state = SMB_OPER_STARTED;
+				NPCM7XX_smb_write_byte(bus, addr_byte);
+			}
+			else
+				printk("\tSDA set ,bus%d is not a master, write %d 0x%x...\n", bus->num,
+				bus->wr_size, bus->write_data_buf[0]);
+			break;
+
+		// SDA status is set - transmit or receive: Handle master mode
+		case SMB_OPER_STARTED:
+			if (bus->operation == SMB_WRITE_OPER)
+				NPCM7XX_smb_int_master_handler_write(bus);
+
+			else if (bus->operation == SMB_READ_OPER)
+				NPCM7XX_smb_int_master_handler_read(bus);
+
+
+			else
+				pr_err("NPCM7XX I2C: unknown operation state.\n");
+
+			break;
+		default:
+			printk("master sda set error on state machine\n");
+			BUG();
+		} // End of master operation: SDA status is set - transmit or receive.
+
+
+	} //SDAST
 }
 
-static void npcm_smb_int_master_handler_write(struct npcm_i2c *bus)
+
+static void NPCM7XX_smb_int_master_handler_write(struct NPCM7XX_i2c *bus)
 {
 	u16 wcount;
 
-	NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_WRITE);
-	if (bus->fifo_use)
-		npcm_smb_clear_tx_fifo(bus);
+	I2C_DEBUG2("\tSDA master bus%d addr=0x%x oper wr\n", bus->num,
+		   bus->dest_addr);
+	NPCM7XX_I2C_EVENT_LOG(NPCM7XX_I2C_EVENT_WRITE);
+
+	if (bus->fifo_use == true)
+		NPCM7XX_smb_clear_tx_fifo(bus);
 
 	// Master write operation - last byte handling
 	if (bus->wr_ind == bus->wr_size) {
-		if (bus->fifo_use && npcm_smb_get_fifo_fullness(bus) > 0)
-	// No more bytes to send (to add to the FIFO), however the FIFO is not
-	// empty yet. It is still in the middle of tx. Currently there's nothing
-	// to do except for waiting to the end of the tx.
-	// We will get an int when the FIFO will get empty.
-			return;
+		I2C_DEBUG2("\tSDA master bus%d addr 0x%x last byte\n", bus->num,
+			   bus->dest_addr);
+		if ((bus->fifo_use == true) &&
+		    (FIELD_GET(NPCM7XX_SMBTXF_STS_TX_BYTES,
+		    ioread8(NPCM7XX_SMBTXF_STS(bus))) > 0))
+		    // No more bytes to send (to add to the FIFO), however the FIFO is not empty
+		    // yet. It is still in the middle of transmitting. Currency there is nothing
+		    // to do except for waiting to the end of the transmission.
+		    // We will get an int when the FIFO will get empty.
+		    return;
 
 		if (bus->rd_size == 0) {
-			// all bytes have been written, in a pure wr operation
-			npcm_smb_eob_int(bus, true);
+			// all bytes have been written, in a pure write operation
+			NPCM7XX_smb_eob_int(bus, true);
 
 			// Issue a STOP condition on the bus
-			npcm_smb_master_stop(bus);
+			NPCM7XX_smb_master_stop(bus);
 			// Clear SDA Status bit (by writing dummy byte)
-			npcm_smb_wr_byte(bus, 0xFF);
+			NPCM7XX_smb_write_byte(bus, 0xFF);
 
+#ifdef SMB_CAPABILITY_END_OF_BUSY_SUPPORT
 			bus->state = SMB_STOP_PENDING;
 			bus->stop_ind = SMB_MASTER_DONE_IND;
-		} else {
-			// last write-byte written on previous int - need to
-			// restart & send slave address
-			if (bus->PEC_use && !bus->read_block_use &&
-			    !npcm_smb_is_quick(bus))
-			    // PEC is used but the protocol is not block read
+#else
+			// Reset state for new transaction
+			bus->state = SMB_IDLE;
+			// Notify upper layer of transaction completion
+			NPCM7XX_smb_callback(bus, SMB_MASTER_DONE_IND, 0);
+#endif
+		}
+		else {
+			// last write-byte written on previous int - need to restart & send slave address
+			if ((bus->PEC_use == true) &&
+			    (bus->rd_size < SMB_EXCLUDE_BLOCK_SIZE_FROM_BUF))   // PEC is used but the protocol is not block read protocol
 			    // then we add extra bytes for PEC support
-				bus->rd_size += 1;
+			    bus->rd_size += 1; // move this to xmit !!!
+
+			if (bus->fifo_use == true) {
+				if (((bus->rd_size == 1) ||
+					bus->rd_size == SMB_EXCLUDE_BLOCK_SIZE_FROM_BUF ||
+					bus->rd_size == SMB_BLOCK_PROT)) {   // SMBus Block read transaction.
+
+					iowrite8(0, NPCM7XX_SMBTXF_CTL(bus));
+					iowrite8(1, NPCM7XX_SMBRXF_CTL(bus));
+
 
-			if (bus->fifo_use) {
-				if (bus->rd_size == 1 || bus->read_block_use) {
-					// SMBus Block read transaction.
-					iowrite8(0, bus->reg + NPCM_SMBTXF_CTL);
-					iowrite8(1, bus->reg + NPCM_SMBRXF_CTL);
 				}
 			}
 
-			npcm_smb_set_fifo(bus, bus->rd_size, -1);
+			NPCM7XX_smb_set_fifo(bus, bus->rd_size, -1);
 
 			// Generate (Repeated) Start upon next write to SDA
-			npcm_smb_master_start(bus);
+			NPCM7XX_smb_master_start(bus);
 
 			if (bus->rd_size == 1)
 
-	// Receiving one byte only - stall after successful completion of send
-	// address byte. If we NACK here, and slave doesn't ACK the address, we
-	// might unintentionally NACK the next multi-byte read
+				// Receiving one byte only - stall after successful completion of sending
+				// address byte. If we NACK here, and slave doesn't ACK the address, we
+				// might unintentionally NACK the next multi-byte read
 
-				npcm_smb_stall_after_start(bus, true);
+				NPCM7XX_smb_stall_after_start(bus, true);
 
 			// send the slave address in read direction
-			npcm_smb_wr_byte(bus, bus->dest_addr | 0x1);
+			NPCM7XX_smb_write_byte(bus, bus->dest_addr | 0x1);
 
 			// Next int will occur on read
 			bus->operation = SMB_READ_OPER;
 		}
-	} else {
-		if (bus->PEC_use && !npcm_smb_is_quick(bus))
-			// extra bytes for PEC support
-			bus->wr_size += 1;
+	}
+	else {
+		if ((bus->PEC_use == true) && (bus->wr_ind == 0)
+		    && (bus->rd_size == 0))// extra bytes for PEC support
+		    bus->wr_size += 1;
 
 		// write next byte not last byte and not slave address
-		if (!bus->fifo_use || bus->wr_size == 1) {
-			if (bus->PEC_use && bus->rd_size == 0 &&
-			    (bus->wr_ind + 1 == bus->wr_size)) {
-				// Master write protocol to send PEC byte.
-				npcm_smb_write_PEC(bus);
+		if ((bus->fifo_use == false) || (bus->wr_size == 1)) {
+			if ((bus->PEC_use == true) && (bus->rd_size == 0) &&
+			    (bus->wr_ind + 1 == bus->wr_size)) { // Master write protocol to send PEC byte.
+				NPCM7XX_smb_write_PEC(bus);
 				bus->wr_ind++;
-			} else {
-				npcm_smb_wr_byte(bus,
-						 bus->wr_buf[bus->wr_ind++]);
 			}
-		} else { // FIFO is used
+			else
+				NPCM7XX_smb_write_byte(bus, bus->write_data_buf[bus->wr_ind++]);
+		}
+		// FIFO is used
+		else {
 			wcount = bus->wr_size - bus->wr_ind;
-			npcm_smb_set_fifo(bus, -1, wcount);
-			npcm_smb_write_to_fifo(bus, wcount);
+			NPCM7XX_smb_set_fifo(bus, -1, wcount);
+
+			NPCM7XX_smb_write_to_fifo(bus, wcount);
+			//@@: In the previous version, it's cleared after writing to fifo.
+			NPCM7XX_smb_clear_tx_fifo(bus);
+
 		}
 	}
+
+
 }
 
-static void npcm_smb_int_master_handler_read(struct npcm_i2c *bus)
+static void NPCM7XX_smb_int_master_handler_read(struct NPCM7XX_i2c *bus)
 {
 	u16 block_zero_bytes;
-	u32 fifo_bytes;
-
 	// Master read operation (pure read or following a write operation).
-	NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_READ);
+	NPCM7XX_I2C_EVENT_LOG(NPCM7XX_I2C_EVENT_READ);
 
-	// Initialize number of bytes to include only the first byte (presents
-	// a case where number of bytes to read is zero); add PEC if applicable
+	if (bus->rd_ind > bus->rd_size)
+		I2C_DEBUG2("\tSDA master bus%d addr=0x%x oper rd ind %d out of %d\n", bus->num,
+		   			bus->dest_addr, bus->rd_ind, bus->rd_size);
+
+	// Initialize number of bytes to include only the first byte (presents a case where
+	// number of bytes to read is zero); add PEC if applicable
 	block_zero_bytes = 1;
-	if (bus->PEC_use)
+	if (bus->PEC_use == true)
 		block_zero_bytes++;
 
-	fifo_bytes = FIELD_GET(NPCM_SMBRXF_CTL_RX_THR,
-			       ioread8(bus->reg + NPCM_SMBRXF_CTL));
-
-	// Perform master read, distinguishing between last byte and the rest of
-	// the bytes. The last byte should be read when the clock is stopped
-	if ((bus->rd_ind < (bus->rd_size - 1)) ||  bus->fifo_use) {
+	// Perform master read, distinguishing between last byte and the rest of the
+	// bytes. The last byte should be read when the clock is stopped
+	if ((bus->rd_ind < (bus->rd_size - 1)) ||
+	    bus->fifo_use == true) {
 		u8 data;
 
+		I2C_DEBUG2("\tSDA master bus%d addr=0x%x oper rd last fifo\n",
+			   bus->num, bus->dest_addr);
 		// byte to be read is not the last one
 		// Check if byte-before-last is about to be read
 		if ((bus->rd_ind == (bus->rd_size - 2)) &&
-		    !bus->fifo_use){
+		    bus->fifo_use == false){
+
 			// Set nack before reading byte-before-last, so that
 			// nack will be generated after receive of last byte
-			npcm_smb_nack(bus);
+			NPCM7XX_smb_nack(bus);
 
-			if (!FIELD_GET(NPCM_SMBST_SDAST,
-				       ioread8(bus->reg + NPCM_SMBST))) {
-				// No data available - reset state for new xfer
+			if (!FIELD_GET(NPCM7XX_SMBST_SDAST, ioread8(NPCM7XX_SMBST(bus)))) {
+				// No data available - reset state for new transaction
 				bus->state = SMB_IDLE;
 
-				// Notify upper layer of rx completion
-				npcm_smb_callback(bus, SMB_NO_DATA_IND,
-						  bus->rd_ind);
+				// Notify upper layer of transaction completion
+				NPCM7XX_smb_callback(bus, SMB_NO_DATA_IND, bus->rd_ind);
 			}
-		} else if (bus->rd_ind == 0) { //first byte handling:
+		}
+		//first byte handling:
+		else if (bus->rd_ind == 0) {
 			// in block protocol first byte is the size
-			if (bus->read_block_use) {
-				npcm_smb_rd_byte(bus, &data);
+			if (bus->rd_size == SMB_EXCLUDE_BLOCK_SIZE_FROM_BUF ||
+			    bus->rd_size == SMB_BLOCK_PROT) {
+				(void)NPCM7XX_smb_read_byte(bus, &data);
 
 				// First byte indicates length in block protocol
-				bus->rd_buf[bus->rd_ind++] = data;
-				bus->rd_size = data + 1;
+				if (bus->rd_size == SMB_EXCLUDE_BLOCK_SIZE_FROM_BUF)
+					bus->rd_size = data;
+				else {
+					bus->read_data_buf[bus->rd_ind++] = data;
+					bus->rd_size = data + 1;
+				}
 
-				if (bus->PEC_use) {
+				if (bus->PEC_use == true) {
 					bus->rd_size += 1;
 					data += 1;
 				}
 
-				if (bus->fifo_use) {
-					iowrite8(NPCM_SMBFIF_CTS_RXF_TXE |
-						 ioread8(bus->reg +
-							 NPCM_SMBFIF_CTS),
-						 bus->reg + NPCM_SMBFIF_CTS);
+				if (bus->fifo_use == true) {
+					iowrite8(ioread8(NPCM7XX_SMBFIF_CTS(bus)) | NPCM7XX_SMBFIF_CTS_RXF_TXE, NPCM7XX_SMBFIF_CTS(bus));
 
 					// first byte in block protocol
 					// is zero -> not supported. read at
@@ -1172,477 +2226,1042 @@ static void npcm_smb_int_master_handler_read(struct npcm_i2c *bus)
 					if (data == 0)
 						data = 1;
 				}
-				npcm_smb_set_fifo(bus, bus->rd_size, -1);
-			} else {
-				if (!bus->fifo_use) {
-					npcm_smb_rd_byte(bus, &data);
-					bus->rd_buf[bus->rd_ind++] = data;
-				} else {
-					npcm_smb_clear_tx_fifo(bus);
-					npcm_smb_master_fifo_read(bus);
+				NPCM7XX_smb_set_fifo(bus, bus->rd_size, -1);
+			}
+			else {
+				if (bus->fifo_use == false) {
+					(void)NPCM7XX_smb_read_byte(bus, &data);
+					bus->read_data_buf[bus->rd_ind++] = data;
+				}
+				else {
+					NPCM7XX_smb_clear_tx_fifo(bus);
+					NPCM7XX_smb_master_fifo_read(bus);
 				}
 			}
 
-		} else {
-			if (bus->fifo_use) {
-				if (bus->rd_size == block_zero_bytes &&
-				    bus->read_block_use) {
-					npcm_smb_eob_int(bus, true);
-					npcm_smb_master_stop(bus);
-					npcm_smb_read_from_fifo(bus,
-								fifo_bytes);
+		}
+		else {
+			if (bus->fifo_use == true) {   // FIFO in used.
+				if ((bus->rd_size == block_zero_bytes) && (bus->read_block_use == true)) {
+					NPCM7XX_smb_eob_int(bus, true);
+					NPCM7XX_smb_master_stop(bus);
+					NPCM7XX_smb_read_from_fifo(bus, FIELD_GET(NPCM7XX_SMBRXF_CTL_RX_THR, ioread8(NPCM7XX_SMBRXF_CTL(bus))));
+
+
+#ifdef SMB_CAPABILITY_END_OF_BUSY_SUPPORT
 					bus->state = SMB_STOP_PENDING;
-					bus->stop_ind = SMB_BLOCK_BYTES_ERR_IND;
+					bus->stop_ind = SMB_MASTER_BLOCK_BYTES_ERR_IND;
+#else
+					// Reset state for new transaction
+					bus->state = SMB_IDLE;
 
-				} else {
-					npcm_smb_master_fifo_read(bus);
+					// Notify upper layer of transaction completion
+					NPCM7XX_smb_callback(bus, SMB_MASTER_BLOCK_BYTES_ERR_IND,
+							     bus->rd_ind);
+#endif
 				}
-			} else {
-				npcm_smb_rd_byte(bus, &data);
-				bus->rd_buf[bus->rd_ind++] = data;
+				else
+					NPCM7XX_smb_master_fifo_read(bus);
+			}
+			else {
+				(void)NPCM7XX_smb_read_byte(bus, &data);
+				bus->read_data_buf[bus->rd_ind++] = data;
 			}
 		}
-	} else {
+	}
+	else {
 		// last byte is about to be read - end of transaction.
 		// Stop should be set before reading last byte.
 		u8 data;
-		enum smb_state_ind ind = SMB_MASTER_DONE_IND;
+		SMB_STATE_IND_T ind = SMB_MASTER_DONE_IND;
 
-		npcm_smb_eob_int(bus, true);
+		I2C_DEBUG2("\tSDA master bus%d addr=0x%x oper rd last\n",
+			   bus->num, bus->dest_addr);
+		NPCM7XX_smb_eob_int(bus, true);
 
-		npcm_smb_master_stop(bus);
+		NPCM7XX_smb_master_stop(bus);
 
-		npcm_smb_rd_byte(bus, &data);
+		(void)NPCM7XX_smb_read_byte(bus, &data);
 
-		if (bus->rd_size == block_zero_bytes && bus->read_block_use) {
-			ind = SMB_BLOCK_BYTES_ERR_IND;
-		} else {
-			bus->rd_buf[bus->rd_ind++] = data;
-			if (npcm_smb_get_PEC(bus) != 0)
+		if ((bus->rd_size == block_zero_bytes)
+		    && (bus->read_block_use == true))
+		    ind = SMB_MASTER_BLOCK_BYTES_ERR_IND;
+		else {
+			bus->read_data_buf[bus->rd_ind++] = data;
+			if (NPCM7XX_smb_get_PEC(bus) != 0)
 				ind = SMB_MASTER_PEC_ERR_IND;
 		}
 
+#ifdef SMB_CAPABILITY_END_OF_BUSY_SUPPORT
 		bus->state = SMB_STOP_PENDING;
 		bus->stop_ind = ind;
-	}
-}
+#else
+
+		// Reset state for new transaction
+		bus->state = SMB_IDLE;
+
+		// Notify upper layer of transaction completion
+		NPCM7XX_smb_callback(bus, ind, bus->rd_ind);
+
+#endif
+	} // last read byte
+} // read operation
+
+
+///////////////    END OF MASTER_HANDLER
+
+
+
+
+
 
-static void npcm_smb_int_master_handler(struct npcm_i2c *bus)
+
+
+
+#if IS_ENABLED(CONFIG_I2C_SLAVE)
+static int NPCM7XX_smb_int_slave_handler(struct NPCM7XX_i2c *bus)
 {
+	SMB_STATE_IND_T ind;
+
 	// A negative acknowledge has occurred
-	if (FIELD_GET(NPCM_SMBST_NEGACK, ioread8(bus->reg + NPCM_SMBST))) {
-		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_NACK);
+	if (FIELD_GET(NPCM7XX_SMBST_NEGACK , ioread8(NPCM7XX_SMBST(bus)))) {
+		I2C_DEBUG("\tNACK slave bus = %d\n", bus->num);
 		if (bus->fifo_use) {
-			// if there are still untransmitted bytes in TX FIFO
-			// reduce them from wr_ind
 
-			if (bus->operation == SMB_WRITE_OPER)
-				bus->wr_ind -= npcm_smb_get_fifo_fullness(bus);
+			// if there are still untransmitted bytes in TX FIFO reduce them from wr_ind
+			bus->wr_ind -= FIELD_GET(NPCM7XX_SMBTXF_STS_TX_BYTES,
+						      ioread8(NPCM7XX_SMBTXF_STS(bus)));
+
 			// clear the FIFO
-			iowrite8(NPCM_SMBFIF_CTS_CLR_FIFO,
-				 bus->reg + NPCM_SMBFIF_CTS);
+			iowrite8(NPCM7XX_SMBFIF_CTS_CLR_FIFO,
+				 NPCM7XX_SMBFIF_CTS(bus));
 		}
 
-		// In master write operation, NACK is a problem
-		// number of bytes sent to master less than required
-		npcm_smb_master_abort(bus);
+		// In slave write operation, NACK is OK, otherwise it is a problem
+		if (!(	(bus->wr_ind != 0) && (bus->wr_ind == bus->wr_size)))
+			// Either not slave, or number of bytes sent to master less than required
+			// In either case notify upper layer. If we are slave - the upper layer
+			// should still wait for a Slave Stop.
+		{
+
+
+			// iowrite8(NPCM7XX_SMBST_NEGACK, NPCM7XX_SMBST(bus));
+			bus->state = SMB_IDLE;
+			NPCM7XX_smb_callback(bus, SMB_NACK_IND, bus->wr_ind);
+		}
+
+		// else:
+		// Slave has to wait for SMB_STOP to decide this is the end of the transaction.
+		// Therefore transaction is not yet considered as done
+		//
+		// In Master mode, NEGACK should be cleared only after generating STOP.
+		// In such case, the bus is released from stall only after the software clears NEGACK
+		// bit. Then a Stop condition is sent.
+		iowrite8(NPCM7XX_SMBST_NEGACK, NPCM7XX_SMBST(bus));
+
+		return 0;
+	}
+
+
+	// A Bus Error has been identified
+	if (FIELD_GET(NPCM7XX_SMBST_BER , ioread8(NPCM7XX_SMBST(bus)))) {
+
+		// Check whether bus arbitration or Start or Stop during data xfer
+		I2C_DEBUG("\tBER slave bus = %d\n", bus->num);
+
+		// Reset the module
+		NPCM7XX_smb_reset(bus);
+
+		iowrite8(NPCM7XX_SMBST_BER, NPCM7XX_SMBST(bus));
 		bus->state = SMB_IDLE;
+		NPCM7XX_smb_callback(bus,
+				     SMB_BUS_ERR_IND, NPCM7XX_smb_get_index(bus));
+		return 0;
+	}
 
-		// In Master mode, NEGACK should be cleared only after
-		// generating STOP.
-		// In such case, the bus is released from stall only after the
-		// software clears NEGACK bit.
-		// Then a Stop condition is sent.
-		iowrite8(NPCM_SMBST_NEGACK, bus->reg + NPCM_SMBST);
-		npcm_smb_callback(bus, SMB_NACK_IND, bus->wr_ind);
-		return;
+#if defined (SMB_CAPABILITY_TIMEOUT_SUPPORT)
+
+	// A Bus Timeout has been identified
+	if ((FIELD_GET(NPCM7XX_SMBT_OUT_T_OUTIE, ioread8(NPCM7XX_SMBT_OUT(bus)) ) == 1) &&  // bus timeout int is on
+	    (FIELD_GET(NPCM7XX_SMBT_OUT_T_OUTST, ioread8(NPCM7XX_SMBT_OUT(bus)) ))) {         // and bus timeout status is set
+		I2C_DEBUG("\ttimeout slave bus = %d\n", bus->num);
+		// Reset the module
+		NPCM7XX_smb_reset(bus);
+		iowrite8(ioread8(NPCM7XX_SMBT_OUT(bus)) | NPCM7XX_SMBT_OUT_T_OUTST, NPCM7XX_SMBT_OUT(bus));// Clear EO_BUSY pending bit
+		bus->state = SMB_IDLE;
+		NPCM7XX_smb_callback(bus, SMB_BUS_ERR_IND, NPCM7XX_smb_get_index(bus));
+		return 0;
 	}
+#endif
 
-	// Master mode: a Bus Error has been identified
-	if (FIELD_GET(NPCM_SMBST_BER, ioread8(bus->reg + NPCM_SMBST))) {
-		// Check whether bus arbitration or Start or Stop during data
-		// xfer bus arbitration problem should not result in recovery
-		if (npcm_smb_is_master(bus)) {
-			// Only current master is allowed to issue stop
-			npcm_smb_master_abort(bus);
+#ifdef SMB_CAPABILITY_END_OF_BUSY_SUPPORT
+
+	// A Master End of Busy (meaning Stop Condition happened)
+	if ((FIELD_GET(NPCM7XX_SMBCTL1_EOBINTE, ioread8(NPCM7XX_SMBCTL1(bus)) ) == 1) &&  // End of Busy int is on
+	    (FIELD_GET(NPCM7XX_SMBCST3_EO_BUSY, ioread8(NPCM7XX_SMBCST3(bus)) ))) {        // and End of Busy is set
+		I2C_DEBUG("\tslave End of busy bus = %d\n", bus->num);
+
+		NPCM7XX_smb_eob_int(bus, false);
+
+		bus->state = SMB_IDLE;
+
+		if ((bus->wr_size == SMB_QUICK_PROT) ||
+		    (bus->rd_size == SMB_QUICK_PROT) ||
+		    (bus->rd_size == 0)) {
+			NPCM7XX_smb_callback(bus, bus->stop_ind, 0);
 		} else {
-			// Bus arbitration loss
-			if (bus->retry_count-- > 0) {
-				// Perform a retry (generate a start condition)
-				// as soon as the SMBus is free
-				iowrite8(NPCM_SMBST_BER, bus->reg + NPCM_SMBST);
-				npcm_smb_master_start(bus);
-				return;
-			}
+			NPCM7XX_smb_callback(bus, bus->stop_ind,
+					     bus->rd_ind);
 		}
-		iowrite8(NPCM_SMBST_BER, bus->reg + NPCM_SMBST);
-		bus->state = SMB_IDLE;
-		npcm_smb_callback(bus, SMB_BUS_ERR_IND,
-				  npcm_smb_get_index(bus));
-		return;
+		return 0;
 	}
+#endif
 
-	// A Master End of Busy (meaning Stop Condition happened)
-	// End of Busy int is on and End of Busy is set
-	if ((FIELD_GET(NPCM_SMBCTL1_EOBINTE,
-		       ioread8(bus->reg + NPCM_SMBCTL1)) == 1) &&
-	    (FIELD_GET(NPCM_SMBCST3_EO_BUSY,
-		       ioread8(bus->reg + NPCM_SMBCST3)))) {
-		NPCM_I2C_EVENT_LOG(NPCM_I2C_EVENT_EOB);
-		npcm_smb_eob_int(bus, false);
+
+	// A Slave Stop Condition has been identified
+	if (FIELD_GET(NPCM7XX_SMBST_SLVSTP , ioread8(NPCM7XX_SMBST(bus)))) {
+		SMB_STATE_IND_T ind;
+
+		I2C_DEBUG("\tslave stop bus = %d\n", bus->num);
+		ASSERT(bus->master_or_slave == SMB_SLAVE);
+		//printk("line:%d slave on bus%d\n", __LINE__, bus->num);
+		iowrite8(NPCM7XX_SMBST_SLVSTP, NPCM7XX_SMBST(bus));
+
+
+		// Check whether bus arbitration or Start or Stop during data xfer
 		bus->state = SMB_IDLE;
-		if (npcm_smb_is_quick(bus))
-			npcm_smb_callback(bus, bus->stop_ind, 0);
-		else
-			npcm_smb_callback(bus, bus->stop_ind, bus->rd_ind);
-		return;
+		if (bus->fifo_use) {
+			//I2C_DEBUG("slave fifo used\r\n");
+			if (bus->operation == SMB_READ_OPER) {
+				//@@: store the initial index.
+				int ori_read_index = bus->rd_ind;
+				NPCM7XX_smb_read_from_fifo(bus,
+							   FIELD_GET(NPCM7XX_SMBRXF_STS_RX_BYTES,
+							   ioread8(NPCM7XX_SMBRXF_STS(bus))));
+
+				// Be prepared for new transactions
+				//bus->state = SMB_IDLE;
+
+				// if PEC is not used or PEC is used and PEC is correct
+				if ((bus->PEC_use == false) ||
+				    (NPCM7XX_smb_get_PEC(bus) == 0)){
+					ind = SMB_SLAVE_DONE_IND;
+				}
+
+				// PEC value is not correct
+				else {
+					ind = SMB_SLAVE_PEC_ERR_IND;
+				}
+				NPCM7XX_smb_callback(bus,
+						     // Notify upper layer that illegal data received
+						     ind,
+						     bus->rd_ind);
+
+				//@@: It handles the fifo which contains less or equal to predefined 16 bytes.
+				//@@: If there is no more byte to read, the following loop won't execute.
+				for(; ori_read_index < bus->rd_ind ; ori_read_index++)
+				{
+					//printk("ori_read_index: 0x%x, bus->rd_ind: 0x%x\r\n", ori_read_index, bus->rd_ind);
+					i2c_slave_event(bus->slave, I2C_SLAVE_WRITE_RECEIVED, &bus->read_data_buf[ori_read_index]);
+					//I2C_DEBUG("bus->read_data_buf: %02x\r\n", bus->read_data_buf[ori_read_index]);
+				}
+
+				i2c_slave_event(bus->slave, I2C_SLAVE_STOP, NULL);
+
+			}
+			if (bus->operation == SMB_WRITE_OPER) {
+				//bus->state = SMB_IDLE;
+				NPCM7XX_smb_callback(bus, SMB_SLAVE_DONE_IND,
+						     bus->wr_ind);
+			}
+
+			iowrite8(ioread8(NPCM7XX_SMBFIF_CTS(bus)) | NPCM7XX_SMBFIF_CTS_SLVRSTR
+				 | NPCM7XX_SMBFIF_CTS_CLR_FIFO
+				 | NPCM7XX_SMBFIF_CTS_RXF_TXE, NPCM7XX_SMBFIF_CTS(bus));
+		}
+
+		// FIFO is not used
+		else {
+			//@@: Just check.
+			//I2C_DEBUG("slave fifo not used\r\n");
+			if (bus->operation == SMB_READ_OPER) {
+
+				// if PEC is not used or PEC is used and PEC is correct
+				if ((bus->PEC_use == false) ||
+				    (NPCM7XX_smb_get_PEC(bus) == 0))
+				    ind = SMB_SLAVE_DONE_IND;
+
+				// PEC value is not correct
+				else
+					ind = SMB_SLAVE_PEC_ERR_IND;
+
+				NPCM7XX_smb_callback(bus, ind, bus->rd_ind);
+			} else
+				//bus->state = SMB_IDLE;
+				NPCM7XX_smb_callback(bus, SMB_SLAVE_DONE_IND,
+				bus->wr_ind);
+		}
+
+		return 0;
 	}
 
-	// Address sent and requested stall occurred (Master mode)
-	if (FIELD_GET(NPCM_SMBST_STASTR, ioread8(bus->reg + NPCM_SMBST))) {
-		// Check for Quick Command SMBus protocol
-		if (npcm_smb_is_quick(bus)) {
-			npcm_smb_eob_int(bus, true);
-			npcm_smb_master_stop(bus);
+	// A Slave restart Condition has been identified
+	if (bus->fifo_use && FIELD_GET(NPCM7XX_SMBFIF_CTS_SLVRSTR , ioread8( NPCM7XX_SMBFIF_CTS(bus)))) {
+		I2C_DEBUG("\tslave restart bus = %d\n", bus->num);
+		//printk("line:%d slave on bus%d\n", __LINE__, bus->num);
+		ASSERT(bus->master_or_slave == SMB_SLAVE);
 
-			// Update status
-			bus->state = SMB_STOP_PENDING;
-			bus->stop_ind = SMB_MASTER_DONE_IND;
+		if (bus->operation == SMB_READ_OPER)
+			NPCM7XX_smb_read_from_fifo(bus,
+			FIELD_GET(NPCM7XX_SMBRXF_STS_RX_BYTES,
+			ioread8(NPCM7XX_SMBRXF_STS(bus))));
+
+		iowrite8(NPCM7XX_SMBFIF_CTS_SLVRSTR, NPCM7XX_SMBFIF_CTS(bus));
+	}
+
+	// A Slave Address Match has been identified
+	if (FIELD_GET(NPCM7XX_SMBST_NMATCH , ioread8(NPCM7XX_SMBST(bus)))) {
+		bool slave_tx;
+		SMB_STATE_IND_T ind = SMB_NO_STATUS_IND;
+		u8 info = 0;
 
-		} else if (bus->rd_size == 1) {
-			// Receiving one byte only - set NACK after ensuring
-			// slave ACKed the address byte
-			npcm_smb_nack(bus);
+		I2C_DEBUG("\tslave match bus = %d\n", bus->num);
+
+		if (bus->fifo_use == false)
+			iowrite8(NPCM7XX_SMBST_NMATCH, NPCM7XX_SMBST(bus));
+
+		if (FIELD_GET(NPCM7XX_SMBST_XMIT, ioread8(NPCM7XX_SMBST(bus))))
+			slave_tx = true;
+		else
+			slave_tx = false;
+
+		if (bus->state == SMB_IDLE) {
+			// Indicate Slave Mode
+			if (slave_tx)
+				ind = SMB_SLAVE_XMIT_IND;
+			else
+				ind = SMB_SLAVE_RCV_IND;
+
+			// Check which type of address match
+			if (FIELD_GET(NPCM7XX_SMBCST_MATCH , ioread8(NPCM7XX_SMBCST(bus)))) {
+				u16 address_match = ((ioread8(NPCM7XX_SMBCST3(bus)) & 0x7) << 7) | (ioread8(NPCM7XX_SMBCST2(bus)) & 0x7F);
+				I2C_DEBUG("\tSA 0x%x bus = %d\n", address_match , bus->num);
+				info = 0;
+				ASSERT(address_match);
+				while (address_match) {
+					if (address_match & 1)
+						break;
+					info++;
+					address_match = address_match >> 1;
+				}
+				bus->own_slave_addr = FIELD_GET(NPCM7XX_SMBADDRx_ADDR, NPCM7XX_smb_get_slave_addr_l(bus, (SMB_ADDR_T)info));
+				if (bus->PEC_mask & BIT(info)) {
+					bus->PEC_use = true;
+					bus->crc_data = 0;
+					if (slave_tx)
+						NPCM7XX_smb_calc_PEC(bus, (bus->own_slave_addr & 0x7F) << 1 | 1);
+					else
+						NPCM7XX_smb_calc_PEC(bus, (bus->own_slave_addr & 0x7F) << 1);
+				} else
+					bus->PEC_use = false;
+			} else {
+				if (FIELD_GET(NPCM7XX_SMBCST_GCMATCH , ioread8(NPCM7XX_SMBCST(bus)))) {
+					info = (u8)SMB_GC_ADDR;
+					bus->own_slave_addr = 0;
+				} else {
+					if (FIELD_GET(NPCM7XX_SMBCST_ARPMATCH , ioread8(NPCM7XX_SMBCST(bus)))) {
+						info = (u8)SMB_ARP_ADDR;
+						bus->own_slave_addr = 0x61;
+					}
+				}
+			}
+		} else {
+			//  Slave match can happen in two options:
+			//  1. Start, SA, read	( slave read without further ado).
+			//  2. Start, SA, read , data , restart, SA, read,  ... ( slave read in fragmented mode)
+			//  3. Start, SA, write, data, restart, SA, read, .. ( regular write-read mode)
+			if (((bus->state == SMB_OPER_STARTED) &&
+				(bus->operation == SMB_READ_OPER) &&
+				slave_tx) || (!slave_tx)){
+				// slave transmit after slave receive w/o Slave Stop implies repeated start
+				ind = SMB_SLAVE_RESTART_IND;
+				info = (u8)(bus->rd_ind);
+				NPCM7XX_smb_calc_PEC(bus, (bus->own_slave_addr & 0x7F) << 1 | 1);
+			}
 		}
 
-		// Reset stall-after-address-byte
-		npcm_smb_stall_after_start(bus, false);
+		// Address match automatically implies slave mode
+		ASSERT(!FIELD_GET(NPCM7XX_SMBST_MASTER, ioread8(NPCM7XX_SMBST(bus))));
+		bus->master_or_slave = SMB_SLAVE;
+		//printk("line:%d slave on bus%d\n", __LINE__, bus->num);
+		bus->state = SMB_SLAVE_MATCH;
+
+		// Notify upper layer
+		// Upper layer must at this stage call the driver routine for slave tx or rx,
+		// to eliminate a condition of slave being notified but not yet starting
+		// transaction - and thus an endless int from SDAST for the slave RCV or TX !
+		NPCM7XX_smb_callback(bus, ind, info);
+
+#ifdef SMB_RECOVERY_SUPPORT
+
+		// By now, SMB operation state should have been changed from MATCH to SMB_OPER_STARTED.
+		// If state hasn't been changed already, this may suggest that the SMB slave is not ready to
+		// transmit or receive data.
+		//
+		// In addition, when using FIFO, NMATCH bit is cleared only when moving to SMB_OPER_STARTED state.
+		// If NMATCH is not cleared, we would get an endless SMB int.
+		// Therefore, Abort the slave, such that SMB HW and state machine return to a default, functional
+		// state.
+		if (bus->state == SMB_SLAVE_MATCH) {
+			NPCM7XX_smb_slave_abort(bus);
+			NPCM7XX_smb_callback(bus, SMB_BUS_ERR_IND, NPCM7XX_smb_get_index(bus));
+			return 0;
+		}
 
-		// Clear stall only after setting STOP
-		iowrite8(NPCM_SMBST_STASTR, bus->reg + NPCM_SMBST);
+		// Slave abort data
+		// if the SMBus's status is not match current status reg of XMIT
+		// the Slave device will enter dead-lock and stall bus forever
+		// Add this check rule to avoid this condition
+		if ((bus->operation == SMB_READ_OPER  &&
+			ind == SMB_SLAVE_XMIT_IND) ||
+			(bus->operation == SMB_WRITE_OPER
+			&& ind == SMB_SLAVE_RCV_IND)) {
+			NPCM7XX_smb_slave_abort(bus);
+
+			NPCM7XX_smb_callback(bus, SMB_BUS_ERR_IND, NPCM7XX_smb_get_index(bus));
+			return 0;
+		}
+#endif
 
-		return;
+		// If none of the above - BER should occur
 	}
 
-	// SDA status is set - transmit or receive, master
-	if (FIELD_GET(NPCM_SMBST_SDAST, ioread8(bus->reg + NPCM_SMBST)) ||
-	    (bus->fifo_use &&
-	    (npcm_smb_tx_fifo_full(bus) || npcm_smb_rx_fifo_full(bus)))) {
+
+
+	// SDA status is set - transmit or receive, slave
+	if (FIELD_GET(NPCM7XX_SMBST_SDAST, ioread8(NPCM7XX_SMBST(bus))) ||
+	    (bus->fifo_use   &&
+	    (NPCM7XX_smb_tx_fifo_full(bus) || NPCM7XX_smb_rx_fifo_full(bus)))) {
 		// Status Bit is cleared by writing to or reading from SDA
 		// (depending on current direction)
-		switch (bus->state) {
-		// Handle unsuccessful bus mastership
-		case SMB_IDLE:
-			npcm_smb_master_abort(bus);
-			return;
 
-		case SMB_MASTER_START:
-			if (npcm_smb_is_master(bus)) {
-				u8 addr_byte = bus->dest_addr;
+		I2C_DEBUG("\tSDA slave set bus = %d\n", bus->num);
 
-				bus->crc_data = 0;
-				if (npcm_smb_is_quick(bus)) {
-					// Need to stall after successful
-					// completion of sending address byte
-					npcm_smb_stall_after_start(bus, true);
-				} else if (bus->wr_size == 0) {
-					// Set direction to Read
-					addr_byte |= (u8)0x1;
-					bus->operation = SMB_READ_OPER;
-				} else {
-					bus->operation = SMB_WRITE_OPER;
+		// SDA status is set - transmit or receive: Handle slave mode
+
+		// Perform slave read. No need to distinguish between last byte and the rest of the bytes.
+		if ((bus->operation == SMB_READ_OPER)) {
+			if (bus->fifo_use == false) {
+				u8 data;
+
+				(void)NPCM7XX_smb_read_byte(bus, &data);
+				if (bus->rd_ind < bus->rd_size) {
+					// Keep read data
+					bus->read_data_buf[bus->rd_ind++] = data;
+					if ((bus->rd_ind == 1) && bus->rd_size == SMB_BLOCK_PROT)
+						// First byte indicates length in block protocol
+						bus->rd_size = data;
+
+#ifdef SMB_WRAP_AROUND_BUFFER
+					if (bus->rd_ind == bus->rd_size) {
+						// Reset state for the remaining bytes transaction
+						bus->state = SMB_SLAVE_MATCH;
+
+						// Notify upper layer of that a byte had received
+						NPCM7XX_smb_callback(bus,
+								     SMB_SLAVE_RCV_MISSING_DATA_IND,
+								     NPCM7XX_smb_get_index(bus));
+					}
+#endif
+				}
+			}
+			// FIFO is used
+			else {
+				if (NPCM7XX_smb_rx_fifo_full(bus)) {
+					//@@: store the initial index.
+					int ori_read_index = bus->rd_ind;
+					//I2C_DEBUG("ori_read_index: %02x\r\n", ori_read_index);
+
+					NPCM7XX_smb_read_from_fifo(bus,
+								   FIELD_GET(NPCM7XX_SMBRXF_CTL_RX_THR,
+								   ioread8(NPCM7XX_SMBRXF_CTL(bus))));
+					//@@:
+					for(; ori_read_index < bus->rd_ind ; ori_read_index++)
+					{
+						i2c_slave_event(bus->slave, I2C_SLAVE_WRITE_RECEIVED, &bus->read_data_buf[ori_read_index]);
+						//I2C_DEBUG("bus->read_data_buf: %02x\r\n", bus->read_data_buf[ori_read_index]);
+					}
+
+					NPCM7XX_smb_clear_rx_fifo(bus);
+				}
+			}
+		}
+		// Perform slave write.
+		else {
+			// More bytes to write
+			if ((bus->operation == SMB_WRITE_OPER) && (bus->wr_ind < bus->wr_size)) {
+				if (bus->fifo_use == false) {
+					if (bus->wr_ind + 1 == bus->wr_size)
+						NPCM7XX_smb_write_PEC(bus);
+					else if (bus->wr_ind < bus->wr_size)
+						NPCM7XX_smb_write_byte(bus, bus->write_data_buf[bus->wr_ind]);
+					bus->wr_ind++;
 				}
+				// FIFO is used
+				else {
+					u16 wcount;
+					wcount =  (bus->wr_size - bus->wr_ind);
 
-	// Receiving one byte only - stall after successful completion of
-	// sending address byte. If we NACK here, and slave doesn't ACK the
-	// address, we might unintentionally NACK the next multi-byte read
-				if (bus->wr_size == 0 && bus->rd_size == 1)
-					npcm_smb_stall_after_start(bus, true);
+					// TODO: replace :
+					if (wcount >= SMBUS_FIFO_SIZE)
+						wcount = SMBUS_FIFO_SIZE;
 
-				// Write the address to the bus
-				bus->state = SMB_OPER_STARTED;
-				npcm_smb_wr_byte(bus, addr_byte);
-			} else {
-				dev_err(bus->dev,
-					"SDA, bus%d is not master, wr %d 0x%x...\n",
-					bus->num, bus->wr_size,
-					bus->wr_buf[0]);
+					iowrite8((u8)wcount, NPCM7XX_SMBTXF_CTL(bus));
+
+					// with:
+					NPCM7XX_smb_set_fifo(bus, -1, wcount);
+					NPCM7XX_smb_write_to_fifo(bus, wcount);
+
+					NPCM7XX_smb_clear_tx_fifo(bus);
+				}
 			}
-			break;
 
-		// SDA status is set - transmit or receive: Handle master mode
-		case SMB_OPER_STARTED:
-			if (bus->operation == SMB_WRITE_OPER)
-				npcm_smb_int_master_handler_write(bus);
-			else if (bus->operation == SMB_READ_OPER)
-				npcm_smb_int_master_handler_read(bus);
-			else
-				pr_err("I2C%d: unknown operation\n", bus->num);
-			break;
-		default:
-			dev_err(bus->dev, "i2c%d master sda err on state machine\n",
-				bus->num);
+			// If all bytes were written, ignore further master read requests.
+			else {
+#if !defined(SMB_WRAP_AROUND_BUFFER)
+				ASSERT(false);
+#endif
+				if (bus->fifo_use == false) {
+					// Clear SDA Status bit
+					if (bus->wr_ind != 0){
+						// Was writing
+#ifdef SMB_WRAP_AROUND_BUFFER
+						// We're out of bytes. Ask the higher level for more bytes. Let it know that driver used all its' bytes
+
+						// Reset state for the remaining bytes transaction
+						bus->state = SMB_SLAVE_MATCH;
+
+						// Notify upper layer of transaction completion
+						// by overrind ind and info_p in next EXECUTE_FUNC()
+						ind = SMB_SLAVE_XMIT_MISSING_DATA_IND;
+						//  TBD : info_p = &(bus->wr_ind);
+#else
+						NPCM7XX_smb_write_byte(bus, 0xFF);
+#endif
+					} else {
+						u8 data;
+						// Was reading
+						(void)NPCM7XX_smb_read_byte(bus, &data);
+					}
+				}
+				// write\read redundant bytes with FIFO (if there are any bytes to write)
+				else {
+					// Set threshold size
+					iowrite8((u8)SMBUS_FIFO_SIZE, NPCM7XX_SMBTXF_CTL(bus));
+
+					// TODO: replace with:
+					// NPCM7XX_smb_set_fifo(bus, -1, wcount);
+
+					NPCM7XX_smb_write_to_fifo(bus, SMBUS_FIFO_SIZE);
+
+					NPCM7XX_smb_clear_tx_fifo(bus);
+				}
+				// Notify upper layer of transaction completion
+				NPCM7XX_smb_callback(bus, SMB_NO_DATA_IND, bus->rd_ind);
+			} // All bytes sent/received
 		}
+	} //SDAST
+	return 1;
+}
+
+#endif  //  IS_ENABLED(CONFIG_I2C_SLAVE)
+
+
+////////////////////////////   END OF SLAVE HANDLER
+
+
+static void NPCM7XX_smb_reset(struct NPCM7XX_i2c *bus)
+{
+	// Save NPCM7XX_SMBCTL1 relevant bits. It is being cleared when the
+	// module is disabled
+	u8 smbctl1 = ioread8(NPCM7XX_SMBCTL1(bus)) & (NPCM7XX_SMBCTL1_GCMEN
+						      | NPCM7XX_SMBCTL1_INTEN
+						      | NPCM7XX_SMBCTL1_NMINTE);
+
+	// Disable the SMB module
+	iowrite8((ioread8(NPCM7XX_SMBCTL2(bus)) & ~SMBCTL2_ENABLE) |
+		 FIELD_PREP(SMBCTL2_ENABLE, DISABLE), NPCM7XX_SMBCTL2(bus));
+
+	// Enable the SMB module
+	(void)NPCM7XX_smb_enable(bus);
+
+	// Restore NPCM7XX_SMBCTL1 status
+	iowrite8(smbctl1, NPCM7XX_SMBCTL1(bus));
+
+	// Reset driver status
+	bus->state = SMB_IDLE;
+	//
+	// Configure FIFO disabled mode so slave will not use fifo
+	//  (master will set it on if supported)
+	//@@: Enable fifo for now
+	//iowrite8(ioread8(NPCM7XX_SMBFIF_CTL(bus)) & ~NPCM7XX_SMBFIF_CTL_FIFO_EN,
+	//	 NPCM7XX_SMBFIF_CTL(bus));
+	//bus->fifo_use = false;
+}
+
+
+static int NPCM7XX_smb_master_abort(struct NPCM7XX_i2c *bus)
+{
+	int ret = -(EIO);
+	I2C_DEBUG2("bus%d addr=0x%x\n", bus->num, bus->dest_addr);
+
+	// Only current master is allowed to issue Stop Condition
+	if (FIELD_GET(NPCM7XX_SMBST_MASTER, ioread8(NPCM7XX_SMBST(bus)))){
+		NPCM7XX_smb_abort_data(bus);
+		ret = 0;
+
 	}
+
+	NPCM7XX_smb_reset(bus);
+
+	return ret;
 }
 
-static int npcm_smb_recovery(struct i2c_adapter *_adap)
+
+static int NPCM7XX_smb_recovery(struct i2c_adapter *_adap)
 {
-	u8   iter = 27;	  // Allow one byte to be sent by the Slave
+	u8   iter = 27;   // Allow one byte to be sent by the Slave
 	u16  timeout;
 	bool done = false;
-	struct npcm_i2c *bus = container_of(_adap, struct npcm_i2c, adap);
+	struct NPCM7XX_i2c *bus = container_of(_adap, struct NPCM7XX_i2c, adap);
 
-	dev_info(bus->dev, "recovery bus%d\n", bus->num);
 
-	might_sleep();
+	I2C_DEBUG("recovery bus%d\n",  bus->num);
 
 	// Disable int
-	npcm_smb_int_enable(bus, false);
+	NPCM7XX_smb_int_enable(bus, false);
+
 
 	// Check If the SDA line is active (low)
-	if (FIELD_GET(NPCM_SMBCST_TSDA, ioread8(bus->reg + NPCM_SMBCST)) == 0) {
-		// Repeat the following sequence until SDA is released
+	if (FIELD_GET(NPCM7XX_SMBCST_TSDA , ioread8(NPCM7XX_SMBCST(bus))) == 0) {
+
+
+		// Repeat the following sequence until SDA becomes inactive (high)
 		do {
 			// Issue a single SCL cycle
-			iowrite8(NPCM_SMBCST_TGSCL, bus->reg + NPCM_SMBCST);
+			iowrite8(NPCM7XX_SMBCST_TGSCL, NPCM7XX_SMBCST(bus));
 			timeout = ABORT_TIMEOUT;
-			while (timeout != 0 &&
-			       FIELD_GET(NPCM_SMBCST_TGSCL,
-					 ioread8(bus->reg + NPCM_SMBCST) == 0))
-				timeout--;
-
+			while ((FIELD_GET(NPCM7XX_SMBCST_TGSCL, ioread8(NPCM7XX_SMBCST(bus))) == 0) && (--timeout != 0) );
 			// If SDA line is inactive (high), stop
-			if (FIELD_GET(NPCM_SMBCST_TSDA,
-				      ioread8(bus->reg + NPCM_SMBCST)) == 1)
+			if (FIELD_GET(NPCM7XX_SMBCST_TSDA, ioread8(NPCM7XX_SMBCST(bus))) == 1)
 				done = true;
-		} while ((!done) && (--iter != 0));
+		} while ((done == false) && (--iter != 0));
 
 		// If SDA line is released (high)
 		if (done) {
 			// Clear BB (BUS BUSY) bit
-			iowrite8(NPCM_SMBCST_BB, bus->reg + NPCM_SMBCST);
+			iowrite8(NPCM7XX_SMBCST_BB, NPCM7XX_SMBCST(bus));
 
-			// Generate a START, to synchronize Master and Slave
-			npcm_smb_master_start(bus);
+			// Generate a START condition, to synchronize Master and Slave
+			NPCM7XX_smb_master_start(bus);
 
 			// Wait until START condition is sent, or timeout
 			timeout = ABORT_TIMEOUT;
-			while (timeout != 0 && !npcm_smb_is_master(bus))
-				timeout--;
+			while ((!FIELD_GET(NPCM7XX_SMBST_MASTER, ioread8(NPCM7XX_SMBST(bus)))== 0) && (--timeout != 0));
 
 			// If START condition was sent
 			if (timeout > 0) {
 				// Send an address byte
-				npcm_smb_wr_byte(bus, bus->dest_addr);
+				NPCM7XX_smb_write_byte(bus, bus->dest_addr);
 
 				// Generate a STOP condition
-				npcm_smb_master_stop(bus);
+				NPCM7XX_smb_master_stop(bus);
 			}
+
 			return 0;
 		}
 	}
 
+
 	// check if success:
-	if (npcm_smb_get_SCL(_adap) == 1 && npcm_smb_get_SDA(_adap) == 1)
-		goto npcm_smb_recovery_done;
+	if ((NPCM7XX_smb_get_SCL(_adap) == 1) &&
+	    (NPCM7XX_smb_get_SDA(_adap) == 1) )
+	    	goto NPCM7XX_smb_recovery_done;
 
 	// hold clock low for 35ms: 25 and some spair:
-	npcm_smb_set_SCL(_adap, 0);
-	usleep_range(35000, 40000);
-	npcm_smb_set_SCL(_adap, 1);
-	usleep_range(1000, 2000);
+	NPCM7XX_smb_set_SCL(_adap, 0);
+	msleep(35);
+	NPCM7XX_smb_set_SCL(_adap, 1);
+	udelay(1000);
 
 	// check if success:
-	if (npcm_smb_get_SCL(_adap) == 1 && npcm_smb_get_SDA(_adap) == 1)
-		goto npcm_smb_recovery_done;
+	if ((NPCM7XX_smb_get_SCL(_adap) == 1) &&
+	    (NPCM7XX_smb_get_SDA(_adap) == 1) )
+	    	goto NPCM7XX_smb_recovery_done;
 
 	return 0;
 
-npcm_smb_recovery_done:
+NPCM7XX_smb_recovery_done:
+
+	// Enable int
+	NPCM7XX_smb_int_enable(bus, true);
+
+	return -(ENOTRECOVERABLE);
+}
+
+
+static void NPCM7XX_smb_int_enable(struct NPCM7XX_i2c *bus, bool enable)
+{
+	iowrite8((ioread8(NPCM7XX_SMBCTL1(bus)) & ~NPCM7XX_SMBCTL1_INTEN) |
+		 FIELD_PREP(NPCM7XX_SMBCTL1_INTEN,
+		 enable), NPCM7XX_SMBCTL1(bus));
+}
+
+#if IS_ENABLED(CONFIG_I2C_SLAVE) && defined SMB_RECOVERY_SUPPORT
+static void NPCM7XX_smb_slave_abort(struct NPCM7XX_i2c *bus)
+{
+	volatile u8 temp;
+
+	// Disable int.
+	NPCM7XX_smb_int_enable(bus, false);
+
+	// Dummy read to clear interface.
+	temp = ioread8(NPCM7XX_SMBSDA(bus));
+
+	// Clear NMATCH and BER bits by writing 1s to them.
+	iowrite8(ioread8(NPCM7XX_SMBST(bus)) | NPCM7XX_SMBST_BER
+		 | NPCM7XX_SMBST_NMATCH,
+		 NPCM7XX_SMBST(bus));
+
+
+	// Reset driver status
+	bus->state = SMB_IDLE;
+
+	// Disable SMB Module
+	iowrite8((ioread8(NPCM7XX_SMBCTL2(bus)) & ~SMBCTL2_ENABLE) |
+			FIELD_PREP(SMBCTL2_ENABLE, DISABLE),
+			NPCM7XX_SMBCTL2(bus));
+
+	// Delay 100 us
+	udelay(10); // TBD must be out of int
+
+	// Enable SMB Module
+	(void)NPCM7XX_smb_enable(bus);
+
+	// Enable int.
+	NPCM7XX_smb_int_enable(bus, true);
+
+	//lint -e{550} suppress PC-Lint warning on Symbol 'temp' not accessed
+}
+#endif //!defined SMB_MASTER_ONLY && defined SMB_RECOVERY_SUPPORT
+
+
+static const u8 crc8_table[256] = {
+	0x00, 0x07, 0x0E, 0x09, 0x1C, 0x1B, 0x12, 0x15,
+	0x38, 0x3F, 0x36, 0x31, 0x24, 0x23, 0x2A, 0x2D,
+	0x70, 0x77, 0x7E, 0x79, 0x6C, 0x6B, 0x62, 0x65,
+	0x48, 0x4F, 0x46, 0x41, 0x54, 0x53, 0x5A, 0x5D,
+	0xE0, 0xE7, 0xEE, 0xE9, 0xFC, 0xFB, 0xF2, 0xF5,
+	0xD8, 0xDF, 0xD6, 0xD1, 0xC4, 0xC3, 0xCA, 0xCD,
+	0x90, 0x97, 0x9E, 0x99, 0x8C, 0x8B, 0x82, 0x85,
+	0xA8, 0xAF, 0xA6, 0xA1, 0xB4, 0xB3, 0xBA, 0xBD,
+	0xC7, 0xC0, 0xC9, 0xCE, 0xDB, 0xDC, 0xD5, 0xD2,
+	0xFF, 0xF8, 0xF1, 0xF6, 0xE3, 0xE4, 0xED, 0xEA,
+	0xB7, 0xB0, 0xB9, 0xBE, 0xAB, 0xAC, 0xA5, 0xA2,
+	0x8F, 0x88, 0x81, 0x86, 0x93, 0x94, 0x9D, 0x9A,
+	0x27, 0x20, 0x29, 0x2E, 0x3B, 0x3C, 0x35, 0x32,
+	0x1F, 0x18, 0x11, 0x16, 0x03, 0x04, 0x0D, 0x0A,
+	0x57, 0x50, 0x59, 0x5E, 0x4B, 0x4C, 0x45, 0x42,
+	0x6F, 0x68, 0x61, 0x66, 0x73, 0x74, 0x7D, 0x7A,
+	0x89, 0x8E, 0x87, 0x80, 0x95, 0x92, 0x9B, 0x9C,
+	0xB1, 0xB6, 0xBF, 0xB8, 0xAD, 0xAA, 0xA3, 0xA4,
+	0xF9, 0xFE, 0xF7, 0xF0, 0xE5, 0xE2, 0xEB, 0xEC,
+	0xC1, 0xC6, 0xCF, 0xC8, 0xDD, 0xDA, 0xD3, 0xD4,
+	0x69, 0x6E, 0x67, 0x60, 0x75, 0x72, 0x7B, 0x7C,
+	0x51, 0x56, 0x5F, 0x58, 0x4D, 0x4A, 0x43, 0x44,
+	0x19, 0x1E, 0x17, 0x10, 0x05, 0x02, 0x0B, 0x0C,
+	0x21, 0x26, 0x2F, 0x28, 0x3D, 0x3A, 0x33, 0x34,
+	0x4E, 0x49, 0x40, 0x47, 0x52, 0x55, 0x5C, 0x5B,
+	0x76, 0x71, 0x78, 0x7F, 0x6A, 0x6D, 0x64, 0x63,
+	0x3E, 0x39, 0x30, 0x37, 0x22, 0x25, 0x2C, 0x2B,
+	0x06, 0x01, 0x08, 0x0F, 0x1A, 0x1D, 0x14, 0x13,
+	0xAE, 0xA9, 0xA0, 0xA7, 0xB2, 0xB5, 0xBC, 0xBB,
+	0x96, 0x91, 0x98, 0x9F, 0x8A, 0x8D, 0x84, 0x83,
+	0xDE, 0xD9, 0xD0, 0xD7, 0xC2, 0xC5, 0xCC, 0xCB,
+	0xE6, 0xE1, 0xE8, 0xEF, 0xFA, 0xFD, 0xF4, 0xF3
+};
+
+static u8 NPCM7XX_smb_calc_crc8(u8 crc_data, u8 data)
+{
+	u8 tmp = crc_data ^ data;
+
+	crc_data = crc8_table[tmp];
+
+	return crc_data;
+}
+
+static void NPCM7XX_smb_calc_PEC(struct NPCM7XX_i2c *bus, u8 data)
+{
+	if (bus->PEC_use)
+		bus->crc_data = NPCM7XX_smb_calc_crc8(bus->crc_data, data);
+}
+
+static inline u8 NPCM7XX_smb_get_PEC(struct NPCM7XX_i2c *bus)
+{
+	if (bus->PEC_use)
+#if defined SMB_CAPABILITY_HW_PEC_SUPPORT
+		return ioread8(NPCM7XX_SMBPEC(bus));
+#else
+		return bus->crc_data;
+#endif
+	else
+		return 0;
+}
+
+static inline void NPCM7XX_smb_write_PEC(struct NPCM7XX_i2c *bus)
+{
+	if (bus->PEC_use)
+	{
+		// get PAC value and write to the bus:
+		NPCM7XX_smb_write_byte(bus, NPCM7XX_smb_get_PEC(bus));
+	}
+	return;
+}
+
 
-	npcm_smb_int_enable(bus, true);
-	return -(ENOTRECOVERABLE);
+#ifdef TBD
+static void NPCM7XX_smb_re_enable_module(struct NPCM7XX_i2c *bus)
+{
+	// Enable SMB int and New Address Match int source
+	iowrite8((ioread8(NPCM7XX_SMBCTL1(bus)) & ~NPCM7XX_SMBCTL1_NMINTE) |
+			FIELD_PREP(NPCM7XX_SMBCTL1_NMINTE, ENABLE),
+			NPCM7XX_SMBCTL1(bus));
+	iowrite8((ioread8(NPCM7XX_SMBCTL1(bus)) & ~NPCM7XX_SMBCTL1_INTEN) |
+			FIELD_PREP(NPCM7XX_SMBCTL1_INTEN, ENABLE),
+			NPCM7XX_SMBCTL1(bus));
 }
 
-static bool npcm_smb_init_clk(struct npcm_i2c *bus, enum smb_mode mode,
-			      u32 bus_freq)
+static bool NPCM7XX_smb_int_is_pending(void)
 {
-	u32  k1 = 0;
-	u32  k2 = 0;
-	u8   dbnct = 0;
-	u32  sclfrq = 0;
-	u8   hldt = 7;
-	bool fast_mode = false;
-	u32  src_clk_freq; // in KHz
-
-	src_clk_freq = bus->apb_clk / 1000;
+	struct NPCM7XX_i2c *bus;
+	bool InterruptIsPending = false;
 
-	if (bus_freq <= SMBUS_FREQ_100KHZ) {
-		sclfrq = src_clk_freq / (bus_freq * 4);
-
-		if (sclfrq < SCLFRQ_MIN || sclfrq > SCLFRQ_MAX)
-			return false;
+	for (bus = 0; bus < SMB_NUM_OF_MODULES; bus++)
+		InterruptIsPending |= INTERRUPT_PENDING(SMB_INTERRUPT_PROVIDER,
+		SMB_INTERRUPT(bus));
 
-		if (src_clk_freq >= 40000)
-			hldt = 17;
-		else if (src_clk_freq >= 12500)
-			hldt = 15;
-		else
-			hldt = 7;
-	}
+	return InterruptIsPending;
+}
+#endif
 
-	else if (bus_freq == SMBUS_FREQ_400KHZ) {
-		sclfrq = 0;
-		fast_mode = true;
 
-		if ((mode == SMB_MASTER && src_clk_freq < 7500) ||
-		    (mode == SMB_SLAVE && src_clk_freq < 10000))
-		  // 400KHZ cannot be supported for master core clock < 7.5 MHZ
-		  // or slave core clock < 10 MHZ
-			return false;
+//
+//  NPCM7XX SMB module allows writing to SCL and SDA pins directly
+//  without the need to change muxing of pins.
+//  This feature will be used for recovery sequences i.e.
+//
+static void NPCM7XX_smb_set_SCL(struct i2c_adapter *_adap, int level)
+{
+	unsigned long flags;
+	struct NPCM7XX_i2c *bus = container_of(_adap, struct NPCM7XX_i2c, adap);
 
-		// Master or Slave with frequency > 25 MHZ
-		if (mode == SMB_MASTER || src_clk_freq > 25000) {
-			hldt = (u8)__KERNEL_DIV_ROUND_UP(src_clk_freq * 300,
-							 1000000) + 7;
-			if (mode == SMB_MASTER) {
-				k1 = __KERNEL_DIV_ROUND_UP(src_clk_freq * 1600,
-							   1000000);
-				k2 = __KERNEL_DIV_ROUND_UP(src_clk_freq * 900,
-							   1000000);
-				k1 = round_up(k1, 2);
-				k2 = round_up(k2 + 1, 2);
-				if (k1 < SCLFRQ_MIN || k1 > SCLFRQ_MAX ||
-				    k2 < SCLFRQ_MIN || k2 > SCLFRQ_MAX)
-					return false;
-			}
-		} else { // Slave with frequency 10-25 MHZ
-			hldt = 7;
-			dbnct = 2;
-		}
-	}
+	// Select Bank 0 to access NPCM7XX_SMBCTL4
+	spin_lock_irqsave(&bus->lock, flags);
+	NPCM7XX_smb_select_bank(bus, SMB_BANK_0);
+#ifdef SMB_CAPABILITY_FORCE_SCL_SDA
+	// Set SCL_LVL, SDA_LVL bits as Read/Write (R/W)
+	iowrite8(ioread8(NPCM7XX_SMBCTL4(bus)) | SMBCTL4_LVL_WE,
+		 NPCM7XX_SMBCTL4(bus));
 
-	else if (bus_freq == SMBUS_FREQ_1MHZ) {
-		sclfrq = 0;
-		fast_mode = true;
+	// Set level
+	iowrite8((ioread8(NPCM7XX_SMBCTL3(bus))
+		& ~SMBCTL3_SCL_LVL) | FIELD_PREP(SMBCTL3_SCL_LVL,
+		level), NPCM7XX_SMBCTL3(bus));
 
-		if ((mode == SMB_MASTER && src_clk_freq < 15000) ||
-		    (mode == SMB_SLAVE	&& src_clk_freq < 24000))
-		// 1MHZ cannot be supported for master core clock < 15 MHZ
-		// or slave core clock < 24 MHZ
-			return false;
+	// Set SCL_LVL, SDA_LVL bits as Read Only (RO)
+	iowrite8(ioread8(NPCM7XX_SMBCTL4(bus))
+		 & ~SMBCTL4_LVL_WE, NPCM7XX_SMBCTL4(bus));
+#endif
+	// Return to Bank 1
+	NPCM7XX_smb_select_bank(bus, SMB_BANK_1);
+	spin_unlock_irqrestore(&bus->lock, flags);
+}
 
-		if (mode == SMB_MASTER) {
-			k1 = round_up((__KERNEL_DIV_ROUND_UP(src_clk_freq * 620,
-							     1000000)), 2);
-			k2 = round_up((__KERNEL_DIV_ROUND_UP(src_clk_freq * 380,
-							     1000000) + 1), 2);
-			if (k1 < SCLFRQ_MIN || k1 > SCLFRQ_MAX ||
-			    k2 < SCLFRQ_MIN || k2 > SCLFRQ_MAX) {
-				return false;
-			}
-		}
 
-		// Master or Slave with frequency > 40 MHZ
-		if (mode == SMB_MASTER || src_clk_freq > 40000) {
-			// Set HLDT:
-			// SDA hold time:  (HLDT-7) * T(CLK) >= 120
-			// HLDT = 120/T(CLK) + 7 = 120 * FREQ(CLK) + 7
-			hldt = (u8)__KERNEL_DIV_ROUND_UP(src_clk_freq * 120,
-							 1000000) + 7;
+static int NPCM7XX_smb_get_SCL(struct i2c_adapter *_adap)
+{
+	unsigned long flags;
+	unsigned int ret = 0;
+	struct NPCM7XX_i2c *bus = container_of(_adap, struct NPCM7XX_i2c, adap);
 
-		// Slave with frequency 24-40 MHZ
-		} else {
-			hldt = 7;
-			dbnct = 2;
-		}
-	}
 
-	// Frequency larger than 1 MHZ
-	else
-		return false;
+	// Select Bank 0 to access NPCM7XX_SMBCTL4
+	spin_lock_irqsave(&bus->lock, flags);
+	NPCM7XX_smb_select_bank(bus, SMB_BANK_0);
 
-	// After clock parameters calculation update the reg
-	iowrite8((ioread8(bus->reg + NPCM_SMBCTL2)
-		& ~SMBCTL2_SCLFRQ6_0) | FIELD_PREP(SMBCTL2_SCLFRQ6_0,
-		sclfrq & 0x7F), bus->reg + NPCM_SMBCTL2);
+	// Get SCL level
+	ret = FIELD_GET(SMBCTL3_SCL_LVL,  ioread8(NPCM7XX_SMBCTL3(bus)));
 
-	iowrite8((ioread8(bus->reg + NPCM_SMBCTL3) & ~SMBCTL3_SCLFRQ8_7) |
-		 FIELD_PREP(SMBCTL3_SCLFRQ8_7, (sclfrq >> 7) & 0x3),
-		 bus->reg + NPCM_SMBCTL3);
+	// Return to Bank 1
+	NPCM7XX_smb_select_bank(bus, SMB_BANK_1);
+	spin_unlock_irqrestore(&bus->lock, flags);
+	return ret;
+}
 
-	iowrite8((ioread8(bus->reg + NPCM_SMBCTL3) & ~SMBCTL3_400K_MODE) |
-		 FIELD_PREP(SMBCTL3_400K_MODE, fast_mode),
-		 bus->reg + NPCM_SMBCTL3);
 
-	// Select Bank 0 to access NPCM_SMBCTL4/NPCM_SMBCTL5
-	npcm_smb_select_bank(bus, SMB_BANK_0);
 
-	if (bus_freq >= SMBUS_FREQ_400KHZ) {
-		// k1 and k2 are relevant for master mode only
-		if (mode == SMB_MASTER) {
-			// Set SCL Low/High Time:
-			// k1 = 2 * SCLLT7-0 -> Low Time  = k1 / 2
-			// k2 = 2 * SCLLT7-0 -> High Time = k2 / 2
-			iowrite8((u8)k1 / 2, bus->reg + NPCM_SMBSCLLT);
-			iowrite8((u8)k2 / 2, bus->reg + NPCM_SMBSCLHT);
-		} else { // DBNCT is relevant for slave mode only
-			iowrite8((ioread8(bus->reg + NPCM_SMBCTL5) &
-				 ~SMBCTL5_DBNCT) |
-				 FIELD_PREP(SMBCTL5_DBNCT, dbnct),
-				 bus->reg + NPCM_SMBCTL5);
-		}
-	}
+static int NPCM7XX_smb_get_SDA(struct i2c_adapter *_adap)
+{
+	unsigned long flags;
+	unsigned int ret = 0;
+	struct NPCM7XX_i2c *bus = container_of(_adap, struct NPCM7XX_i2c, adap);
 
-	iowrite8((ioread8(bus->reg + NPCM_SMBCTL4) & ~SMBCTL4_HLDT)
-		 | FIELD_PREP(SMBCTL4_HLDT, hldt), bus->reg + NPCM_SMBCTL4);
+	// Select Bank 0 to access NPCM7XX_SMBCTL4
+	spin_lock_irqsave(&bus->lock, flags);
+	NPCM7XX_smb_select_bank(bus, SMB_BANK_0);
 
-	// Return to Bank 1, and stay there by default:
-	npcm_smb_select_bank(bus, SMB_BANK_1);
+	// Get SDA level
+	ret = FIELD_GET(SMBCTL3_SDA_LVL,  ioread8(NPCM7XX_SMBCTL3(bus)));
 
-	dev_dbg(bus->dev, "k1 = %d k2 = %d dbnct = %d sclfrq = %d hldt = %d src_clk_freq %d fast_mode %d\n",
-		k1, k2, dbnct, sclfrq, hldt, src_clk_freq, fast_mode);
+	// Return to Bank 1
+	NPCM7XX_smb_select_bank(bus, SMB_BANK_1);
+	spin_unlock_irqrestore(&bus->lock, flags);
+	return ret;
 
-	return true;
 }
 
-static bool npcm_smb_init_module(struct npcm_i2c *bus, enum smb_mode mode,
-				 u32 bus_freq)
-{
-	// Check whether module already enabled or frequency is out of bounds
-	if ((bus->state != SMB_DISABLE && bus->state != SMB_IDLE) ||
-	    bus_freq < SMBUS_FREQ_MIN || bus_freq > SMBUS_FREQ_MAX)
-		return false;
-	// Configure FIFO disabled mode so slave will not use fifo
-	// (maste will set it on if supported)
-	bus->threshold_fifo = SMBUS_FIFO_SIZE;
-	iowrite8(ioread8(bus->reg + NPCM_SMBFIF_CTL) & ~NPCM_SMBFIF_CTL_FIFO_EN,
-		 bus->reg + NPCM_SMBFIF_CTL);
-
-	bus->fifo_use = false;
 
-	// Configure SMB module clock frequency
-	if (!npcm_smb_init_clk(bus, mode, bus_freq)) {
-		pr_err("npcm_smb_init_clk failed\n");
-		return false;
-	}
-	npcm_smb_disable(bus);
+//@@: A temporary global buffer for slave device data storage.
+u8  read_data_buf[PAGE_SIZE];
+static void NPCM7XX_smb_callback(struct NPCM7XX_i2c *bus, SMB_STATE_IND_T op_status, u16 info)
+{
+	struct i2c_msg *msgs = bus->msgs;
+	int msgs_num = bus->msgs_num;
 
-	// Enable module (before configuring CTL1)
-	npcm_smb_enable(bus);
-	bus->state = SMB_IDLE;
+	if (op_status != 6)
+		I2C_DEBUG2("\t\t=>\tend bus%d status %d info %d\n", bus->num, op_status, info);
+	switch (op_status) {
+#if IS_ENABLED(CONFIG_I2C_SLAVE)
+			//extern u8  read_data_buf[PAGE_SIZE];
+			//extern u16 rd_size;
+			//extern u8  write_data_buf[32];
+			//extern u16 wr_size;
+		case SMB_SLAVE_RCV_IND:
+			// Slave got an address match with direction bit clear so it
+			//	should receive datathe int must call
+			//      NPCM7XX_smb_slave_start_receive()
+			//      info: the enum SMB_ADDR_T address match
+			//@@: bus->rd_size is SMB_QUICK_PROT when nwrite and nread are both 0.
+		    if(bus->slave)
+		    {
+			    i2c_slave_event(bus->slave, I2C_SLAVE_WRITE_REQUESTED, NULL);
+		    }
+		    //printk("bus->rd_size: %02x\r\n", bus->rd_size);
+		    if( (0 == bus->rd_size) || (SMB_QUICK_PROT == bus->rd_size) )
+		    {
+				bus->rd_size = 32;
+				//printk("Set slave receive buffer\r\n");
+			}
+			NPCM7XX_smb_slave_start_receive(bus, bus->rd_size,
+							read_data_buf);
+			break;
+		case SMB_SLAVE_XMIT_IND:
+			// Slave got an address match with direction bit set so it
+			//      should transmit data
+			//	the int must call NPCM7XX_smb_slave_start_xmit()
+			// info: the enum SMB_ADDR_T address match
+			NPCM7XX_smb_slave_start_xmit(bus, bus->wr_size,
+						bus->write_data_buf);
+			break;
+		case SMB_SLAVE_DONE_IND:
+			// Slave done transmitting or receiving
+			// info:
+			//	on receive: number of actual bytes received
+			//	on transmit: number of actual bytes transmitted,
+			//	when PEC is used 'info' should be (nwrite+1) which means
+			//		 that 'nwrite' bytes were sent + the PEC byte
+			//		'nwrite' is the second parameter
+			//               NPCM7XX_smb_slave_start_xmit()
+			break;
+#endif // CONFIG_I2C_SLAVE
+		case SMB_MASTER_DONE_IND:
+		// Master transaction finished and all transmit bytes were sent
+		// info: number of bytes actually received after the Master
+		//	receive operation (if Master didn't issue receive it
+		//      should be 0)
+		// Notify that not all data was received on Master or Slave
+		// info:
+		//	on receive: number of actual bytes received
+		//	when PEC is used even if 'info' is the expected number
+		//	of bytes, it means that PEC error occured.
+		{
+			if (msgs[0].flags & I2C_M_RD)
+				msgs[0].len = info;
+			else if (msgs_num == 2 && msgs[1].flags & I2C_M_RD)
+				msgs[1].len = info;
+
+			bus->cmd_err = 0;
+			complete(&bus->cmd_complete);
+		}
+		break;
 
-	// Enable SMB int and New Address Match int source
-	iowrite8((ioread8(bus->reg + NPCM_SMBCTL1) | NPCM_SMBCTL1_NMINTE) &
-		 ~NPCM_SMBCTL1_RWS_FIELDS,
-		 bus->reg + NPCM_SMBCTL1);
+		case SMB_NO_DATA_IND:
+		// Notify that not all data was received on Master or Slave
+		// info:
+		//on receive: number of actual bytes received
+		//	when PEC is used even if 'info' is the expected number
+		//      of bytes,it means that PEC error occured.
+		{
+			if (msgs[0].flags & I2C_M_RD)
+			    msgs[0].len = info;
+			else if (msgs_num == 2 && msgs[1].flags & I2C_M_RD)
+			    msgs[1].len = info;
+
+			bus->cmd_err = -EFAULT;
+			I2C_DEBUG("I2C%d no data ind: SA=0x%x wr=%d / %d, rd=%d / %d, state "
+			       "%d, op=%d, ind=%d, int_cnt=%d, log=0x%x\n",
+			       bus->num, bus->dest_addr,
+			       bus->wr_ind, bus->wr_size, bus->rd_ind, bus->rd_size, bus->state,
+			       bus->operation, bus->stop_ind,
+			       bus->int_cnt, bus->event_log);
+			complete(&bus->cmd_complete);
+		}
+		break;
+		case SMB_NACK_IND:
+			// MASTER transmit got a NAK before transmitting all bytes
+			// info: number of transmitted bytes
+			bus->cmd_err = -EAGAIN;
+			complete(&bus->cmd_complete);
 
-	npcm_smb_int_enable(bus, true);
-	return true;
+			break;
+		case SMB_BUS_ERR_IND:
+			// Bus error occured
+			// info: has no meaning
+			bus->cmd_err = -EIO;
+			I2C_DEBUG("I2C%d BER: SA=0x%x wr=%d / %d, rd=%d / %d, state "
+			       "%d, op=%d, ind=%d, int_cnt=%d, log=0x%x\n",
+			       bus->num, bus->dest_addr,
+			       bus->wr_ind, bus->wr_size, bus->rd_ind, bus->rd_size, bus->state,
+			       bus->operation, bus->stop_ind,
+			       bus->int_cnt, bus->event_log);
+
+			I2C_DEBUG("\t\t=>\tBER:  bus%d status %d info %d\n", bus->num, op_status, info);
+			I2C_DEBUG("\t\t=>\tBER bus%d addr 0x%x, fifo %d, block %d\n",
+				  bus->num, bus->dest_addr, bus->fifo_use, bus->read_block_use);
+			complete(&bus->cmd_complete);
+			break;
+		case SMB_WAKE_UP_IND:
+			// SMBus wake up occured
+			// info: has no meaning
+			break;
+		default:
+			break;
+	}
 }
 
-static int __npcm_i2c_init(struct npcm_i2c *bus, struct platform_device *pdev)
+
+static int __NPCM7XX_i2c_init(struct NPCM7XX_i2c *bus,
+struct platform_device *pdev)
 {
 	u32 clk_freq;
 	int ret;
@@ -1650,6 +3269,8 @@ static int __npcm_i2c_init(struct npcm_i2c *bus, struct platform_device *pdev)
 	// Initialize the internal data structures
 	bus->state = SMB_DISABLE;
 	bus->master_or_slave = SMB_SLAVE;
+	//printk("line:%d slave on bus%d\n", __LINE__, bus->num);
+
 
 	ret = of_property_read_u32(pdev->dev.of_node,
 				   "bus-frequency", &clk_freq);
@@ -1658,126 +3279,76 @@ static int __npcm_i2c_init(struct npcm_i2c *bus, struct platform_device *pdev)
 			"Could not read bus-frequency property\n");
 		clk_freq = 100000;
 	}
-	ret = npcm_smb_init_module(bus, SMB_MASTER, clk_freq / 1000);
-	if (!ret) {
+	I2C_DEBUG2("clk_freq = %d\n", clk_freq);
+	ret = NPCM7XX_smb_init_module(bus, SMB_MASTER, clk_freq / 1000);
+	if (ret == false) {
 		dev_err(&pdev->dev,
-			"npcm_smb_init_module() failed\n");
+			"NPCM7XX_smb_init_module() failed\n");
 		return -1;
 	}
+#if defined (SMB_CAPABILITY_TIMEOUT_SUPPORT)
+	NPCM7XX_smb_enable_timeout(bus, true);
+#endif //SMB_CAPABILITY_TIMEOUT_SUPPORT
+
+#if IS_ENABLED(CONFIG_I2C_SLAVE)
+	// If slave has already been reged, re-enable it.
+	if (bus->slave)
+		NPCM7XX_i2c_reg_slave(bus->slave);
+#endif // CONFIG_I2C_SLAVE
 
-	crc8_populate_lsb(npcm7xx_crc8, 0x07);
-	crc8_populate_msb(npcm7xx_crc8, 0x07);
 	return 0;
 }
 
-static irqreturn_t npcm_i2c_bus_irq(int irq, void *dev_id)
+
+static irqreturn_t NPCM7XX_i2c_bus_irq(int irq, void *dev_id)
 {
-	struct npcm_i2c *bus = dev_id;
+	struct NPCM7XX_i2c *bus = dev_id;
 
 	bus->int_cnt++;
-	_npcm7xx_get_time_stamp(&bus->int_time_stamp[0],
-				&bus->int_time_stamp[1]);
+
+#ifdef SMB_SW_BYPASS_HW_ISSUE_SMB_STOP
+	_npcm7xx_get_time_stamp(bus->int_time_stamp);
+#endif
+    //printk("line:%d on bus%d\n", __LINE__, bus->num);
 	if (bus->master_or_slave == SMB_MASTER)	{
-		npcm_smb_int_master_handler(bus);
+		//printk("master int on bus%d\n", bus->num);
+		NPCM7XX_smb_int_master_handler(bus);
 		return IRQ_HANDLED;
 	}
 
-	dev_err(bus->dev, "int unknown on bus%d\n", bus->num);
-	return IRQ_NONE;
-}
-
-static bool npcm_smb_master_start_xmit(struct npcm_i2c *bus,
-				       u8 slave_addr, u16 nwrite, u16 nread,
-				       u8 *write_data, u8 *read_data,
-				       bool use_PEC)
-{
-	//
-	// Allow only if bus is not busy
-	//
-	if (bus->state != SMB_IDLE) {
-		dev_info(bus->dev, "\tbus%d->state != SMB_IDLE\n", bus->num);
-		return false;
-	}
-
-	// Configure FIFO mode :
-	if (FIELD_GET(SMB_VER_FIFO_EN, ioread8(bus->reg + SMB_VER))) {
-		bus->fifo_use = true;
-		iowrite8(ioread8(bus->reg + NPCM_SMBFIF_CTL) |
-			 NPCM_SMBFIF_CTL_FIFO_EN, bus->reg + NPCM_SMBFIF_CTL);
-	} else {
-		bus->fifo_use = false;
-	}
-
-	// Update driver state
-	bus->master_or_slave = SMB_MASTER;
-	bus->state = SMB_MASTER_START;
-	if (nwrite > 0)
-		bus->operation = SMB_WRITE_OPER;
-	else
-		bus->operation = SMB_READ_OPER;
-
-	if (npcm_smb_is_quick(bus))
-		bus->operation = SMB_WRITE_OPER; // send the address with W bit.
-
-	bus->dest_addr = (u8)(slave_addr << 1);// Translate 7bit to 8bit format
-	bus->wr_buf = write_data;
-	bus->wr_size = nwrite;
-	bus->wr_ind = 0;
-	bus->rd_buf = read_data;
-	bus->rd_size = nread;
-	bus->rd_ind = 0;
-	bus->PEC_use = use_PEC;
-	bus->retry_count = SMB_RETRY_MAX_COUNT;
-
-	// clear BER just in case it is set due to a previous transaction
-	iowrite8(NPCM_SMBST_BER, bus->reg + NPCM_SMBST);
-
-	// Initiate SMBus master transaction
-	// Generate a Start condition on the SMBus
-	if (bus->fifo_use) {
-		// select bank 1 for FIFO regs
-		npcm_smb_select_bank(bus, SMB_BANK_1);
-
-		// clear FIFO and relevant status bits.
-		iowrite8(ioread8(bus->reg + NPCM_SMBFIF_CTS) |
-			 NPCM_SMBFIF_CTS_SLVRSTR |
-			 NPCM_SMBFIF_CTS_CLR_FIFO |
-			 NPCM_SMBFIF_CTS_RXF_TXE, bus->reg + NPCM_SMBFIF_CTS);
-
-		if (bus->operation == SMB_READ_OPER) {
-			//This is a read only operation. Configure the FIFO
-			//threshold according to the needed # of bytes to read.
-			npcm_smb_set_fifo(bus, nread, -1);
-		} else if (bus->operation == SMB_WRITE_OPER) {
-			npcm_smb_set_fifo(bus, -1, nwrite);
-		}
+#if IS_ENABLED(CONFIG_I2C_SLAVE)
+	else if (!NPCM7XX_smb_int_slave_handler(bus)) {
+		dev_dbg(bus->dev, "irq handled by slave.\n");
+		//printk("line:%d slave on bus%d\n", __LINE__, bus->num);
+		return IRQ_HANDLED;
 	}
+#endif // CONFIG_I2C_SLAVE
+	printk("int unknown on bus%d\n", bus->num);
 
-	bus->int_cnt = 0;
-	bus->event_log = 0;
-	npcm_smb_master_start(bus);
-
-	return true;
+	return IRQ_NONE;
 }
 
-static int npcm_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
-				int num)
+
+static int  NPCM7XX_i2c_master_xfer(struct i2c_adapter *adap,
+					struct i2c_msg *msgs, int num)
 {
-	struct npcm_i2c *bus = adap->algo_data;
+	struct NPCM7XX_i2c *bus = adap->algo_data;
 	struct i2c_msg *msg0, *msg1;
 	unsigned long time_left, flags;
 	u16 nwrite, nread;
 	u8 *write_data, *read_data;
 	u8 slave_addr;
 	int ret = 0;
+	
+	//@@: store the original mode.
+	SMB_MODE_T ori_mode = bus->master_or_slave;
 
 	spin_lock_irqsave(&bus->lock, flags);
-	bus->cmd_err = -EPERM;
+	bus->cmd_err = -EPERM; // restart error to unused value by this driver.
 	bus->int_cnt = 0;
-	bus->stop_ind = SMB_NO_STATUS_IND;
-	bus->read_block_use = false;
 
-	iowrite8(0xFF, bus->reg + NPCM_SMBST);
+	iowrite8(0xFF, NPCM7XX_SMBST(bus));
+	//iowrite8(NPCM7XX_SMBCST_BB, NPCM7XX_SMBCST(bus));
 
 	if (num > 2 || num < 1) {
 		pr_err("I2C command not supported, num of msgs = %d\n", num);
@@ -1789,22 +3360,22 @@ static int npcm_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 	slave_addr = msg0->addr;
 	if (msg0->flags & I2C_M_RD) { // read
 		if (num == 2) {
-			pr_err(" num = 2 but first msg is rd instead of wr\n");
+			pr_err(" num = 2 but first msg is read instead of "
+			       "write.\n");
 			spin_unlock_irqrestore(&bus->lock, flags);
 			return -EINVAL;
 		}
 		nwrite = 0;
 		write_data = NULL;
-		if (msg0->flags & I2C_M_RECV_LEN) {
-			nread = 1;
-			bus->read_block_use = true;
-
-		} else {
+		if (msg0->flags & I2C_M_RECV_LEN)
+			nread = SMB_BLOCK_PROT;
+		else
 			nread = msg0->len;
-		}
+
 		read_data = msg0->buf;
 
-	} else { // write
+	}
+	else { // write
 		nwrite = msg0->len;
 		write_data = msg0->buf;
 		nread = 0;
@@ -1812,23 +3383,20 @@ static int npcm_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 		if (num == 2) {
 			msg1 = &msgs[1];
 			if (slave_addr != msg1->addr) {
-				pr_err("SA==%02x but msg1->addr == %02x\n",
-				       slave_addr, msg1->addr);
+				pr_err(" slave_addr == %02x but msg1->addr == "
+				       "%02x\n", slave_addr, msg1->addr);
 				spin_unlock_irqrestore(&bus->lock, flags);
 				return -EINVAL;
 			}
 			if ((msg1->flags & I2C_M_RD) == 0) {
-				pr_err("num = 2 but both msg are write.\n");
+				pr_err(" num = 2 but both msg are write.\n");
 				spin_unlock_irqrestore(&bus->lock, flags);
 				return -EINVAL;
 			}
-			if (msg1->flags & I2C_M_RECV_LEN) {
-				nread = 1;
-				bus->read_block_use = true;
-			} else {
+			if (msg1->flags & I2C_M_RECV_LEN)
+				nread = SMB_BLOCK_PROT;
+			else
 				nread = msg1->len;
-				bus->read_block_use = false;
-			}
 
 			read_data = msg1->buf;
 		}
@@ -1837,29 +3405,97 @@ static int npcm_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 	bus->msgs = msgs;
 	bus->msgs_num = num;
 
-	if (nwrite >= 32 * 1024 ||  nread >= 32 * 1024) {
-		pr_err("i2c%d buffer too big\n", bus->num);
-		return -EINVAL;
-	}
 
 	reinit_completion(&bus->cmd_complete);
 
-	if (npcm_smb_master_start_xmit(bus, slave_addr, nwrite, nread,
-				       write_data, read_data, 0) == false)
+	if (NPCM7XX_smb_master_start_xmit(bus, slave_addr, nwrite, nread, write_data,
+		read_data, 0) == false)
 		ret = -(EBUSY);
 
-	if (ret != -(EBUSY)) {
+	if (ret != -(EBUSY)){
 		time_left = wait_for_completion_timeout(&bus->cmd_complete,
 							bus->adap.timeout);
 
-		if (time_left == 0 && bus->cmd_err == -EPERM) {
-			npcm_smb_master_abort(bus);
+		if (time_left == 0 && bus->cmd_err == -EPERM){
+			printk("I2C%d timeout! timeout = %d, "
+			       "SA=0x%x error %d, nwrite=%d, nread=%d, state "
+			       "%d, op=%d, ind=%d, int_cnt=%d, ret=%d, "
+			       "log=0x%x\n",
+			       bus->num, bus->adap.timeout, slave_addr,
+			       bus->cmd_err,
+			       nwrite, nread, bus->state, bus->operation,
+			       bus->stop_ind, bus->int_cnt, ret,
+			       bus->event_log);
+
+			if (bus->msgs[0].flags & I2C_M_RD)
+				nread = bus->msgs[0].len;
+			else if (bus->msgs_num == 2 && bus->msgs[1].flags & I2C_M_RD)
+				nread = bus->msgs[1].len;
+
+			if (nwrite && nwrite != SMB_QUICK_PROT) {
+				int i;
+				char str[32 * 3 + 4];
+				char *s = str;
+
+				for (i = 0; (i < nwrite && i < 32); i++)
+					s += sprintf(s, "%02x ", write_data[i]);
+
+				printk("write_data  = %s\n", str);
+			}
+
+			if (nread && nread != SMB_QUICK_PROT) {
+				int i;
+				char str[32 * 3 + 4];
+				char *s = str;
+
+				for (i = 0; (i < nread && i < 32); i++)
+					s += sprintf(s, "%02x ", read_data[i]);
+
+				printk("read_data  = %s\n", str);
+			}
+
+			NPCM7XX_smb_master_abort(bus);
 			ret = -ETIMEDOUT;
-		} else {
-			ret = bus->cmd_err;
 		}
+		else
+			ret = bus->cmd_err;
+	}
+	else
+	{
+		I2C_DEBUG("I2C%d busy!"
+			       "SA=0x%x error %d, nwrite=%d, nread=%d, state "
+			       "%d, op=%d, ind=%d, int_cnt=%d, ret=%d, "
+			       "log=0x%x\n",
+			       bus->num, slave_addr,
+			       bus->cmd_err,
+			       nwrite, nread, bus->state, bus->operation,
+			       bus->stop_ind, bus->int_cnt, ret,
+			       bus->event_log);
 	}
 
+	//TaliP:   do this????   if ((nwrite == 0) && (nread == 0))
+	//	NPCM7XX_smb_master_abort(bus);
+
+#ifdef CONFIG_NPCM750_I2C_DEBUG
+	if (bus->msgs[0].flags & I2C_M_RD)
+		nread = bus->msgs[0].len;
+	else if (bus->msgs_num == 2 && bus->msgs[1].flags & I2C_M_RD)
+		nread = bus->msgs[1].len;
+	if (nread && nread != SMB_QUICK_PROT) {
+		int i;
+		char str[32 * 3 + 4];
+		char *s = str;
+
+		for (i = 0; (i < nread && i < 32); i++)
+			s += sprintf(s, "%02x ", read_data[i]);
+
+		I2C_DEBUG2("read_data = %s\n", str);
+	}
+#endif
+    //@@: restore to the original mode.
+    bus->master_or_slave = ori_mode;
+
+
 	bus->msgs = NULL;
 	bus->msgs_num = 0;
 	spin_unlock_irqrestore(&bus->lock, flags);
@@ -1870,27 +3506,87 @@ static int npcm_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 	else
 		return ret;
 }
+//@@: A temporary addon for slave. It should be configured according to the real usage case.
+static u32 NPCM7XX_i2c_functionality(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SLAVE | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_SMBUS_BLOCK_DATA;
+}
+
+#if IS_ENABLED(CONFIG_I2C_SLAVE)
 
-static u32 npcm_i2c_functionality(struct i2c_adapter *adap)
+static int  NPCM7XX_i2c_reg_slave(struct i2c_client *client)
 {
-	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_SMBUS_BLOCK_DATA;
+	struct NPCM7XX_i2c *bus;
+
+	bus = client->adapter->algo_data;
+	I2C_DEBUG("SA=0x%x, PEC=%d\n", client->addr, bus->PEC_use);
+	if (bus->slave) {
+		return -EINVAL;
+	}
+
+	if (0 != NPCM7XX_smb_add_slave_addr(bus, client->addr, bus->PEC_use)) {
+		return -EINVAL;
+	}
+	//@@: For now, I2C4 acts as a slave device.
+	bus->master_or_slave = SMB_SLAVE;
+
+	bus->slave = client;
+
+	return 0;
 }
 
-static const struct i2c_algorithm npcm_i2c_algo = {
-	.master_xfer = npcm_i2c_master_xfer,
-	.functionality = npcm_i2c_functionality,
+static int  NPCM7XX_i2c_unreg_slave(struct i2c_client *client)
+{
+	struct NPCM7XX_i2c *bus = client->adapter->algo_data;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&bus->lock, lock_flags);
+	if (!bus->slave) {
+		spin_unlock_irqrestore(&bus->lock, lock_flags);
+		return -EINVAL;
+	}
+
+
+	// Turn off slave mode.
+	NPCM7XX_smb_remove_slave_addr(bus, client->addr);
+
+	bus->slave = NULL;
+	spin_unlock_irqrestore(&bus->lock, lock_flags);
+
+	return 0;
+}
+#endif // CONFIG_I2C_SLAVE
+
+static const struct i2c_algorithm NPCM7XX_i2c_algo = {
+	.master_xfer = NPCM7XX_i2c_master_xfer,
+	.functionality = NPCM7XX_i2c_functionality,
+#if IS_ENABLED(CONFIG_I2C_SLAVE)
+	.reg_slave	= NPCM7XX_i2c_reg_slave,
+	.unreg_slave	= NPCM7XX_i2c_unreg_slave,
+#endif // CONFIG_I2C_SLAVE
 };
 
-static struct i2c_bus_recovery_info npcm_i2c_recovery = {
-	.recover_bus = npcm_smb_recovery,
-	.get_scl = npcm_smb_get_SCL,
-	.set_scl = npcm_smb_set_SCL,
-	.get_sda = npcm_smb_get_SDA,
+
+static struct i2c_bus_recovery_info NPCM7XX_i2c_recovery = {
+	.recover_bus = NPCM7XX_smb_recovery,
+	.get_scl = NPCM7XX_smb_get_SCL,
+	.set_scl = NPCM7XX_smb_set_SCL,
+	.get_sda = NPCM7XX_smb_get_SDA,
+
+	// NPCM7XX_smb_set_sda?
+
+	//.prepare_recovery = NULL;
+	//.unprepare_recovery = NULL;
+
+	/* gpio recovery */
+	//.scl_gpio =  -1;
+	//.sda_gpio = -1; // no need for gpio number since no muxing is required.
 };
 
-static int  npcm_i2c_probe_bus(struct platform_device *pdev)
+
+static int  NPCM7XX_i2c_probe_bus(struct platform_device *pdev)
 {
-	struct npcm_i2c *bus;
+	struct NPCM7XX_i2c *bus;
 	struct resource *res;
 	struct clk *i2c_clk;
 	int ret;
@@ -1903,36 +3599,51 @@ static int  npcm_i2c_probe_bus(struct platform_device *pdev)
 #ifdef CONFIG_OF
 	num = of_alias_get_id(pdev->dev.of_node, "i2c");
 	bus->num = num;
+
+
+
 	i2c_clk = devm_clk_get(&pdev->dev, NULL);
+
 	if (IS_ERR(i2c_clk)) {
 		pr_err(" I2C probe failed: can't read clk.\n");
-		return	-EPROBE_DEFER;
+		return  -EPROBE_DEFER; // this error will cause the probing to run again after clk is ready.
 	}
+
 	bus->apb_clk = clk_get_rate(i2c_clk);
-	dev_dbg(bus->dev, "I2C APB clock is %d\n", bus->apb_clk);
+	I2C_DEBUG2("I2C APB clock is %d\n", bus->apb_clk);
 #endif //  CONFIG_OF
 
-	gcr_regmap = syscon_regmap_lookup_by_compatible("nuvoton,npcm750-gcr");
-	if (IS_ERR(gcr_regmap)) {
-		pr_err("%s: failed to find nuvoton,npcm750-gcr\n", __func__);
-		return IS_ERR(gcr_regmap);
+
+	if (gcr_regmap == NULL) {
+		gcr_regmap = syscon_regmap_lookup_by_compatible("nuvoton,npcm750-gcr");
+		if (IS_ERR(gcr_regmap)) {
+			pr_err("%s: failed to find nuvoton,"
+			       "npcm750-gcr\n", __func__);
+			return IS_ERR(gcr_regmap);
+		}
+		regmap_write(gcr_regmap, I2CSEGCTL_OFFSET, I2CSEGCTL_VAL);
+		printk("I2C%d: gcr mapped\n", bus->num);
 	}
-	regmap_write(gcr_regmap, NPCM_I2CSEGCTL, I2CSEGCTL_VAL);
-	dev_dbg(bus->dev, "I2C%d: gcr mapped\n", bus->num);
 
-	clk_regmap = syscon_regmap_lookup_by_compatible("nuvoton,npcm750-clk");
-	if (IS_ERR(clk_regmap)) {
-		pr_err("%s: failed to find nuvoton,npcm750-clk\n", __func__);
-		return IS_ERR(clk_regmap);
+	if (clk_regmap == NULL) {
+		clk_regmap = syscon_regmap_lookup_by_compatible(
+			"nuvoton,npcm750-clk");
+		if (IS_ERR(clk_regmap)) {
+			pr_err("%s: failed to find nuvoton,"
+			       "npcm750-clk\n", __func__);
+			return IS_ERR(clk_regmap);
+		}
+		printk("I2C%d: clk mapped\n", bus->num);
 	}
-	dev_dbg(bus->dev, "I2C%d: clk mapped\n", bus->num);
+
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	dev_dbg(bus->dev, "resource: %pR\n", res);
-	bus->reg = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR((bus)->reg))
-		return PTR_ERR((bus)->reg);
-	dev_dbg(bus->dev, "base = %p\n", bus->reg);
+	I2C_DEBUG2("resource: %pR\n", res);
+	bus->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(bus->base))
+		return PTR_ERR(bus->base);
+
+	I2C_DEBUG2("base = %p\n", bus->base);
 
 	// Initialize the I2C adapter
 	spin_lock_init(&bus->lock);
@@ -1941,17 +3652,17 @@ static int  npcm_i2c_probe_bus(struct platform_device *pdev)
 	bus->adap.class = I2C_CLASS_HWMON | I2C_CLASS_SPD;
 	bus->adap.retries = 0;
 	bus->adap.timeout = 500 * HZ / 1000;
-	bus->adap.algo = &npcm_i2c_algo;
+	bus->adap.algo = &NPCM7XX_i2c_algo;
 	bus->adap.algo_data = bus;
 	bus->adap.dev.parent = &pdev->dev;
 	bus->adap.dev.of_node = pdev->dev.of_node;
-	bus->adap.bus_recovery_info = &npcm_i2c_recovery;
+	bus->adap.bus_recovery_info = &NPCM7XX_i2c_recovery;
 
 	snprintf(bus->adap.name, sizeof(bus->adap.name), "Nuvoton i2c");
 
 	bus->dev = &pdev->dev;
 
-	ret = __npcm_i2c_init(bus, pdev);
+	ret = __NPCM7XX_i2c_init(bus, pdev);
 	if (ret < 0)
 		return ret;
 
@@ -1960,58 +3671,66 @@ static int  npcm_i2c_probe_bus(struct platform_device *pdev)
 		pr_err("I2C platform_get_irq error.");
 		return -ENODEV;
 	}
-	dev_dbg(bus->dev, "irq = %d\n", bus->irq);
+	//bus->irq = irq_of_parse_and_map(pdev->dev.of_node, 0);
+	I2C_DEBUG2("irq = %d\n", bus->irq);
 
-	ret = request_irq(bus->irq, npcm_i2c_bus_irq, 0,
+	ret = request_irq(bus->irq, NPCM7XX_i2c_bus_irq, 0,
 			  dev_name(&pdev->dev), (void *)bus);
-	if (ret) {
-		dev_err(&pdev->dev, "I2C%d: request_irq fail\n", bus->num);
+	if (ret){
+		dev_err(&pdev->dev, "I2C%d: request_irq failed\n", bus->num);
 		return ret;
 	}
 
 	ret = i2c_add_adapter(&bus->adap);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "I2C%d: i2c_add_adapter fail\n", bus->num);
+	if (ret < 0){
+		dev_err(&pdev->dev, "I2C%d: i2c_add_adapter failed\n", bus->num);
 		return ret;
 	}
 
 	platform_set_drvdata(pdev, bus);
-	pr_info("i2c bus %d registered\n", bus->adap.nr);
+
+	printk("i2c bus %d registered, irq %d\n",
+		  bus->adap.nr, bus->irq);
 
 	return 0;
 }
 
-static int  npcm_i2c_remove_bus(struct platform_device *pdev)
+static int  NPCM7XX_i2c_remove_bus(struct platform_device *pdev)
 {
+	struct NPCM7XX_i2c *bus = platform_get_drvdata(pdev);
 	unsigned long lock_flags;
-	struct npcm_i2c *bus = platform_get_drvdata(pdev);
 
 	spin_lock_irqsave(&bus->lock, lock_flags);
-	npcm_smb_disable(bus);
+
+	// Disable everything.
+	NPCM7XX_smb_disable(bus);
+
 	spin_unlock_irqrestore(&bus->lock, lock_flags);
+
 	i2c_del_adapter(&bus->adap);
 
 	return 0;
 }
 
-static const struct of_device_id npcm_i2c_bus_of_table[] = {
+static const struct of_device_id NPCM7XX_i2c_bus_of_table[] = {
 	{ .compatible = "nuvoton,npcm750-i2c", },
 	{},
 };
-MODULE_DEVICE_TABLE(of, npcm_i2c_bus_of_table);
+MODULE_DEVICE_TABLE(of, NPCM7XX_i2c_bus_of_table);
 
-static struct platform_driver npcm_i2c_bus_driver = {
-	.probe = npcm_i2c_probe_bus,
-	.remove = npcm_i2c_remove_bus,
+static struct platform_driver NPCM7XX_i2c_bus_driver = {
+	.probe = NPCM7XX_i2c_probe_bus,
+	.remove = NPCM7XX_i2c_remove_bus,
 	.driver = {
 		.name = "nuvoton-i2c-bus",
-		.of_match_table = npcm_i2c_bus_of_table,
-	}
+		.of_match_table = NPCM7XX_i2c_bus_of_table,
+	},
 };
-module_platform_driver(npcm_i2c_bus_driver);
+module_platform_driver(NPCM7XX_i2c_bus_driver);
 
-MODULE_AUTHOR("Avi Fishman <avi.fishman@gmail.com>");
-MODULE_AUTHOR("Tali Perry <tali.perry@nuvoton.com>");
+MODULE_AUTHOR("Avi Fishman <avi.fishman@gmail.com>, Tali Perry <tali.perry@nuvoton.com>");
 MODULE_DESCRIPTION("Nuvoton I2C Bus Driver");
 MODULE_LICENSE("GPL v2");
 MODULE_VERSION(I2C_VERSION);
+
+
diff --git a/drivers/i2c/i2c-slave-mqueue.c b/drivers/i2c/i2c-slave-mqueue.c
new file mode 100644
index 0000000..0b61535
--- /dev/null
+++ b/drivers/i2c/i2c-slave-mqueue.c
@@ -0,0 +1,215 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2017 - 2018, Intel Corporation.
+
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/sysfs.h>
+
+#define MQ_MSGBUF_SIZE		CONFIG_I2C_SLAVE_MQUEUE_MESSAGE_SIZE
+#define MQ_QUEUE_SIZE		CONFIG_I2C_SLAVE_MQUEUE_QUEUE_SIZE
+#define MQ_QUEUE_NEXT(x)	(((x) + 1) & (MQ_QUEUE_SIZE - 1))
+
+struct mq_msg {
+	int	len;
+	u8	*buf;
+};
+
+struct mq_queue {
+	struct bin_attribute	bin;
+	struct kernfs_node	*kn;
+
+	spinlock_t		lock; /* spinlock for queue index handling */
+	int			in;
+	int			out;
+
+	struct mq_msg		*curr;
+	int			truncated; /* drop current if truncated */
+	struct mq_msg		queue[MQ_QUEUE_SIZE];
+};
+
+static int i2c_slave_mqueue_callback(struct i2c_client *client,
+				     enum i2c_slave_event event, u8 *val)
+{
+	struct mq_queue *mq = i2c_get_clientdata(client);
+	struct mq_msg *msg = mq->curr;
+	int ret = 0;
+
+	switch (event) {
+	case I2C_SLAVE_WRITE_REQUESTED:
+		mq->truncated = 0;
+
+		msg->len = 1;
+		//msg->buf[0] = client->addr << 1;
+		msg->buf[0] = client->addr;
+		break;
+
+	case I2C_SLAVE_WRITE_RECEIVED:
+		if (msg->len < MQ_MSGBUF_SIZE) {
+			//printk("val: 0x%x\r\n", *val);
+			msg->buf[msg->len++] = *val;
+		} else {
+			dev_err(&client->dev, "message is truncated!\n");
+			mq->truncated = 1;
+			ret = -EINVAL;
+		}
+		break;
+
+	case I2C_SLAVE_STOP:
+		if (unlikely(mq->truncated || msg->len < 2))
+			break;
+
+		spin_lock(&mq->lock);
+		mq->in = MQ_QUEUE_NEXT(mq->in);
+		mq->curr = &mq->queue[mq->in];
+		mq->curr->len = 0;
+
+		/* Flush the oldest message */
+		if (mq->out == mq->in)
+			mq->out = MQ_QUEUE_NEXT(mq->out);
+		spin_unlock(&mq->lock);
+
+		kernfs_notify(mq->kn);
+		break;
+
+	default:
+		*val = 0xFF;
+		break;
+	}
+
+	return ret;
+}
+
+static ssize_t i2c_slave_mqueue_bin_read(struct file *filp,
+					 struct kobject *kobj,
+					 struct bin_attribute *attr,
+					 char *buf, loff_t pos, size_t count)
+{
+	struct mq_queue *mq;
+	struct mq_msg *msg;
+	unsigned long flags;
+	bool more = false;
+	ssize_t ret = 0;
+
+	mq = dev_get_drvdata(container_of(kobj, struct device, kobj));
+
+	spin_lock_irqsave(&mq->lock, flags);
+	if (mq->out != mq->in) {
+		msg = &mq->queue[mq->out];
+
+		if (msg->len <= count) {
+			ret = msg->len;
+			memcpy(buf, msg->buf, ret);
+		} else {
+			ret = -EOVERFLOW; /* Drop this HUGE one. */
+		}
+
+		mq->out = MQ_QUEUE_NEXT(mq->out);
+		if (mq->out != mq->in)
+			more = true;
+	}
+	spin_unlock_irqrestore(&mq->lock, flags);
+
+	if (more)
+		kernfs_notify(mq->kn);
+
+	return ret;
+}
+
+static int i2c_slave_mqueue_probe(struct i2c_client *client,
+				  const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	struct mq_queue *mq;
+	int ret, i;
+	void *buf;
+
+	mq = devm_kzalloc(dev, sizeof(*mq), GFP_KERNEL);
+	if (!mq)
+		return -ENOMEM;
+
+	BUILD_BUG_ON(!is_power_of_2(MQ_QUEUE_SIZE));
+
+	buf = devm_kmalloc_array(dev, MQ_QUEUE_SIZE, MQ_MSGBUF_SIZE,
+				 GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	for (i = 0; i < MQ_QUEUE_SIZE; i++)
+		mq->queue[i].buf = buf + i * MQ_MSGBUF_SIZE;
+
+	i2c_set_clientdata(client, mq);
+
+	spin_lock_init(&mq->lock);
+	mq->curr = &mq->queue[0];
+
+	sysfs_bin_attr_init(&mq->bin);
+	mq->bin.attr.name = "slave-mqueue";
+	mq->bin.attr.mode = 0400;
+	mq->bin.read = i2c_slave_mqueue_bin_read;
+	mq->bin.size = MQ_MSGBUF_SIZE * MQ_QUEUE_SIZE;
+
+	ret = sysfs_create_bin_file(&dev->kobj, &mq->bin);
+	if (ret)
+		return ret;
+
+	mq->kn = kernfs_find_and_get(dev->kobj.sd, mq->bin.attr.name);
+	if (!mq->kn) {
+		sysfs_remove_bin_file(&dev->kobj, &mq->bin);
+		return -EFAULT;
+	}
+
+	ret = i2c_slave_register(client, i2c_slave_mqueue_callback);
+	if (ret) {
+		kernfs_put(mq->kn);
+		sysfs_remove_bin_file(&dev->kobj, &mq->bin);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int i2c_slave_mqueue_remove(struct i2c_client *client)
+{
+	struct mq_queue *mq = i2c_get_clientdata(client);
+
+	i2c_slave_unregister(client);
+
+	kernfs_put(mq->kn);
+	sysfs_remove_bin_file(&client->dev.kobj, &mq->bin);
+
+	return 0;
+}
+
+static const struct i2c_device_id i2c_slave_mqueue_id[] = {
+	{ "slave-mqueue", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, i2c_slave_mqueue_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id nuvoton_i2c_slave_of_table[] = {
+	{ .compatible = "slave-mqueue" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, nuvoton_i2c_slave_of_table);
+#endif
+
+static struct i2c_driver i2c_slave_mqueue_driver = {
+	.driver = {
+		.name	= "i2c-slave-mqueue",
+		.of_match_table	= of_match_ptr(nuvoton_i2c_slave_of_table),
+	},
+	.probe		= i2c_slave_mqueue_probe,
+	.remove		= i2c_slave_mqueue_remove,
+	.id_table	= i2c_slave_mqueue_id,
+};
+module_i2c_driver(i2c_slave_mqueue_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Haiyue Wang <haiyue.wang@linux.intel.com>");
+MODULE_DESCRIPTION("I2C slave mode for receiving and queuing messages");
+
-- 
2.7.4

