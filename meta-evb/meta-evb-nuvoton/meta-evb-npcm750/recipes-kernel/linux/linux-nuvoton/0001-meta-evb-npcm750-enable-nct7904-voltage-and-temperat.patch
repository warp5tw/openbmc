From 82488a25c8b3e8a6f4e3339237d1c6dacc8ad23a Mon Sep 17 00:00:00 2001
From: kfting <kfting@nuvoton.com>
Date: Wed, 30 Jan 2019 15:46:18 +0800
Subject: [PATCH] meta-evb-npcm750: enable nct7904 voltage and temperature
 sensor from configurations in the dts file.

1. Use nuvoton-nct7904.dtsi to configure the voltage and temperature sensors.

Signed-off-by: kfting <kfting@nuvoton.com>
---
 arch/arm/boot/dts/nuvoton-nct7904.dtsi    |   67 +
 arch/arm/boot/dts/nuvoton-npcm750-evb.dts |    4 +
 arch/arm/boot/dts/nuvoton-npcm750.dtsi    |    1 +
 drivers/hwmon/nct7904.c                   | 2125 +++++++++++++++++++++++------
 4 files changed, 1749 insertions(+), 448 deletions(-)
 create mode 100644 arch/arm/boot/dts/nuvoton-nct7904.dtsi

diff --git a/arch/arm/boot/dts/nuvoton-nct7904.dtsi b/arch/arm/boot/dts/nuvoton-nct7904.dtsi
new file mode 100644
index 0000000..b93f8c7
--- /dev/null
+++ b/arch/arm/boot/dts/nuvoton-nct7904.dtsi
@@ -0,0 +1,67 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2018 Nuvoton Technology tomer.maimon@nuvoton.com
+// Copyright 2018 Google, Inc.
+
+&i2c3 {
+	   hwm0: nct7904@2d {
+			compatible = "nct7904";
+			reg = <0x2d>;
+			status = "disabled";
+
+			#address-cells = <1>;
+		    #size-cells = <0>;
+
+            //Refer to nct7904 datasheet about vt_adc_ctrl0-2
+		    vt_adc_ctrl0 = /bits/ 8 <0xff>;
+		    vt_adc_ctrl1 = /bits/ 8 <0x7f>;
+		    vt_adc_ctrl2 = /bits/ 8 <0x3>;
+
+            //reg:  the corresponding register bit
+			//mode: Voltage Temperature Mode Control setting from nct7904 datasheet
+			//00BIN = Voltage monitoring
+			//01BIN = Temperature monitoring (thermal diode current mode)
+			//11BIN = Temperature monitoring (thermistor)
+
+		    //VSEN2-5 can be a voltage, thermal diode or thermistor sensor.
+		    //The configuration is exclusive.
+		    //The description below is to configure VEN2-3 as a thermal diode sensor.
+		    vsen2: vsen@1 {
+		        compatible = "nct7904,vsen2";
+			    reg = <0x1>;
+			    mode = /bits/ 8 <0x1>;
+		    };
+
+            //The sample description below is to configure VEN2-3 as a thermistor sensor.
+		    //vsen2: vsen@1 {
+		    //    compatible = "nct7904,vsen2";
+			//    reg = <0x1>;
+			//    mode = /bits/ 8 <0x3>;
+		    //};
+
+            //The description below is to configure VEN4-5 as a thermistor sensor.
+		    vsen4: vsen@3 {
+		        compatible = "nct7904,vsen4";
+			    reg = <0x3>;
+			    mode = /bits/ 8 <0x1>;
+		    };
+
+		    //VSEN6-9 can be a voltage, or thermistor sensor.
+		    //The description below is to configure VEN6 as a thermistor sensor.
+		    vsens6: vsen@5 {
+		        compatible = "nct7904,vsen6";
+		        reg = <0x5>;
+		        mode = /bits/ 8 <0x3>;
+		    };
+
+		    //The description below is to configure VEN8 as a thermistor sensor.
+		    vsens8: vsen@7 {
+		        compatible = "nct7904,vsen8";
+		        reg = <0x7>;
+		        mode = /bits/ 8 <0x3>;
+		    };
+
+
+	   };
+};
+
+
diff --git a/arch/arm/boot/dts/nuvoton-npcm750-evb.dts b/arch/arm/boot/dts/nuvoton-npcm750-evb.dts
index 1316d6a..192bf1c 100644
--- a/arch/arm/boot/dts/nuvoton-npcm750-evb.dts
+++ b/arch/arm/boot/dts/nuvoton-npcm750-evb.dts
@@ -336,6 +336,10 @@
 				#size-cells = <0>;
 				bus-frequency = <100000>;
 				status = "okay";
+
+				hwm0: nct7904@2d {
+                    status = "okay";
+				};
 			};
 
 			i2c4: i2c-bus@84000 {
diff --git a/arch/arm/boot/dts/nuvoton-npcm750.dtsi b/arch/arm/boot/dts/nuvoton-npcm750.dtsi
index 421a4ed..c4e3ec0 100644
--- a/arch/arm/boot/dts/nuvoton-npcm750.dtsi
+++ b/arch/arm/boot/dts/nuvoton-npcm750.dtsi
@@ -4,6 +4,7 @@
 
 #include "nuvoton-common-npcm7xx.dtsi"
 #include "nuvoton-npcm750-gpio.dtsi"
+#include "nuvoton-nct7904.dtsi"
 
 / {
 	#address-cells = <1>;
diff --git a/drivers/hwmon/nct7904.c b/drivers/hwmon/nct7904.c
index 95a68ab..7457cdc 100644
--- a/drivers/hwmon/nct7904.c
+++ b/drivers/hwmon/nct7904.c
@@ -1,580 +1,1809 @@
 /*
- * nct7904.c - driver for Nuvoton NCT7904D.
- *
- * Copyright (c) 2015 Kontron
- * Author: Vadim V. Vlasov <vvlasov@dev.rtsoft.ru>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
+    nct7904.c - Linux kernel driver for hardware monitoring
+    Copyright (C) 2008 Nuvoton Technology Corp.
+                  Wei Song
+                  2016 Nuvoton Technology Corp.
+				  		Sheng-Yuan Huang
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation - version 2.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301 USA.
+
+
+    Supports following chips:
+
+    Chip       #vin   #fanin #temp #dts wchipid  vendid  i2c  ISA
+    nct7904d    17     12    5     8    0x79     0x50    yes   no
+*/
 
 #include <linux/module.h>
-#include <linux/device.h>
 #include <linux/init.h>
+#include <linux/slab.h>
 #include <linux/i2c.h>
-#include <linux/mutex.h>
 #include <linux/hwmon.h>
+#include <linux/hwmon-vid.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/err.h>
+#include <linux/mutex.h>
+#include <linux/jiffies.h>
+
+//#define DBG_INIT_FUNCTION  //It's old style code, but it is easy for debugging initialize functions. So I keep them for debugging usage.
+
+/* Addresses to scan */
+static unsigned short normal_i2c[] = { 0x2d, 0x2e, I2C_CLIENT_END };
+
+
+/* Insmod parameters */
+static unsigned short force_subclients[4];
+module_param_array(force_subclients, short, NULL, 0);
+MODULE_PARM_DESC(force_subclients, "List of subclient addresses: "
+		       "{bus, clientaddr, subclientaddr1, subclientaddr2}");
+
+
+
+static bool reset;
+module_param(reset, bool, 0);
+MODULE_PARM_DESC(reset, "Set to 1 to reset chip, not recommended");
+
+#define FIX_BANK_PROBLEM	/* Define it to cover bank bug of early nct7904 */
+
+#define NCT7904_REG_BANK_MASK	 0x7
+#define NCT7904_REG_BANKSEL    0xFF
+#define NCT7904_REG_VENDORID   0xD
+#define NCT7904_REG_CHIPID     0xE
+#define NCT7904_REG_DEVICEID   0xF
+#define NCT7904_REG_VENDORID2   0x7A
+#define NCT7904_REG_CHIPID2     0x7B
+#define NCT7904_REG_DEVICEID2   0x7C
+
+#define NCT7904_REG_I2C_ADDR          	0xC
+#define NCT7904_REG_GLOBAL_CONTROL  0x00
+
+
+/* Multi-Function Pin Ctrl Registers */
+#define NCT7904_REG_VOLT_CTRL1   0x20
+#define NCT7904_REG_VOLT_CTRL2   0x21
+#define NCT7904_REG_VOLT_CTRL3   0x22
+
+#define NCT7904_REG_FANIN_CTRL1  0x24
+#define NCT7904_REG_FANIN_CTRL2  0x25
+
+
+#define NCT7904_REG_VOLT_TEMP_CTRL	0x2E
+#define VAL_VOLT_TEMP_CTRL_VOLT_MONITOR	0x0  /* value definition in NCT7904_REG_VOLT_TEMP_CTRL */
+#define VAL_VOLT_TEMP_CTRL_DIODE_CURRENT	0x1
+#define VAL_VOLT_TEMP_CTRL_DIODE_VOLT		0x2
+#define VAL_VOLT_TEMP_CTRL_THERMISTOR		0x3
+/* shift bits of TR1~TR4 in NCT7904_REG_VOLT_TEMP_CTRL */
+static u16 NCT7904_TEMP_CTRL_SHIFT[] = {0,2,4,6};
+
+
 
-#define VENDOR_ID_REG		0x7A	/* Any bank */
-#define NUVOTON_ID		0x50
-#define CHIP_ID_REG		0x7B	/* Any bank */
-#define NCT7904_ID		0xC5
-#define DEVICE_ID_REG		0x7C	/* Any bank */
-
-#define BANK_SEL_REG		0xFF
-#define BANK_0			0x00
-#define BANK_1			0x01
-#define BANK_2			0x02
-#define BANK_3			0x03
-#define BANK_4			0x04
-#define BANK_MAX		0x04
-
-#define FANIN_MAX		12	/* Counted from 1 */
-#define VSEN_MAX		21	/* VSEN1..14, 3VDD, VBAT, V3VSB,
-					   LTD (not a voltage), VSEN17..19 */
-#define FANCTL_MAX		4	/* Counted from 1 */
-#define TCPU_MAX		8	/* Counted from 1 */
-#define TEMP_MAX		4	/* Counted from 1 */
-
-#define VT_ADC_CTRL0_REG	0x20	/* Bank 0 */
-#define VT_ADC_CTRL1_REG	0x21	/* Bank 0 */
-#define VT_ADC_CTRL2_REG	0x22	/* Bank 0 */
-#define FANIN_CTRL0_REG		0x24
-#define FANIN_CTRL1_REG		0x25
-#define DTS_T_CTRL0_REG		0x26
-#define DTS_T_CTRL1_REG		0x27
-#define VT_ADC_MD_REG		0x2E
-
-#define VSEN1_HV_REG		0x40	/* Bank 0; 2 regs (HV/LV) per sensor */
-#define TEMP_CH1_HV_REG		0x42	/* Bank 0; same as VSEN2_HV */
-#define LTD_HV_REG		0x62	/* Bank 0; 2 regs in VSEN range */
-#define FANIN1_HV_REG		0x80	/* Bank 0; 2 regs (HV/LV) per sensor */
-#define T_CPU1_HV_REG		0xA0	/* Bank 0; 2 regs (HV/LV) per sensor */
-
-#define PRTS_REG		0x03	/* Bank 2 */
-#define FANCTL1_FMR_REG		0x00	/* Bank 3; 1 reg per channel */
-#define FANCTL1_OUT_REG		0x10	/* Bank 3; 1 reg per channel */
-
-static const unsigned short normal_i2c[] = {
-	0x2d, 0x2e, I2C_CLIENT_END
+#define TEMP_READ       0
+#define TEMP_CRIT       1
+#define TEMP_CRIT_HYST  2
+#define TEMP_WARN       3
+#define TEMP_WARN_HYST  4
+#define TEMP_LSB_MASK	0x7
+/* only crit and crit_hyst affect real-time alarm status.
+   Feild: current, crit, crit_hyst, warn, warn_hyst 
+   Attention: Current reading has decimal fraction. */
+static u16 NCT7904_REG_TEMP[][5] = {
+	{0x42, 0x104, 0x105, 0x106, 0x107}, // TR1/TD1
+	{0x46, 0x10C, 0x10D, 0x10E, 0x10F}, // TR2/TD2
+	{0x4A, 0x114, 0x115, 0x116, 0x117}, // TR3
+	{0x4E, 0x11C, 0x11D, 0x11E, 0x11F}, // TR4
+	{0x62, 0x144, 0x145, 0x146, 0x147}, // LTD
 };
 
-struct nct7904_data {
-	struct i2c_client *client;
-	struct mutex bank_lock;
-	int bank_sel;
-	u32 fanin_mask;
-	u32 vsen_mask;
-	u32 tcpu_mask;
-	u8 fan_mode[FANCTL_MAX];
+#define NCT7904_REG_TEMP_LSB(index)	(NCT7904_REG_TEMP[index][TEMP_READ] + 1)
+
+#define IN_READ				0
+#define IN_MAX					1
+#define IN_LOW					2
+static const u16 NCT7904_REG_IN[][3] = {
+	/* Current, HL, LL */
+	{0x40, 0x100, 0x102},	/* VSEN1	*/
+	{0x42, 0x104, 0x106},	/* VSEN2	*/
+	{0x44, 0x108, 0x10A},	/* VSEN3	*/
+	{0x46, 0x10C, 0x10E},	/* VSEN4	*/
+	{0x48, 0x110, 0x112},	/* VSEN5	*/
+	{0x4A, 0x114, 0x116},	/* VSEN6	*/
+	{0x4C, 0x118, 0x11A},	/* VSEN7	*/
+	{0x4E, 0x11C, 0x11E},	/* VSEN8	*/
+	{0x50, 0x120, 0x122},	/* VSEN9	*/
+	{0x52, 0x124, 0x126},	/* VSEN10*/
+	{0x54, 0x128, 0x12A},	/* VSEN11*/
+	{0x56, 0x12C, 0x12E},	/* VSEN12*/
+	{0x58, 0x130, 0x132},	/* VSEN13*/
+	{0x5A, 0x134, 0x136},	/* VSEN14*/
+	{0x5C, 0x138, 0x13A},	/* 3VDD	*/
+	{0x5E, 0x13C, 0x13E},	/* VBAT	*/
+	{0x60, 0x140, 0x142},	/* 3VSB	*/
+									/* LTD is a temperature sensor	*/
+};
+
+#define IN_LSB_REG(index)	(NCT7904_REG_IN[index][IN_READ]+1)
+#define IN_HL_LSB_REG(index)	(NCT7904_REG_IN[index][IN_MAX]+1)
+#define IN_LL_LSB_REG(index)	(NCT7904_REG_IN[index][IN_LOW]+1)
+#define IN_LSB_MASK	0x7
+
+u8 IN_MULTIPLIER[] = { 2, 2, 2, 2, 2, 
+			2, 2, 2, 2, 2, 
+			2, 2, 2, 2, 6,
+			6, 6};
+
+
+
+
+#define NCT7904_REG_FAN(index)    (0x80 + (index)*2 )
+#define NCT7904_REG_FAN_LSB(index)    (0x81 + (index)*2 )
+#define NCT7904_REG_FAN_MIN(index)     (0x160 + (index)*2 )
+#define NCT7904_REG_FAN_MIN_LSB(index)    (0x161 + (index)*2 )
+#define NCT7904_FAN_LSB_MASK	0x1F
+
+#define ALARM_REG_NUM        10
+#define NCT7904_REG_ALARM(index)   (0xC1 + (index))
+
+
+
+#define NCT7904_REG_PECI_ENABLE	0x200
+#define NCT7904_REG_TSI_CTRL		0x250
+
+#define NCT7904_REG_DTSC0			0x26
+#define NCT7904_REG_DTSC1			0x27
+/*
+#define W83795_REG_DTSE                0x302
+#define W83795_REG_DTS(index)          (0x26 + (index))
+*/
+#define DTS_READ        0
+#define DTS_CRIT        1
+#define DTS_CRIT_HYST   2
+#define DTS_WARN        3
+#define DTS_WARN_HYST   4
+#define DTS_LSB_MASK		0x7
+static u16 NCT7904_REG_DTS[][5] = {
+	{0xA0, 0x190, 0x191, 0x192, 0x193},
+	{0xA2, 0x194, 0x195, 0x196, 0x197},
+	{0xA4, 0x198, 0x199, 0x19A, 0x19B},
+	{0xA6, 0x19C, 0x19D, 0x19E, 0x19F},
+	{0xA8, 0x1A0, 0x1A1, 0x1A2, 0x1A3},
+	{0xAA, 0x1A4, 0x1A5, 0x1A6, 0x1A7},
+	{0xAC, 0x1A8, 0x1A9, 0x1AA, 0x1AB},
+	{0xAE, 0x1AC, 0x1AD, 0x1AE, 0x1AF},
 };
+#define NCT7904_REG_DTS_LSB(index)	(NCT7904_REG_DTS[index][DTS_READ] + 1)
 
-/* Access functions */
-static int nct7904_bank_lock(struct nct7904_data *data, unsigned bank)
+static inline u16 IN_FROM_REG(u8 index, u16 val)
 {
-	int ret;
+	return (val * IN_MULTIPLIER[index]);
+}
 
-	mutex_lock(&data->bank_lock);
-	if (data->bank_sel == bank)
-		return 0;
-	ret = i2c_smbus_write_byte_data(data->client, BANK_SEL_REG, bank);
-	if (ret == 0)
-		data->bank_sel = bank;
-	else
-		data->bank_sel = -1;
-	return ret;
+static inline u16 IN_TO_REG(u8 index, u16 val)
+{
+	return (val / IN_MULTIPLIER[index]);
 }
 
-static inline void nct7904_bank_release(struct nct7904_data *data)
+static inline unsigned long FAN_FROM_REG(u16 val)
 {
-	mutex_unlock(&data->bank_lock);
+	if ((val >= 0x1fff) || (val == 0))
+		return	0;
+	return (1350000UL / val);
 }
 
-/* Read 1-byte register. Returns unsigned reg or -ERRNO on error. */
-static int nct7904_read_reg(struct nct7904_data *data,
-			    unsigned bank, unsigned reg)
+static inline u16 FAN_TO_REG(long rpm)
 {
-	struct i2c_client *client = data->client;
-	int ret;
+	if (rpm <= 0)
+		return 0x1fff;
+	return clamp_val((1350000 + (rpm >> 1)) / rpm, 1, 0x1fff);
+}
+
+static inline unsigned long TIME_FROM_REG(u8 reg)
+{
+	return (reg * 100);
+}
+
+static inline u8 TIME_TO_REG(unsigned long val)
+{
+	return clamp_val((val + 50) / 100, 0, 0xff);
+}
 
-	ret = nct7904_bank_lock(data, bank);
-	if (ret == 0)
-		ret = i2c_smbus_read_byte_data(client, reg);
+/* For 8-bit 2's complement integer portion */
+static inline long TEMP_FROM_REG(s8 reg)
+{
+	return (reg * 1000);
+}
 
-	nct7904_bank_release(data);
-	return ret;
+
+/* For limitation */
+static inline s8 TEMP_TO_REG(long val, s8 min, s8 max)
+{
+//	return clamp_val((val < 0 ? -val : val) / 1000, min, max);
+	return clamp_val(val / 1000, min, max);
 }
 
+
+enum chip_types {nct7904d};
+
+struct nct7904_data {
+	struct device *hwmon_dev;
+	struct mutex update_lock;
+	unsigned long last_updated;	/* In jiffies */
+	enum chip_types chip_type; /* For recording what the chip is */ 
+	const struct attribute_group *groups[5];
+
+	struct i2c_client *client;
+
+	u8 bank;
+	
+//	u8 vrm;
+//	u8 vid[3];
+//	u8 has_vid;    /* Enable monitor VID or not, affected by CR 0x6A */
+
+	u32 has_in;    /* Enable monitor VIN or not, affected by CR 0x02, 0x03 */
+	u16 in[17][3];		/* Register value, [VSEN1~14,3VDD,VBAT,3VSB][read/high/low] */
+
+//	u8 has_gain;        /* has gain: in17 -in20 * 8 */
+
+	u16 has_fan;		/* Enable fan1-14, 3VDD, VBAT, 3VSB */
+	u16 fan[12];		/* Register value combine */
+	u16 fan_min[12];	/* Register value combine */
+
+	u8 has_temp;      /* Enable monitor temp4-1 or not, affected by CR 0x04, 0x05 */
+	u8 temp[5][5];		/* [ch1~ch4,LTD][current, crit, crit_hyst, warn, warn_hyst] */
+	u8 temp_read_lsb[5]; /* The LSB value corresponded to temp[][TEMP_READ] */
+	u8 temp_mode;	/* 0: TR mode, 1: TD mode */
+
+
+	u8 enable_dts;    /* Enable PECI and SB-TSI, 
+	* bit 0: =1 enable, =0 disable , 
+	* bit 1: =1 AMD SB-TSI, =0 Intel PECI */
+	u8 has_dts;      /* Enable monitor DTS temp: T_CPU1~T_CPU8 */
+	u8 dts[8][5];       /* [DTS_CPU1~DTS_CPU8][current, crit, crit_hyst, warn, warn_hyst] */
+	u8 dts_read_lsb[8];  /* The LSB value corresponded to dts[][DTS_READ] */
+
+ 
+
+	u8 alarms[10];     /* Register value */
+
+	
+	char valid;
+};
+
+static u8 nct7904_read_value(struct i2c_client *client, u16 reg);
+static int nct7904_write_value(struct i2c_client *client, u16 reg, u8 value);
+static int nct7904_probe(struct i2c_client *client,
+			const struct i2c_device_id *id);
+static int nct7904_detect(struct i2c_client *client,
+			 struct i2c_board_info *info);
+//static int nct7904_remove(struct i2c_client *client);
+
+static void nct7904_init_client(struct i2c_client *client);
+static struct nct7904_data *nct7904_update_device(struct device *dev);
+
+#ifdef CONFIG_OF
+
+static int nct7904_get_channels_config(struct i2c_client *client, struct nct7904_data *data);
+
+#endif
+
+static const struct i2c_device_id nct7904_id[] = {
+	{ "nct7904", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, nct7904_id);
+
+static struct i2c_driver nct7904_driver = {
+	.class		= I2C_CLASS_HWMON,
+	.driver = {
+		   .name = "nct7904",
+	},
+	.probe		= nct7904_probe,
+//	.remove		= nct7904_remove,
+	.id_table	= nct7904_id,
+	.detect		= nct7904_detect,
+	.address_list	= normal_i2c,
+};
+
+
 /*
- * Read 2-byte register. Returns register in big-endian format or
- * -ERRNO on error.
- */
-static int nct7904_read_reg16(struct nct7904_data *data,
-			      unsigned bank, unsigned reg)
+static ssize_t
+show_vid(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct i2c_client *client = data->client;
-	int ret, hi;
-
-	ret = nct7904_bank_lock(data, bank);
-	if (ret == 0) {
-		ret = i2c_smbus_read_byte_data(client, reg);
-		if (ret >= 0) {
-			hi = ret;
-			ret = i2c_smbus_read_byte_data(client, reg + 1);
-			if (ret >= 0)
-				ret |= hi << 8;
+	struct w83795_data *data = w83795_update_device(dev);
+	struct sensor_device_attribute_2 *sensor_attr =
+	    to_sensor_dev_attr_2(attr);
+	int nr = sensor_attr->nr;
+
+	return sprintf(buf, "%d\n", vid_from_reg(data->vid[nr], data->vrm));
+}
+*/
+
+
+#define ALARM_STATUS      0
+//#define BEEP_ENABLE       1
+#define ALARM_DTS_STATUS	2
+
+static ssize_t
+show_alarm_beep(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct nct7904_data *data = nct7904_update_device(dev);
+	struct sensor_device_attribute_2 *sensor_attr =
+	    to_sensor_dev_attr_2(attr);
+	int nr = sensor_attr->nr;
+	int index = sensor_attr->index >> 3;
+	int bit = sensor_attr->index & 0x07;
+	u8 val;
+
+	if (ALARM_DTS_STATUS == nr){ //For 7904 DTS alarm
+		if (sensor_attr->index < 4){
+			val = (data->alarms[6] >> (bit)) & 1;
+		}
+		else{
+			val = (data->alarms[7] >> (bit-4)) & 1;
 		}
 	}
+	else{
+		val = (data->alarms[index] >> (bit)) & 1;
+	}
+
 
-	nct7904_bank_release(data);
-	return ret;
+	return sprintf(buf, "%u\n", val);
 }
 
-/* Write 1-byte register. Returns 0 or -ERRNO on error. */
-static int nct7904_write_reg(struct nct7904_data *data,
-			     unsigned bank, unsigned reg, u8 val)
-{
-	struct i2c_client *client = data->client;
-	int ret;
 
-	ret = nct7904_bank_lock(data, bank);
-	if (ret == 0)
-		ret = i2c_smbus_write_byte_data(client, reg, val);
+#define FAN_INPUT     0
+#define FAN_MIN       1
+static ssize_t
+show_fan(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct sensor_device_attribute_2 *sensor_attr =
+	    to_sensor_dev_attr_2(attr);
+	int nr = sensor_attr->nr;
+	int index = sensor_attr->index;
+	struct nct7904_data *data = nct7904_update_device(dev);
+	u16 val;
+
+	if (FAN_INPUT == nr) {
+		val = data->fan[index] & 0x1fff;
+	} else {
+		val = data->fan_min[index] & 0x1fff;
+	}
 
-	nct7904_bank_release(data);
-	return ret;
+	return sprintf(buf, "%lu\n", FAN_FROM_REG(val));
 }
 
-static int nct7904_read_fan(struct device *dev, u32 attr, int channel,
-			    long *val)
+static ssize_t
+store_fan_min(struct device *dev, struct device_attribute *attr,
+	      const char *buf, size_t count)
 {
+	struct sensor_device_attribute_2 *sensor_attr =
+	    to_sensor_dev_attr_2(attr);
+	int index = sensor_attr->index;
 	struct nct7904_data *data = dev_get_drvdata(dev);
-	unsigned int cnt, rpm;
-	int ret;
-
-	switch(attr) {
-	case hwmon_fan_input:
-		ret = nct7904_read_reg16(data, BANK_0,
-					 FANIN1_HV_REG + channel * 2);
-		if (ret < 0)
-			return ret;
-		cnt = ((ret & 0xff00) >> 3) | (ret & 0x1f);
-		if (cnt == 0x1fff)
-			rpm = 0;
-		else
-			rpm = 1350000 / cnt;
-		*val = rpm;
+	struct i2c_client *client = data->client;
+
+
+	u16 val;
+	unsigned long tmpVal;
+	int err;
+	err = kstrtoul(buf, 10, &tmpVal);
+	if (err){
 		return 0;
-	default:
-		return -EOPNOTSUPP;
+	}	
+	val=FAN_TO_REG((u16)tmpVal);
+
+
+	mutex_lock(&data->update_lock);
+	data->fan_min[index] = val;
+	nct7904_write_value(client, NCT7904_REG_FAN_MIN(index),
+			   (val >> 5) & 0xff);
+
+	nct7904_write_value(client, NCT7904_REG_FAN_MIN_LSB(index), val & NCT7904_FAN_LSB_MASK);
+	mutex_unlock(&data->update_lock);
+
+	return count;
+}
+
+
+
+/* Only for storing integer portion */
+static ssize_t
+show_temp(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct sensor_device_attribute_2 *sensor_attr =
+	    to_sensor_dev_attr_2(attr);
+	int nr = sensor_attr->nr;
+	int index = sensor_attr->index;
+	struct nct7904_data *data = nct7904_update_device(dev);
+	long temp = TEMP_FROM_REG(data->temp[index][nr]);
+
+	if (TEMP_READ == nr){
+		temp += (data->temp_read_lsb[index] & TEMP_LSB_MASK) * 125;
 	}
+
+	return sprintf(buf, "%ld\n", temp);
 }
 
-static umode_t nct7904_fan_is_visible(const void *_data, u32 attr, int channel)
+static ssize_t
+store_temp(struct device *dev, struct device_attribute *attr,
+	   const char *buf, size_t count)
 {
-	const struct nct7904_data *data = _data;
+	struct sensor_device_attribute_2 *sensor_attr =
+	    to_sensor_dev_attr_2(attr);
+	int nr = sensor_attr->nr;
+	int index = sensor_attr->index;
+	struct nct7904_data *data = dev_get_drvdata(dev);
+	struct i2c_client *client = data->client;
 
-	if (attr == hwmon_fan_input && data->fanin_mask & (1 << channel))
-		return S_IRUGO;
-	return 0;
+	long tmp;
+	long tmpVal;
+	int err;
+	err = kstrtol(buf, 10, &tmpVal);
+	if (err){
+		return 0;
+	}	
+	tmp=tmpVal;
+
+	mutex_lock(&data->update_lock);
+	data->temp[index][nr] = TEMP_TO_REG(tmp, -128, 127);
+	nct7904_write_value(client, NCT7904_REG_TEMP[index][nr],
+			   data->temp[index][nr]);
+	mutex_unlock(&data->update_lock);
+	return count;
 }
 
-static u8 nct7904_chan_to_index[] = {
-	0,	/* Not used */
-	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
-	18, 19, 20, 16
-};
 
-static int nct7904_read_in(struct device *dev, u32 attr, int channel,
-			   long *val)
+static ssize_t
+show_dts_mode(struct device *dev, struct device_attribute *attr, char *buf)
 {
 	struct nct7904_data *data = dev_get_drvdata(dev);
-	int ret, volt, index;
-
-	index = nct7904_chan_to_index[channel];
-
-	switch(attr) {
-	case hwmon_in_input:
-		ret = nct7904_read_reg16(data, BANK_0,
-					 VSEN1_HV_REG + index * 2);
-		if (ret < 0)
-			return ret;
-		volt = ((ret & 0xff00) >> 5) | (ret & 0x7);
-		if (index < 14)
-			volt *= 2; /* 0.002V scale */
+
+	
+	struct sensor_device_attribute_2 *sensor_attr =
+	    to_sensor_dev_attr_2(attr);
+	int index = sensor_attr->index;
+	u8 tmp;
+
+	if (data->enable_dts == 0)
+		return sprintf(buf, "%d\n", 0);
+	
+	if ((data->has_dts >> index) & 0x01) {
+		if (data->enable_dts & 2)
+			tmp = 5; //TSI
 		else
-			volt *= 6; /* 0.006V scale */
-		*val = volt;
-		return 0;
-	default:
-		return -EOPNOTSUPP;
+			tmp = 6; //PECI
+	} else {
+		tmp = 0;
 	}
+
+	return sprintf(buf, "%d\n", tmp);
 }
 
-static umode_t nct7904_in_is_visible(const void *_data, u32 attr, int channel)
-{
-	const struct nct7904_data *data = _data;
-	int index = nct7904_chan_to_index[channel];
 
-	if (channel > 0 && attr == hwmon_in_input &&
-	    (data->vsen_mask & BIT(index)))
-		return S_IRUGO;
 
-	return 0;
+static ssize_t
+show_dts(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct sensor_device_attribute_2 *sensor_attr =
+	    to_sensor_dev_attr_2(attr);
+	int nr = sensor_attr->nr;
+	int index = sensor_attr->index;
+	struct nct7904_data *data = nct7904_update_device(dev);
+	long temp = TEMP_FROM_REG(data->dts[index][nr]);
+	
+	if (DTS_READ == nr){
+		temp += (data->dts_read_lsb[index] & DTS_LSB_MASK) * 125;
+	}
+
+	return sprintf(buf, "%ld\n", temp);
 }
 
-static int nct7904_read_temp(struct device *dev, u32 attr, int channel,
-			     long *val)
+
+/* Only for storing integer portion */
+static ssize_t
+store_dts(struct device *dev, struct device_attribute *attr,
+	   const char *buf, size_t count)
 {
+	struct sensor_device_attribute_2 *sensor_attr =
+	    to_sensor_dev_attr_2(attr);
+	int nr = sensor_attr->nr;
+	int index = sensor_attr->index;
 	struct nct7904_data *data = dev_get_drvdata(dev);
-	int ret, temp;
+	struct i2c_client *client = data->client;
 
-	switch(attr) {
-	case hwmon_temp_input:
-		if (channel == 0)
-			ret = nct7904_read_reg16(data, BANK_0, LTD_HV_REG);
-		else
-			ret = nct7904_read_reg16(data, BANK_0,
-					T_CPU1_HV_REG + (channel - 1) * 2);
-		if (ret < 0)
-			return ret;
-		temp = ((ret & 0xff00) >> 5) | (ret & 0x7);
-		*val = sign_extend32(temp, 10) * 125;
+	long tmp;
+	long tmpVal;
+	int err;
+	err = kstrtol(buf, 10, &tmpVal);
+	if (err){
 		return 0;
-	default:
-		return -EOPNOTSUPP;
-	}
+	}	
+	tmp=tmpVal;
+
+
+	mutex_lock(&data->update_lock);
+	data->dts[index][nr] = TEMP_TO_REG(tmp, -128, 127);
+	nct7904_write_value(client, NCT7904_REG_DTS[index][nr],
+			   data->dts[index][nr]);
+	mutex_unlock(&data->update_lock);
+	return count;
 }
 
-static umode_t nct7904_temp_is_visible(const void *_data, u32 attr, int channel)
+/*
+	Type 3:  Thermal diode
+  Type 4:  Thermistor
+*/
+static ssize_t
+show_temp_mode(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	const struct nct7904_data *data = _data;
-
-	if (attr == hwmon_temp_input) {
-		if (channel == 0) {
-			if (data->vsen_mask & BIT(17))
-				return S_IRUGO;
+	struct nct7904_data *data = dev_get_drvdata(dev);
+	
+	struct sensor_device_attribute_2 *sensor_attr =
+	    to_sensor_dev_attr_2(attr);
+	int index = sensor_attr->index;
+	u8 tmp;
+
+	if ((data->has_temp >> index) & 0x01) {
+		if ((data->temp_mode >> index) & 0x01) {
+			tmp = 3;	//TD
 		} else {
-			if (data->tcpu_mask & BIT(channel - 1))
-				return S_IRUGO;
+			tmp = 4;	//TR
 		}
+	} else {
+		tmp = 0;
 	}
 
-	return 0;
+	return sprintf(buf, "%d\n", tmp);
+}
+
+
+/* show/store VIN */
+static ssize_t
+show_in(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct sensor_device_attribute_2 *sensor_attr =
+	    to_sensor_dev_attr_2(attr);
+	int nr = sensor_attr->nr;
+	int index = sensor_attr->index;
+	struct nct7904_data *data = nct7904_update_device(dev);
+	u16 val = data->in[index][nr];
+	
+
+	val = IN_FROM_REG(index, val);
+
+	return sprintf(buf, "%d\n", val);
 }
 
-static int nct7904_read_pwm(struct device *dev, u32 attr, int channel,
-			    long *val)
+static ssize_t
+store_in(struct device *dev, struct device_attribute *attr,
+	 const char *buf, size_t count)
 {
+	struct sensor_device_attribute_2 *sensor_attr =
+	    to_sensor_dev_attr_2(attr);
+	int nr = sensor_attr->nr;
+	int index = sensor_attr->index;
 	struct nct7904_data *data = dev_get_drvdata(dev);
-	int ret;
-
-	switch(attr) {
-	case hwmon_pwm_input:
-		ret = nct7904_read_reg(data, BANK_3, FANCTL1_OUT_REG + channel);
-		if (ret < 0)
-			return ret;
-		*val = ret;
-		return 0;
-	case hwmon_pwm_enable:
-		ret = nct7904_read_reg(data, BANK_3, FANCTL1_FMR_REG + channel);
-		if (ret < 0)
-			return ret;
+	struct i2c_client *client = data->client;
+
+	u8 tmp;
 
-		*val = ret ? 2 : 1;
+	u16 val;
+	unsigned long tmpVal;
+	int err;
+	err = kstrtoul(buf, 10, &tmpVal);
+	if (err){
 		return 0;
-	default:
-		return -EOPNOTSUPP;
+	}	
+	val=IN_TO_REG(index, (u16)tmpVal);
+
+	
+	val = clamp_val(val, 0, 0x7FF);
+	mutex_lock(&data->update_lock);
+
+	switch (nr){
+	case IN_MAX:
+		tmp = nct7904_read_value(client, IN_HL_LSB_REG(index));
+		tmp &= ~IN_LSB_MASK;
+		tmp |= val & IN_LSB_MASK;
+		nct7904_write_value(client, IN_HL_LSB_REG(index), tmp);
+		break;
+	case IN_LOW:
+		tmp = nct7904_read_value(client, IN_LL_LSB_REG(index));
+		tmp &= ~IN_LSB_MASK;
+		tmp |= val & IN_LSB_MASK;
+		nct7904_write_value(client, IN_LL_LSB_REG(index), tmp);
+		break;
 	}
+
+	tmp = (val >> 3) & 0xff;
+	nct7904_write_value(client, NCT7904_REG_IN[index][nr], tmp);
+
+	data->in[index][nr] = val;
+
+	mutex_unlock(&data->update_lock);
+	return count;
 }
 
-static int nct7904_write_pwm(struct device *dev, u32 attr, int channel,
-			     long val)
+
+static umode_t nct7904_in_is_visible(struct kobject *kobj,
+				     struct attribute *attr, int index)
 {
+	struct device *dev = container_of(kobj, struct device, kobj);
 	struct nct7904_data *data = dev_get_drvdata(dev);
-	int ret;
-
-	switch(attr) {
-	case hwmon_pwm_input:
-		if (val < 0 || val > 255)
-			return -EINVAL;
-		ret = nct7904_write_reg(data, BANK_3, FANCTL1_OUT_REG + channel,
-					val);
-		return ret;
-	case hwmon_pwm_enable:
-		if (val < 1 || val > 2 ||
-		    (val == 2 && !data->fan_mode[channel]))
-			return -EINVAL;
-		ret = nct7904_write_reg(data, BANK_3, FANCTL1_FMR_REG + channel,
-					val == 2 ? data->fan_mode[channel] : 0);
-		return ret;
-	default:
-		return -EOPNOTSUPP;
-	}
-}
-
-static umode_t nct7904_pwm_is_visible(const void *_data, u32 attr, int channel)
-{
-	switch(attr) {
-	case hwmon_pwm_input:
-	case hwmon_pwm_enable:
-		return S_IRUGO | S_IWUSR;
-	default:
+	int in = index / 4;	/* voltage index */
+
+	if (!(data->has_in & (1 << in)))
 		return 0;
-	}
+
+	return attr->mode;
 }
 
-static int nct7904_read(struct device *dev, enum hwmon_sensor_types type,
-			u32 attr, int channel, long *val)
+static umode_t nct7904_fan_is_visible(struct kobject *kobj,
+				     struct attribute *attr, int index)
 {
-	switch (type) {
-	case hwmon_in:
-		return nct7904_read_in(dev, attr, channel, val);
-	case hwmon_fan:
-		return nct7904_read_fan(dev, attr, channel, val);
-	case hwmon_pwm:
-		return nct7904_read_pwm(dev, attr, channel, val);
-	case hwmon_temp:
-		return nct7904_read_temp(dev, attr, channel, val);
-	default:
-		return -EOPNOTSUPP;
-	}
+	struct device *dev = container_of(kobj, struct device, kobj);
+	struct nct7904_data *data = dev_get_drvdata(dev);
+	int fan = index / 3;	/* fan index */
+
+	if (!(data->has_fan & (1 << fan)))
+		return 0;
+
+	return attr->mode;
 }
 
-static int nct7904_write(struct device *dev, enum hwmon_sensor_types type,
-			 u32 attr, int channel, long val)
+
+static umode_t nct7904_dts_is_visible(struct kobject *kobj,
+				     struct attribute *attr, int index)
 {
-	switch (type) {
-	case hwmon_pwm:
-		return nct7904_write_pwm(dev, attr, channel, val);
-	default:
-		return -EOPNOTSUPP;
-	}
+	struct device *dev = container_of(kobj, struct device, kobj);
+	struct nct7904_data *data = dev_get_drvdata(dev);
+	int dts = index / 7;	/* dts index */
+
+	if (!(data->has_dts & (1 << dts)))
+		return 0;
+
+	return attr->mode;
 }
 
-static umode_t nct7904_is_visible(const void *data,
-				  enum hwmon_sensor_types type,
-				  u32 attr, int channel)
+
+static umode_t nct7904_temp_is_visible(struct kobject *kobj,
+				     struct attribute *attr, int index)
 {
-	switch (type) {
-	case hwmon_in:
-		return nct7904_in_is_visible(data, attr, channel);
-	case hwmon_fan:
-		return nct7904_fan_is_visible(data, attr, channel);
-	case hwmon_pwm:
-		return nct7904_pwm_is_visible(data, attr, channel);
-	case hwmon_temp:
-		return nct7904_temp_is_visible(data, attr, channel);
-	default:
+	struct device *dev = container_of(kobj, struct device, kobj);
+	struct nct7904_data *data = dev_get_drvdata(dev);
+	int temp = index / 7;	/* temp index */
+
+	if (!(data->has_temp & (1 << temp)))
 		return 0;
-	}
+
+	return attr->mode;
 }
 
-/* Return 0 if detection is successful, -ENODEV otherwise */
-static int nct7904_detect(struct i2c_client *client,
-			  struct i2c_board_info *info)
-{
-	struct i2c_adapter *adapter = client->adapter;
 
-	if (!i2c_check_functionality(adapter,
-				     I2C_FUNC_SMBUS_READ_BYTE |
-				     I2C_FUNC_SMBUS_WRITE_BYTE_DATA))
-		return -ENODEV;
 
-	/* Determine the chip type. */
-	if (i2c_smbus_read_byte_data(client, VENDOR_ID_REG) != NUVOTON_ID ||
-	    i2c_smbus_read_byte_data(client, CHIP_ID_REG) != NCT7904_ID ||
-	    (i2c_smbus_read_byte_data(client, DEVICE_ID_REG) & 0xf0) != 0x50 ||
-	    (i2c_smbus_read_byte_data(client, BANK_SEL_REG) & 0xf8) != 0x00)
-		return -ENODEV;
+#define NOT_USED			-1
 
-	strlcpy(info->type, "nct7904", I2C_NAME_SIZE);
 
-	return 0;
-}
 
-static const u32 nct7904_in_config[] = {
-	HWMON_I_INPUT,                  /* dummy, skipped in is_visible */
-	HWMON_I_INPUT,
-	HWMON_I_INPUT,
-	HWMON_I_INPUT,
-	HWMON_I_INPUT,
-	HWMON_I_INPUT,
-	HWMON_I_INPUT,
-	HWMON_I_INPUT,
-	HWMON_I_INPUT,
-	HWMON_I_INPUT,
-	HWMON_I_INPUT,
-	HWMON_I_INPUT,
-	HWMON_I_INPUT,
-	HWMON_I_INPUT,
-	HWMON_I_INPUT,
-	HWMON_I_INPUT,
-	HWMON_I_INPUT,
-	HWMON_I_INPUT,
-	HWMON_I_INPUT,
-	HWMON_I_INPUT,
-	HWMON_I_INPUT,
-	0
+#define SENSOR_DEV_ATTR_IN(index)		\
+	static SENSOR_DEVICE_ATTR_2(in##index##_input, S_IRUGO, show_in, NULL,	\
+		IN_READ, index); \
+	static SENSOR_DEVICE_ATTR_2(in##index##_max, S_IRUGO | S_IWUSR, show_in,	\
+		store_in, IN_MAX, index);		\
+	static SENSOR_DEVICE_ATTR_2(in##index##_min, S_IRUGO | S_IWUSR, show_in,	\
+		store_in, IN_LOW, index);	\
+	static SENSOR_DEVICE_ATTR_2(in##index##_alarm, S_IRUGO, show_alarm_beep,	\
+		NULL, ALARM_STATUS,	index)
+
+#define DEV_ATTR_ATTR_LIST_IN(index)	\
+	&sensor_dev_attr_in##index##_input.dev_attr.attr,	\
+	&sensor_dev_attr_in##index##_max.dev_attr.attr,	\
+	&sensor_dev_attr_in##index##_min.dev_attr.attr,	\
+	&sensor_dev_attr_in##index##_alarm.dev_attr.attr
+
+
+
+#define SENSOR_DEV_ATTR_FAN(index)						\
+		static SENSOR_DEVICE_ATTR_2(fan##index##_input, S_IRUGO, show_fan,		\
+			NULL, FAN_INPUT, index - 1); \
+		static SENSOR_DEVICE_ATTR_2(fan##index##_min, S_IWUSR | S_IRUGO, 	\
+			show_fan, store_fan_min, FAN_MIN, index - 1);	\
+		static SENSOR_DEVICE_ATTR_2(fan##index##_alarm, S_IRUGO, show_alarm_beep, \
+			NULL, ALARM_STATUS, index + 31)
+
+
+#define DEV_ATTR_ATTR_LIST_FAN(index)	\
+	&sensor_dev_attr_fan##index##_input.dev_attr.attr,	\
+	&sensor_dev_attr_fan##index##_min.dev_attr.attr,	\
+	&sensor_dev_attr_fan##index##_alarm.dev_attr.attr
+
+
+
+
+
+#define SENSOR_DEV_ATTR_DTS(index)						\
+		static SENSOR_DEVICE_ATTR_2(temp##index##_type, S_IRUGO ,		\
+			show_dts_mode, NULL, NOT_USED, index - 6);	\
+		static SENSOR_DEVICE_ATTR_2(temp##index##_input, S_IRUGO, show_dts, 	\
+			NULL, DTS_READ, index - 6);				\
+		static SENSOR_DEVICE_ATTR_2(temp##index##_max, S_IRUGO | S_IWUSR, show_dts,	\
+			store_dts, DTS_CRIT, index - 6); 		\
+		static SENSOR_DEVICE_ATTR_2(temp##index##_max_hyst, S_IRUGO | S_IWUSR, \
+			show_dts, store_dts, DTS_CRIT_HYST, index - 6); \
+		static SENSOR_DEVICE_ATTR_2(temp##index##_warn, S_IRUGO | S_IWUSR, show_dts, \
+			store_dts, DTS_WARN, index - 6); 		\
+		static SENSOR_DEVICE_ATTR_2(temp##index##_warn_hyst, S_IRUGO | S_IWUSR,	\
+			show_dts, store_dts, DTS_WARN_HYST, index - 6); \
+		static SENSOR_DEVICE_ATTR_2(temp##index##_alarm, S_IRUGO,			\
+			show_alarm_beep, NULL, ALARM_DTS_STATUS, index - 6)
+
+	
+#define DEV_ATTR_ATTR_LIST_DTS(index)	\
+		&sensor_dev_attr_temp##index##_type.dev_attr.attr,	\
+		&sensor_dev_attr_temp##index##_input.dev_attr.attr,	\
+		&sensor_dev_attr_temp##index##_max.dev_attr.attr, \
+		&sensor_dev_attr_temp##index##_max_hyst.dev_attr.attr, \
+		&sensor_dev_attr_temp##index##_warn.dev_attr.attr, \
+		&sensor_dev_attr_temp##index##_warn_hyst.dev_attr.attr, \
+		&sensor_dev_attr_temp##index##_alarm.dev_attr.attr
+
+
+
+#define SENSOR_DEV_ATTR_TEMP(index)						\
+	static SENSOR_DEVICE_ATTR_2(temp##index##_type, S_IRUGO,		\
+		show_temp_mode, NULL, NOT_USED, index - 1);	\
+	static SENSOR_DEVICE_ATTR_2(temp##index##_input, S_IRUGO, show_temp,		\
+		NULL, TEMP_READ, index - 1);				\
+	static SENSOR_DEVICE_ATTR_2(temp##index##_max, S_IRUGO | S_IWUSR, show_temp,	\
+		store_temp, TEMP_CRIT, index - 1);			\
+	static SENSOR_DEVICE_ATTR_2(temp##index##_max_hyst, S_IRUGO | S_IWUSR,	\
+		show_temp, store_temp, TEMP_CRIT_HYST, index - 1);	\
+	static SENSOR_DEVICE_ATTR_2(temp##index##_warn, S_IRUGO | S_IWUSR, show_temp,	\
+		store_temp, TEMP_WARN, index - 1);			\
+	static SENSOR_DEVICE_ATTR_2(temp##index##_warn_hyst, S_IRUGO | S_IWUSR,	\
+		show_temp, store_temp, TEMP_WARN_HYST, index - 1);	\
+	static SENSOR_DEVICE_ATTR_2(temp##index##_alarm, S_IRUGO,			\
+		show_alarm_beep, NULL, ALARM_STATUS, index * 2 - 1 )
+
+
+#define DEV_ATTR_ATTR_LIST_TEMP(index)	\
+		&sensor_dev_attr_temp##index##_type.dev_attr.attr,	\
+		&sensor_dev_attr_temp##index##_input.dev_attr.attr,	\
+		&sensor_dev_attr_temp##index##_max.dev_attr.attr, \
+		&sensor_dev_attr_temp##index##_max_hyst.dev_attr.attr, \
+		&sensor_dev_attr_temp##index##_warn.dev_attr.attr, \
+		&sensor_dev_attr_temp##index##_warn_hyst.dev_attr.attr, \
+		&sensor_dev_attr_temp##index##_alarm.dev_attr.attr
+
+
+
+
+SENSOR_DEV_ATTR_IN(0);
+SENSOR_DEV_ATTR_IN(1);
+SENSOR_DEV_ATTR_IN(2);
+SENSOR_DEV_ATTR_IN(3);
+SENSOR_DEV_ATTR_IN(4);
+SENSOR_DEV_ATTR_IN(5);
+SENSOR_DEV_ATTR_IN(6);
+SENSOR_DEV_ATTR_IN(7);
+SENSOR_DEV_ATTR_IN(8);
+SENSOR_DEV_ATTR_IN(9);
+SENSOR_DEV_ATTR_IN(10);
+SENSOR_DEV_ATTR_IN(11);
+SENSOR_DEV_ATTR_IN(12);
+SENSOR_DEV_ATTR_IN(13);
+SENSOR_DEV_ATTR_IN(14);
+SENSOR_DEV_ATTR_IN(15);
+SENSOR_DEV_ATTR_IN(16);
+
+static struct attribute *nct7904_attributes_in[] = {
+	DEV_ATTR_ATTR_LIST_IN(0),
+	DEV_ATTR_ATTR_LIST_IN(1),
+   DEV_ATTR_ATTR_LIST_IN(2),
+   DEV_ATTR_ATTR_LIST_IN(3),
+   DEV_ATTR_ATTR_LIST_IN(4),
+   DEV_ATTR_ATTR_LIST_IN(5),
+   DEV_ATTR_ATTR_LIST_IN(6),
+   DEV_ATTR_ATTR_LIST_IN(7),
+   DEV_ATTR_ATTR_LIST_IN(8),
+   DEV_ATTR_ATTR_LIST_IN(9),
+   DEV_ATTR_ATTR_LIST_IN(10),
+   DEV_ATTR_ATTR_LIST_IN(11),
+   DEV_ATTR_ATTR_LIST_IN(12),
+   DEV_ATTR_ATTR_LIST_IN(13),
+   DEV_ATTR_ATTR_LIST_IN(14),
+   DEV_ATTR_ATTR_LIST_IN(15),
+   DEV_ATTR_ATTR_LIST_IN(16),
+	NULL
 };
 
-static const struct hwmon_channel_info nct7904_in = {
-	.type = hwmon_in,
-	.config = nct7904_in_config,
-};
 
-static const u32 nct7904_fan_config[] = {
-            HWMON_F_INPUT,
-            HWMON_F_INPUT,
-            HWMON_F_INPUT,
-            HWMON_F_INPUT,
-            HWMON_F_INPUT,
-            HWMON_F_INPUT,
-            HWMON_F_INPUT,
-            HWMON_F_INPUT,
-	    0
-};
 
-static const struct hwmon_channel_info nct7904_fan = {
-	.type = hwmon_fan,
-	.config = nct7904_fan_config,
+
+SENSOR_DEV_ATTR_FAN(1);
+SENSOR_DEV_ATTR_FAN(2);
+SENSOR_DEV_ATTR_FAN(3);
+SENSOR_DEV_ATTR_FAN(4);
+SENSOR_DEV_ATTR_FAN(5);
+SENSOR_DEV_ATTR_FAN(6);
+SENSOR_DEV_ATTR_FAN(7);
+SENSOR_DEV_ATTR_FAN(8);
+SENSOR_DEV_ATTR_FAN(9);
+SENSOR_DEV_ATTR_FAN(10);
+SENSOR_DEV_ATTR_FAN(11);
+SENSOR_DEV_ATTR_FAN(12);
+
+static struct attribute *nct7904_attributes_fan[] = {
+	DEV_ATTR_ATTR_LIST_FAN(1),
+	DEV_ATTR_ATTR_LIST_FAN(2),
+	DEV_ATTR_ATTR_LIST_FAN(3),
+	DEV_ATTR_ATTR_LIST_FAN(4),
+	DEV_ATTR_ATTR_LIST_FAN(5),
+	DEV_ATTR_ATTR_LIST_FAN(6),
+	DEV_ATTR_ATTR_LIST_FAN(7),
+	DEV_ATTR_ATTR_LIST_FAN(8),
+	DEV_ATTR_ATTR_LIST_FAN(9),
+	DEV_ATTR_ATTR_LIST_FAN(10),
+	DEV_ATTR_ATTR_LIST_FAN(11),
+	DEV_ATTR_ATTR_LIST_FAN(12),
+	NULL
 };
 
-static const u32 nct7904_pwm_config[] = {
-            HWMON_PWM_INPUT | HWMON_PWM_ENABLE,
-            HWMON_PWM_INPUT | HWMON_PWM_ENABLE,
-            HWMON_PWM_INPUT | HWMON_PWM_ENABLE,
-            HWMON_PWM_INPUT | HWMON_PWM_ENABLE,
-	    0
+
+
+SENSOR_DEV_ATTR_TEMP(1);
+SENSOR_DEV_ATTR_TEMP(2);
+SENSOR_DEV_ATTR_TEMP(3);
+SENSOR_DEV_ATTR_TEMP(4);
+SENSOR_DEV_ATTR_TEMP(5);
+
+
+static struct attribute *nct7904_attributes_temp[] = {
+	DEV_ATTR_ATTR_LIST_TEMP(1),
+	DEV_ATTR_ATTR_LIST_TEMP(2),
+	DEV_ATTR_ATTR_LIST_TEMP(3),
+	DEV_ATTR_ATTR_LIST_TEMP(4),
+	DEV_ATTR_ATTR_LIST_TEMP(5),
+	NULL
 };
 
-static const struct hwmon_channel_info nct7904_pwm = {
-	.type = hwmon_pwm,
-	.config = nct7904_pwm_config,
+
+
+SENSOR_DEV_ATTR_DTS(6);
+SENSOR_DEV_ATTR_DTS(7);
+SENSOR_DEV_ATTR_DTS(8);
+SENSOR_DEV_ATTR_DTS(9);
+SENSOR_DEV_ATTR_DTS(10);
+SENSOR_DEV_ATTR_DTS(11);
+SENSOR_DEV_ATTR_DTS(12);
+SENSOR_DEV_ATTR_DTS(13);
+
+static struct attribute *nct7904_attributes_dts[] = {
+	DEV_ATTR_ATTR_LIST_DTS(6),
+	DEV_ATTR_ATTR_LIST_DTS(7),
+	DEV_ATTR_ATTR_LIST_DTS(8),
+	DEV_ATTR_ATTR_LIST_DTS(9),
+	DEV_ATTR_ATTR_LIST_DTS(10),
+	DEV_ATTR_ATTR_LIST_DTS(11),
+	DEV_ATTR_ATTR_LIST_DTS(12),
+	DEV_ATTR_ATTR_LIST_DTS(13),
+	NULL
 };
 
-static const u32 nct7904_temp_config[] = {
-            HWMON_T_INPUT,
-            HWMON_T_INPUT,
-            HWMON_T_INPUT,
-            HWMON_T_INPUT,
-            HWMON_T_INPUT,
-            HWMON_T_INPUT,
-            HWMON_T_INPUT,
-            HWMON_T_INPUT,
-            HWMON_T_INPUT,
-	    0
+
+static const struct attribute_group nct7904_group_in = {
+	.attrs = nct7904_attributes_in,
+	.is_visible = nct7904_in_is_visible,
 };
 
-static const struct hwmon_channel_info nct7904_temp = {
-	.type = hwmon_temp,
-	.config = nct7904_temp_config,
+
+static const struct attribute_group nct7904_group_fan = {
+	.attrs = nct7904_attributes_fan,
+	.is_visible = nct7904_fan_is_visible,
 };
 
-static const struct hwmon_channel_info *nct7904_info[] = {
-	&nct7904_in,
-	&nct7904_fan,
-	&nct7904_pwm,
-	&nct7904_temp,
-	NULL
+static const struct attribute_group nct7904_group_dts = {
+	.attrs = nct7904_attributes_dts,
+	.is_visible = nct7904_dts_is_visible,
 };
 
-static const struct hwmon_ops nct7904_hwmon_ops = {
-	.is_visible = nct7904_is_visible,
-	.read = nct7904_read,
-	.write = nct7904_write,
+static const struct attribute_group nct7904_group_temp = {
+	.attrs = nct7904_attributes_temp,
+	.is_visible = nct7904_temp_is_visible,
 };
 
-static const struct hwmon_chip_info nct7904_chip_info = {
-	.ops = &nct7904_hwmon_ops,
-	.info = nct7904_info,
+
+
+/*
+static struct sensor_device_attribute_2 w83795_vid[] = {
+	SENSOR_ATTR_2(cpu0_vid, S_IRUGO, show_vid, NULL, NOT_USED, 0),
+	SENSOR_ATTR_2(cpu1_vid, S_IRUGO, show_vid, NULL, NOT_USED, 1),
+	SENSOR_ATTR_2(cpu2_vid, S_IRUGO, show_vid, NULL, NOT_USED, 2),
 };
+*/
 
-static int nct7904_probe(struct i2c_client *client,
-			 const struct i2c_device_id *id)
+
+static void nct7904_init_client(struct i2c_client *client)
 {
+	if (reset) {
+		nct7904_write_value(client, NCT7904_REG_GLOBAL_CONTROL, 0x80);
+	}
+
+	/* Start monitoring: nct7904 has no this register */
+
+}
+
+/* Return 0 if detection is successful, -ENODEV otherwise */
+static int nct7904_detect(struct i2c_client *client,
+			 struct i2c_board_info *info)
+{
+	u8 bank;
+	struct i2c_adapter *adapter = client->adapter;
+	unsigned short address = client->addr;
+
+	printk("nct7904: nct7904_detecting...\n");
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+		return -ENODEV;
+	}
+	bank = i2c_smbus_read_byte_data(client, NCT7904_REG_BANKSEL);
+
+
+	/* If Nuvoton chip, address of chip and W83795_REG_I2C_ADDR
+	   should match */
+	if ((bank & NCT7904_REG_BANK_MASK) == 0
+	 && (i2c_smbus_read_byte_data(client, NCT7904_REG_I2C_ADDR) & 0x7f) !=
+	    address<<1) {
+		printk("nct7904: Detection failed at check "
+			 "i2c addr\n");
+		return -ENODEV;
+	}
+
+
+	/* We have either had a force parameter, or we have already detected the
+	   Nuvoton. Determine the chip type now */
+/*
+	if (kind <= 0) {
+		if (0x79 == i2c_smbus_read_byte_data(client,
+		        W83795_REG_CHIPID)) {
+			kind = w83795;
+		} else {
+			if (kind == 0)
+				dev_warn(&adapter->dev, "w83795: Ignoring "
+					 "'force' parameter for unknown chip "
+					 "at address 0x%02x\n", address);
+			return -ENODEV;
+		}
+	}
+*/
+
+	/* Check Nuvoton vendor ID */
+	if (0x50 != i2c_smbus_read_byte_data(client,
+						NCT7904_REG_VENDORID)) {
+		if (0x50 != i2c_smbus_read_byte_data(client,
+						NCT7904_REG_VENDORID2)) {
+			printk("nct7904: Detection failed at check "
+				 "vendor id\n");
+		
+			return -ENODEV;
+		}
+	}
+
+	if (0x79 != i2c_smbus_read_byte_data(client,
+		        NCT7904_REG_CHIPID)) {
+		   if (0xC5 != i2c_smbus_read_byte_data(client,
+		        NCT7904_REG_CHIPID2)) {
+
+				printk("nct7904: Detection failed at check "
+				 "chip id\n");
+				return -ENODEV;
+		   }
+	} 
+
+	//set bank as 0
+	i2c_smbus_write_byte_data(client, NCT7904_REG_BANKSEL, 0);
+
+
+	printk("nct7904: nct7904 is found.\n");
+
+	/* Fill in the remaining client fields and put into the global list */
+	strlcpy(info->type, "nct7904", I2C_NAME_SIZE);
+	dev_info(&adapter->dev, "Detected Nuvoton %s chip at 0x%02x\n",
+		 "nct7904", client->addr);
+
+	return 0;
+}
+
+#define TMP_MASK 0x3
+static int nct7904_probe(struct i2c_client *client, 
+			const struct i2c_device_id *id)
+{
+	int i;
+	u8 tmp;
+	u16 u16tmp;
+	struct device *dev = &client->dev;
 	struct nct7904_data *data;
 	struct device *hwmon_dev;
-	struct device *dev = &client->dev;
-	int ret, i;
-	u32 mask;
+#ifdef CONFIG_OF
+	int config_result = 1;
+#endif
+//	int err = 0;
+
+	u8 val;
+	u8 TempIdxBit; //Tmp using. The index bit coresponding to has_temp and "TD" in has_mode
+	u32 VoltIdxBit; //Tmp using. The index bit coresponding to has_in
+
+	printk("nct7904: nct7904_probe\n");
 
-	data = devm_kzalloc(dev, sizeof(struct nct7904_data), GFP_KERNEL);
-	if (!data)
+	if (!(data = devm_kzalloc(dev,sizeof(struct nct7904_data), GFP_KERNEL))) {
 		return -ENOMEM;
+	}
+
+	i2c_set_clientdata(client, data);
+	data->bank = i2c_smbus_read_byte_data(client, NCT7904_REG_BANKSEL) & NCT7904_REG_BANK_MASK;
+	mutex_init(&data->update_lock);
+
+	data->client = client; //added by hsy 2018/04/17
+
+	/* Initialize the chip */
+	nct7904_init_client(client);
+
+#ifdef CONFIG_OF
+	config_result = nct7904_get_channels_config(client, data);
+#endif
+
+	/* Check chip type: Only one package-48 pins. So assign it directly. */
+	data->chip_type = nct7904d;
+
+#ifdef CONFIG_OF
+	if(config_result)
+	{
+#endif
+
+	    data->has_in = nct7904_read_value(client, NCT7904_REG_VOLT_CTRL1);
+	    data->has_in |= nct7904_read_value(client, NCT7904_REG_VOLT_CTRL2) << 8;
+	    data->has_in |= nct7904_read_value(client, NCT7904_REG_VOLT_CTRL3) << 16;
+
+#ifdef CONFIG_OF
+    }
+#endif
+
+	    data->has_fan = nct7904_read_value(client, NCT7904_REG_FANIN_CTRL1);
+	    data->has_fan |= nct7904_read_value(client, NCT7904_REG_FANIN_CTRL2) << 8;
+
+#ifdef CONFIG_OF
+	if(config_result)
+	{
+#endif
+
+	    data->has_temp = 0;
+	    tmp = nct7904_read_value(client, NCT7904_REG_VOLT_CTRL1);
+	    if ((tmp & 0x6) == 0x6){
+            data->has_temp |= 1;
+	    }
+	    if ((tmp & 0x18) == 0x18){
+            data->has_temp |= 2;
+	    }
+	    if ((tmp & 0x20) == 0x20){
+            data->has_temp |= 4;
+	    }
+	    if ((tmp & 0x80) == 0x80){
+            data->has_temp |= 8;
+	    }
+
+	    /* LTD */
+	    tmp = nct7904_read_value(client, NCT7904_REG_VOLT_CTRL3);
+	    if ((tmp & 0x02) == 0x02){
+	    	data->has_temp |= 0x10;
+	    }
+
+#ifdef CONFIG_OF
+    }
+#endif
+
+	/* PECI */
+	tmp = nct7904_read_value(client, NCT7904_REG_PECI_ENABLE);
+	if (tmp & 0x80) {
+		data->enable_dts = 1;	//bit1=0,bit0=1 => Enable DTS & PECI
+	} else {
+		tmp = nct7904_read_value(client, NCT7904_REG_TSI_CTRL);
+		if (tmp & 0x80) {
+			data->enable_dts = 0x3; //bit1=1, bit0=1, Enable DTS & TSI
+		}
+		else{
+			data->enable_dts = 0;
+		}
+	}
+
+#ifdef CONFIG_OF
+	if(config_result)
+	{
+#endif
+
+	    /* VDSEN2-9 and TR1-4, TD1-2 use the same pin and is exclusive. */
+	    data->temp_mode = 0;
+	    tmp = nct7904_read_value(client, NCT7904_REG_VOLT_TEMP_CTRL);
+
+	    /* Multi-Function detecting for Volt and TR/TD.
+	       Just deal with the DISABLE in has_xxxx because
+	       if it is not monitored, multi-function selection is useless.*/
+
+	    //VSEN2~3, TEMP_CH1
+	    val = (tmp & (TMP_MASK<<NCT7904_TEMP_CTRL_SHIFT[0]))>>NCT7904_TEMP_CTRL_SHIFT[0];
+	    TempIdxBit = (1<<0);
+	    VoltIdxBit = 0x6;
+
+	    if (val == VAL_VOLT_TEMP_CTRL_VOLT_MONITOR){
+            data->has_temp &= ~TempIdxBit;
+	    }
+	    else if (val == VAL_VOLT_TEMP_CTRL_DIODE_CURRENT){
+            data->has_in &= ~VoltIdxBit;
+            data->temp_mode |= TempIdxBit;
+	    }
+	    else{
+            data->has_in &= ~VoltIdxBit;
+	    }
+
+	    //VSEN4~5, TEMP_CH2
+	    val = (tmp & (TMP_MASK<<NCT7904_TEMP_CTRL_SHIFT[1]))>>NCT7904_TEMP_CTRL_SHIFT[1];
+	    TempIdxBit = (1<<1);
+	    VoltIdxBit = 0x18;
+	    if (val == VAL_VOLT_TEMP_CTRL_VOLT_MONITOR){
+            data->has_temp &= ~TempIdxBit;
+	    }
+	    else if (val == VAL_VOLT_TEMP_CTRL_DIODE_CURRENT){
+            data->has_in &= ~VoltIdxBit;
+            data->temp_mode |= TempIdxBit;
+	    }
+	    else{
+            data->has_in &= ~VoltIdxBit;
+	    }
+
+	    //VSEN6, TEMP_CH3
+	    val = (tmp & (TMP_MASK<<NCT7904_TEMP_CTRL_SHIFT[2]))>>NCT7904_TEMP_CTRL_SHIFT[2];
+	    TempIdxBit = (1<<2);
+	    VoltIdxBit = 0x20;
+	    if (val == VAL_VOLT_TEMP_CTRL_VOLT_MONITOR){
+            data->has_temp &= ~TempIdxBit;
+	    }
+	    else{ //TR
+            data->has_in &= ~VoltIdxBit;
+	    }
+
+	    //VSEN8, TEMP_CH4
+	    val = (tmp & (TMP_MASK<<NCT7904_TEMP_CTRL_SHIFT[3]))>>NCT7904_TEMP_CTRL_SHIFT[3];
+	    TempIdxBit = (1<<3);
+	    VoltIdxBit = 0x80;
+	    if (val == VAL_VOLT_TEMP_CTRL_VOLT_MONITOR){
+            data->has_temp &= ~TempIdxBit;
+	    }
+	    else{ //TR
+            data->has_in &= ~VoltIdxBit;
+	    }
+
+#ifdef CONFIG_OF
+    }
+#endif
+
+
+	/* Check DTS enable status */
+	if (data->enable_dts == 0) {
+		data->has_dts = 0;
+	} else {
+		
+		data->has_dts = 
+			nct7904_read_value(client, NCT7904_REG_DTSC0) & 0xF;
+		if (data->enable_dts & 0x2){
+			data->has_dts |=
+			(nct7904_read_value(client, NCT7904_REG_DTSC1) & 0xF) << 4;
+		}
+
+	}
+
+
+	/* First update the voltages measured value and limits */
+	for (i = 0; i < ARRAY_SIZE(data->in); i++) {
+		if (!(data->has_in & (1 << i))) {
+			continue;
+		}
+
+		u16tmp = nct7904_read_value(client, NCT7904_REG_IN[i][IN_MAX]) << 3;
+		u16tmp |= nct7904_read_value(client, IN_HL_LSB_REG(i));
+		data->in[i][IN_MAX] = u16tmp;
+
+		u16tmp = nct7904_read_value(client, NCT7904_REG_IN[i][IN_LOW]) << 3;
+		u16tmp |= nct7904_read_value(client, IN_LL_LSB_REG(i));
+		data->in[i][IN_LOW] = u16tmp;
+		
+		u16tmp = nct7904_read_value(client, NCT7904_REG_IN[i][IN_READ]) << 3;
+		u16tmp |= nct7904_read_value(client, IN_LSB_REG(i)) & IN_LSB_MASK;
+		data->in[i][IN_READ] = u16tmp;
+	}
+
+	
+
+	/* First update fan and limits */
+	for (i = 0; i < ARRAY_SIZE(data->fan); i++) {
+		if (!(data->has_fan & (1 << i))) {
+			continue;
+		}
+		data->fan_min[i] =
+			((u16)nct7904_read_value(client, NCT7904_REG_FAN_MIN(i))) << 5;
+		data->fan_min[i] |=
+		  nct7904_read_value(client, NCT7904_REG_FAN_MIN_LSB(i)) & NCT7904_FAN_LSB_MASK;
+		data->fan[i] =
+			((u16)nct7904_read_value(client, NCT7904_REG_FAN(i))) << 5;
+		data->fan[i] |=
+		  nct7904_read_value(client, NCT7904_REG_FAN_LSB(i)) & NCT7904_FAN_LSB_MASK;
+	}
+
+	/* temperature and limits */
+	for (i = 0; i < ARRAY_SIZE(data->temp); i++) {
+		if (!(data->has_temp & (1 << i)))
+			continue;
+		data->temp[i][TEMP_CRIT] = 
+			nct7904_read_value(client, NCT7904_REG_TEMP[i][TEMP_CRIT]);
+		data->temp[i][TEMP_CRIT_HYST] = 
+			nct7904_read_value(client, NCT7904_REG_TEMP[i][TEMP_CRIT_HYST]);
+		data->temp[i][TEMP_WARN] = 
+			nct7904_read_value(client, NCT7904_REG_TEMP[i][TEMP_WARN]);
+		data->temp[i][TEMP_WARN_HYST] = 
+			nct7904_read_value(client, NCT7904_REG_TEMP[i][TEMP_WARN_HYST]);
+		data->temp[i][TEMP_READ] = 
+			nct7904_read_value(client, NCT7904_REG_TEMP[i][TEMP_READ]);
+		data->temp_read_lsb[i] =
+			nct7904_read_value(client, NCT7904_REG_TEMP_LSB(i));
+	}
+
+	/* dts temperature and limits */
+	if (data->enable_dts != 0) {
+		for (i = 0; i < ARRAY_SIZE(data->dts); i++) {
+			data->dts[i][DTS_CRIT] = 
+				nct7904_read_value(client, NCT7904_REG_DTS[i][DTS_CRIT]);
+			data->dts[i][DTS_CRIT_HYST] = 
+				nct7904_read_value(client, NCT7904_REG_DTS[i][DTS_CRIT_HYST]);
+			data->dts[i][DTS_WARN] = 
+				nct7904_read_value(client, NCT7904_REG_DTS[i][DTS_WARN]);
+			data->dts[i][DTS_WARN_HYST] = 
+				nct7904_read_value(client, NCT7904_REG_DTS[i][DTS_WARN_HYST]);
+			
+			if (!(data->has_dts & (1 << i)))
+				continue;
+			data->dts[i][DTS_READ] = 
+				nct7904_read_value(client, NCT7904_REG_DTS[i][DTS_READ]);
+			data->dts_read_lsb[i] =
+				nct7904_read_value(client, NCT7904_REG_DTS_LSB(i));
+			
+		}
+	}
 
-	data->client = client;
-	mutex_init(&data->bank_lock);
-	data->bank_sel = -1;
 
-	/* Setup sensor groups. */
-	/* FANIN attributes */
-	ret = nct7904_read_reg16(data, BANK_0, FANIN_CTRL0_REG);
-	if (ret < 0)
-		return ret;
-	data->fanin_mask = (ret >> 8) | ((ret & 0xff) << 8);
 
+	/* vid */
 	/*
-	 * VSEN attributes
-	 *
-	 * Note: voltage sensors overlap with external temperature
-	 * sensors. So, if we ever decide to support the latter
-	 * we will have to adjust 'vsen_mask' accordingly.
-	 */
-	mask = 0;
-	ret = nct7904_read_reg16(data, BANK_0, VT_ADC_CTRL0_REG);
-	if (ret >= 0)
-		mask = (ret >> 8) | ((ret & 0xff) << 8);
-	ret = nct7904_read_reg(data, BANK_0, VT_ADC_CTRL2_REG);
-	if (ret >= 0)
-		mask |= (ret << 16);
-	data->vsen_mask = mask;
-
-	/* CPU_TEMP attributes */
-	ret = nct7904_read_reg16(data, BANK_0, DTS_T_CTRL0_REG);
-	if (ret < 0)
-		return ret;
-	data->tcpu_mask = ((ret >> 8) & 0xf) | ((ret & 0xf) << 4);
-
-	for (i = 0; i < FANCTL_MAX; i++) {
-		ret = nct7904_read_reg(data, BANK_3, FANCTL1_FMR_REG + i);
-		if (ret < 0)
-			return ret;
-		data->fan_mode[i] = ret;
-	}
-
-	hwmon_dev =
-		devm_hwmon_device_register_with_info(dev, client->name, data,
-						     &nct7904_chip_info, NULL);
+	data->vrm = vid_which_vrm();
+	if (data->chip_type == w83795adg) {
+		data->has_vid = 0;
+	} else {
+		data->has_vid = 
+			(w83795_read_value(client, W83795_REG_VID_CTRL) >> 3) & 0x07;
+	}
+	*/
+	
+	/* alarm */
+	for (i = 0; i < ALARM_REG_NUM; i ++) {
+		data->alarms[i] = 
+			nct7904_read_value(client, NCT7904_REG_ALARM(i));
+
+	}
+
+
+	/* Prepare for sysfs hooks */
+	data->groups[0] = &nct7904_group_in;
+	data->groups[1] = &nct7904_group_fan;
+	data->groups[2] = &nct7904_group_dts;
+	data->groups[3] = &nct7904_group_temp;
+	data->groups[4] = NULL;
+
+	hwmon_dev = devm_hwmon_device_register_with_groups(dev,
+					client->name,
+					data, data->groups);
 	return PTR_ERR_OR_ZERO(hwmon_dev);
+
+//	return 0;
+
+	/* Unregister sysfs hooks */
+/*
+exit_remove:
+	for (i = 0; i < ARRAY_SIZE(nct7904_in); i++)
+		device_remove_file(dev, &nct7904_in[i].dev_attr);
+
+	for (i = 0; i < ARRAY_SIZE(nct7904_fan); i++)
+		device_remove_file(dev, &nct7904_fan[i].dev_attr);
+
+
+
+//	for (i = 0; i < ARRAY_SIZE(w83795_vid); i++) {
+//		if (!((data->has_vid >> i) & 1))
+//			continue;
+//		device_remove_file(dev, &w83795_vid[i].dev_attr);
+//	}
+
+
+
+
+	for (i = 0; i < ARRAY_SIZE(nct7904_temp); i++){
+		if (!(data->has_temp & (1 << i)))
+			continue;
+		device_remove_file(dev, &nct7904_temp[i].dev_attr);
+	}
+
+	for (i = 0; i < ARRAY_SIZE(nct7904_dts); i++)
+		device_remove_file(dev, &nct7904_dts[i].dev_attr);
+
+	return err;
+*/
+	
 }
 
-static const struct i2c_device_id nct7904_id[] = {
-	{"nct7904", 0},
-	{}
-};
-MODULE_DEVICE_TABLE(i2c, nct7904_id);
+#ifdef CONFIG_OF
+
+static int nct7904_get_channels_config(struct i2c_client *client, struct nct7904_data *data)
+{
+	struct device_node *node;
+    u8 tmp;
+    u8 TempIdxBit; //Tmp using. The index bit coresponding to has_temp and "TD" in has_mode
+	u32 VoltIdxBit; //Tmp using. The index bit coresponding to has_in
+
+    data->has_temp = 0;
+
+    /* VDSEN2-9 and TR1-4, TD1-2 use the same pin and is exclusive. */
+	data->temp_mode = 0;
+
+	if (!client->dev.of_node
+	    || !of_get_next_child(client->dev.of_node, NULL))
+	{
+		printk("no child node\r\n");
+        return -EINVAL;
+	}
+
+    if (of_property_read_u8(client->dev.of_node, "vt_adc_ctrl0", &tmp)) {
+        dev_err(&client->dev, "invalid reg on %pOF\n", client->dev.of_node);
+        return -EINVAL;
+    }
+    else {
+        data->has_in = tmp;
+        nct7904_write_value(client, NCT7904_REG_VOLT_CTRL1, tmp);
+	    if ((tmp & 0x6) == 0x6){
+            data->has_temp |= 1;
+	    }
+	    if ((tmp & 0x18) == 0x18){
+            data->has_temp |= 2;
+	    }
+	    if ((tmp & 0x20) == 0x20){
+            data->has_temp |= 4;
+	    }
+	    if ((tmp & 0x80) == 0x80){
+            data->has_temp |= 8;
+	    }
+        //printk("data->has_in : 0x%x\r\n", data->has_in);
+    }
+
+    if (of_property_read_u8(client->dev.of_node, "vt_adc_ctrl1", &tmp)) {
+        dev_err(&client->dev, "invalid reg on %pOF\n", client->dev.of_node);
+        return -EINVAL;
+    }
+    else {
+        nct7904_write_value(client, NCT7904_REG_VOLT_CTRL2, tmp);
+        data->has_in |= tmp << 8;
+        //printk("data->has_in : 0x%x\r\n", data->has_in);
+    }
+
+    if (of_property_read_u8(client->dev.of_node, "vt_adc_ctrl2", &tmp)) {
+        dev_err(&client->dev, "invalid reg on %pOF\n", client->dev.of_node);
+        return -EINVAL;
+    }
+    else {
+        nct7904_write_value(client, NCT7904_REG_VOLT_CTRL3, tmp);
+        data->has_in |= tmp << 16;
+        /* LTD */
+        if ((tmp & 0x02) == 0x02){
+	    	data->has_temp |= 0x10;
+	    }
+
+        //printk("data->has_in : 0x%x\r\n", data->has_in);
+    }
+
+    /* Multi-Function detecting for Volt and TR/TD.
+	Just deal with the DISABLE in has_xxxx because
+	if it is not monitored, multi-function selection is useless.*/
+
+	//VSEN2~3, TEMP_CH1
+	node = of_find_compatible_node(NULL, NULL, "nct7904,vsen2");
+	if(node)
+	{
+		if (of_property_read_u8(node, "mode", &tmp)) {
+            dev_err(&client->dev, "invalid mode on %pOF\n", node);
+        }
+        else
+        {
+            //printk("mode : 0x%x\r\n", tmp);
+            //tmp = (tmp & (TMP_MASK<<NCT7904_TEMP_CTRL_SHIFT[0]))>>NCT7904_TEMP_CTRL_SHIFT[0];
+            u8 temp = nct7904_read_value(client, NCT7904_REG_VOLT_TEMP_CTRL);
+            temp &= ~(TMP_MASK);
+            nct7904_write_value(client, NCT7904_REG_VOLT_TEMP_CTRL, (temp|tmp) );
+
+            TempIdxBit = (1<<0);
+            VoltIdxBit = 0x6;
+            if (tmp == VAL_VOLT_TEMP_CTRL_VOLT_MONITOR){
+                data->has_temp &= ~TempIdxBit;
+	        }
+            else if (tmp == VAL_VOLT_TEMP_CTRL_DIODE_CURRENT){
+                data->has_in &= ~VoltIdxBit;
+                data->temp_mode |= TempIdxBit;
+	        }
+            else{
+                data->has_in &= ~VoltIdxBit;
+	        }
+	    }
+
+	    of_node_put(node);
+	}
+
+	//VSEN4~5, TEMP_CH2
+	node = of_find_compatible_node(NULL, NULL, "nct7904,vsen4");
+	if(node)
+	{
+        if (of_property_read_u8(node, "mode", &tmp)) {
+            dev_err(&client->dev, "invalid mode on %pOF\n", node);
+        }
+        else
+        {
+            //printk("mode : 0x%x\r\n", tmp);
+            //tmp = (tmp & (TMP_MASK<<NCT7904_TEMP_CTRL_SHIFT[1]))>>NCT7904_TEMP_CTRL_SHIFT[1];
+            u8 temp = nct7904_read_value(client, NCT7904_REG_VOLT_TEMP_CTRL);
+            temp &= ~(TMP_MASK<<NCT7904_TEMP_CTRL_SHIFT[1]);
+            nct7904_write_value(client, NCT7904_REG_VOLT_TEMP_CTRL, (temp| (tmp<<NCT7904_TEMP_CTRL_SHIFT[1]) ) );
+
+            TempIdxBit = (1<<1);
+            VoltIdxBit = 0x18;
+            if (tmp == VAL_VOLT_TEMP_CTRL_VOLT_MONITOR){
+                data->has_temp &= ~TempIdxBit;
+            }
+            else if (tmp == VAL_VOLT_TEMP_CTRL_DIODE_CURRENT){
+                data->has_in &= ~VoltIdxBit;
+                data->temp_mode |= TempIdxBit;
+	        }
+            else{
+                data->has_in &= ~VoltIdxBit;
+	        }
+	    }
+
+        of_node_put(node);
+    }
+
+	//VSEN6, TEMP_CH3
+	node = of_find_compatible_node(NULL, NULL, "nct7904,vsen6");
+	if(node)
+	{
+		if (of_property_read_u8(node, "mode", &tmp)) {
+            dev_err(&client->dev, "invalid mode on %pOF\n", node);
+        }
+        else
+        {
+            //printk("mode : 0x%x\r\n", tmp);
+            //tmp = (tmp & (TMP_MASK<<NCT7904_TEMP_CTRL_SHIFT[2]))>>NCT7904_TEMP_CTRL_SHIFT[2];
+            u8 temp = nct7904_read_value(client, NCT7904_REG_VOLT_TEMP_CTRL);
+            temp &= ~(TMP_MASK<<NCT7904_TEMP_CTRL_SHIFT[2]);
+            nct7904_write_value(client, NCT7904_REG_VOLT_TEMP_CTRL, (temp| (tmp<<NCT7904_TEMP_CTRL_SHIFT[2]) ) );
+
+            TempIdxBit = (1<<2);
+            VoltIdxBit = 0x20;
+            if (tmp == VAL_VOLT_TEMP_CTRL_VOLT_MONITOR){
+                data->has_temp &= ~TempIdxBit;
+	        }
+            else{ //TR
+                data->has_in &= ~VoltIdxBit;
+	        }
+	    }
+
+	    of_node_put(node);
+    }
+
+	//VSEN8, TEMP_CH4
+	node = of_find_compatible_node(NULL, NULL, "nct7904,vsen8");
+	if(node)
+	{
+		if (of_property_read_u8(node, "mode", &tmp)) {
+            dev_err(&client->dev, "invalid mode on %pOF\n", node);
+        }
+        else
+        {
+            //printk("mode : 0x%x\r\n", tmp);
+            //tmp = (tmp & (TMP_MASK<<NCT7904_TEMP_CTRL_SHIFT[3]))>>NCT7904_TEMP_CTRL_SHIFT[3];
+            u8 temp = nct7904_read_value(client, NCT7904_REG_VOLT_TEMP_CTRL);
+            temp &= ~(TMP_MASK<<NCT7904_TEMP_CTRL_SHIFT[3]);
+            nct7904_write_value(client, NCT7904_REG_VOLT_TEMP_CTRL, (temp| (tmp<<NCT7904_TEMP_CTRL_SHIFT[3]) ) );
+
+            TempIdxBit = (1<<3);
+            VoltIdxBit = 0x80;
+            if (tmp == VAL_VOLT_TEMP_CTRL_VOLT_MONITOR){
+                data->has_temp &= ~TempIdxBit;
+	        }
+            else{ //TR
+                data->has_in &= ~VoltIdxBit;
+	        }
+	    }
+
+	    of_node_put(node);
+    }
+
+	return 0;
+}
+
+#endif
+
+static struct nct7904_data *nct7904_update_device(struct device *dev)
+{
+	struct nct7904_data *data = dev_get_drvdata(dev);
+	struct i2c_client *client = data->client;
+	u16 tmp;
+	int i;
+
+	mutex_lock(&data->update_lock);
+
+	if (!(time_after(jiffies, data->last_updated + HZ * 2)
+	      || !data->valid))
+		goto END;
+
+	/* Update the voltages value */
+	for (i = 0; i < ARRAY_SIZE(data->in); i++) {
+		if (!(data->has_in & (1 << i))) {
+			continue;
+		}
+		tmp = nct7904_read_value(client, NCT7904_REG_IN[i][IN_READ]) << 3;
+		tmp |= nct7904_read_value(client, IN_LSB_REG(i)) & IN_LSB_MASK;
+		data->in[i][IN_READ] = tmp;
+	}
+
+	/* Update fan */
+	for (i = 0; i < ARRAY_SIZE(data->fan); i++) {
+		if (!(data->has_fan & (1 << i))) {
+			continue;
+		}
+		data->fan[i] =
+			((u16)nct7904_read_value(client, NCT7904_REG_FAN(i))) << 5;
+		data->fan[i] |=
+		  nct7904_read_value(client, NCT7904_REG_FAN_LSB(i)) & NCT7904_FAN_LSB_MASK;
+	}
+
+	/* Update temperature */
+	for (i = 0; i < ARRAY_SIZE(data->temp); i++) {
+		/* even stop monitor, register still keep value, just read out it */
+		if (!(data->has_temp & (1 << i))) {
+			data->temp[i][TEMP_READ] = 0;
+			data->temp_read_lsb[i] = 0;
+			continue;
+		}
+		data->temp[i][TEMP_READ] = 
+			nct7904_read_value(client, NCT7904_REG_TEMP[i][TEMP_READ]);
+		data->temp_read_lsb[i] =
+			nct7904_read_value(client, NCT7904_REG_TEMP_LSB(i));
+	}
+
+	/* Update dts temperature */
+	/* dts temperature and limits */
+	if (data->enable_dts != 0) {
+		for (i = 0; i < ARRAY_SIZE(data->dts); i++) {
+			
+			data->dts[i][DTS_CRIT] = 
+				nct7904_read_value(client, NCT7904_REG_DTS[i][DTS_CRIT]);
+			data->dts[i][DTS_CRIT_HYST] = 
+				nct7904_read_value(client, NCT7904_REG_DTS[i][DTS_CRIT_HYST]);
+			data->dts[i][DTS_WARN] = 
+				nct7904_read_value(client, NCT7904_REG_DTS[i][DTS_WARN]);
+			data->dts[i][DTS_WARN_HYST] = 
+				nct7904_read_value(client, NCT7904_REG_DTS[i][DTS_WARN_HYST]);
+
+			if (!(data->has_dts & (1 << i)))
+				continue;
+			data->dts[i][DTS_READ] = 
+				nct7904_read_value(client, NCT7904_REG_DTS[i][DTS_READ]);
+			data->dts_read_lsb[i] =
+				nct7904_read_value(client, NCT7904_REG_DTS_LSB(i));
+			
+		}
+	}
+
+	
+
+	/* retrieve vid  */
+	/*
+	if (0 != data->has_vid) {
+		tmp = w83795_read_value(client, W83795_REG_VID_CTRL);
+		w83795_write_value(client, W83795_REG_VID_CTRL, tmp | 0x80);
+		for (i = 0; i < 3; i ++) {
+			data->vid[i] = 
+				w83795_read_value(client, W83795_REG_VSEN_VIDIN(i));
+		}
+	}
+	*/
+	
+	/* update alarm and beep */
+	for (i = 0; i < ALARM_REG_NUM; i ++) {
+		data->alarms[i] = 
+			nct7904_read_value(client, NCT7904_REG_ALARM(i));
+	}
+
+	data->last_updated = jiffies;
+	data->valid = 1;
+
+END:
+	mutex_unlock(&data->update_lock);
+	return data;
+}
+
+/*
+static int nct7904_remove(struct i2c_client *client)
+{
+	struct nct7904_data *data = i2c_get_clientdata(client);
+	struct device *dev = &client->dev;
+	int i,res;
+
+	hwmon_device_unregister(data->hwmon_dev);
+
+	for (i = 0; i < ARRAY_SIZE(nct7904_in); i++)
+		device_remove_file(dev, &nct7904_in[i].dev_attr);
+
+	for (i = 0; i < ARRAY_SIZE(nct7904_fan); i++)
+		device_remove_file(dev, &nct7904_fan[i].dev_attr);
 
-static struct i2c_driver nct7904_driver = {
-	.class = I2C_CLASS_HWMON,
-	.driver = {
-		.name = "nct7904",
-	},
-	.probe = nct7904_probe,
-	.id_table = nct7904_id,
-	.detect = nct7904_detect,
-	.address_list = normal_i2c,
-};
+
+
+//	for (i = 0; i < ARRAY_SIZE(w83795_vid); i++) {
+//		if (!((data->has_vid >> i) & 1))
+//			continue;
+//		device_remove_file(dev, &w83795_vid[i].dev_attr);
+//	}
+
+	
+
+	for (i = 0; i < ARRAY_SIZE(nct7904_temp); i++){
+		if (!(data->has_temp & (1 << (i/7))))
+			continue;
+		device_remove_file(dev, &nct7904_temp[i].dev_attr);
+	}
+
+	for (i = 0; i < ARRAY_SIZE(nct7904_dts); i++){
+		device_remove_file(dev, &nct7904_dts[i].dev_attr);
+	}
+
+	// To make sure bank is set as 0.
+	//	Only bank 0 can provide Chip ID and Vendor ID in some early nct7904.
+	//	So we always reset bank to 0 before removing driver. 
+	res = i2c_smbus_write_byte_data(client, NCT7904_REG_BANKSEL, 0);
+
+	return 0;
+}
+*/
+
+
+/* Ignore the possibility that somebody change bank outside the driver
+   Must be called with data->update_lock held, except during initialization */
+static u8 nct7904_read_value(struct i2c_client *client, u16 reg)
+{
+	struct nct7904_data *data = i2c_get_clientdata(client);
+	u8 res = 0xff;
+	u8 new_bank = reg >> 8;
+
+//new_bank |= data->bank & 0xf8;
+
+#ifndef FIX_BANK_PROBLEM /* #if NOT def */
+	/* For fixing bank's bug of early verion nct7904, we always 
+	   over-write bank reg before accessing */
+
+	if (data->bank != new_bank) {
+#endif		
+		if (i2c_smbus_write_byte_data
+		    (client, NCT7904_REG_BANKSEL, new_bank) >= 0){
+			data->bank = new_bank;
+		}
+		else {
+			dev_err(&client->dev,
+				"set bank to %d failed, fall back "
+				"to bank %d, read reg 0x%x error\n",
+				new_bank, data->bank, reg);
+			res = 0x0;	/* read 0x0 from the chip */
+			goto END;
+		}
+		
+#ifndef FIX_BANK_PROBLEM /* #if NOT def */		
+	}
+#endif
+
+	res = i2c_smbus_read_byte_data(client, reg & 0xff);
+END:
+	return res;
+}
+
+/* Must be called with data->update_lock held, except during initialization */
+static int nct7904_write_value(struct i2c_client *client, u16 reg, u8 value)
+{
+	struct nct7904_data *data = i2c_get_clientdata(client);
+	int res;
+	u8 new_bank = reg >> 8;
+
+
+//new_bank |= data->bank & 0xf8;
+
+#ifndef FIX_BANK_PROBLEM /* #if NOT def */
+	
+	/* For fixing bank's bug of early verion nct7904, we always 
+	   over-write bank reg before accessing */
+	if (data->bank != new_bank) {
+#endif
+
+		if ((res = i2c_smbus_write_byte_data
+		    (client, NCT7904_REG_BANKSEL, new_bank)) >= 0){
+			data->bank = new_bank;
+		}
+		else {
+			dev_err(&client->dev,
+				"set bank to %d failed, fall back "
+				"to bank %d, write reg 0x%x error\n",
+				new_bank, data->bank, reg);
+			goto END;
+		}
+		
+#ifndef FIX_BANK_PROBLEM /* #if NOT def */		
+	}
+#endif	
+ 
+
+	res = i2c_smbus_write_byte_data(client, reg & 0xff, value);
+END:
+	return res;
+}
+
+#ifdef DBG_INIT_FUNCTION
+
+static int __init sensors_nct7904_init(void)
+{
+	printk("nct7904: sensors_nct7904_init\n");
+
+	return i2c_add_driver(&nct7904_driver);
+}
+
+static void __exit sensors_nct7904_exit(void)
+{
+	printk("nct7904: sensors_nct7904_exit\n");
+
+	i2c_del_driver(&nct7904_driver);
+}
+
+module_init(sensors_nct7904_init);
+module_exit(sensors_nct7904_exit);
+
+#else
 
 module_i2c_driver(nct7904_driver);
 
-MODULE_AUTHOR("Vadim V. Vlasov <vvlasov@dev.rtsoft.ru>");
-MODULE_DESCRIPTION("Hwmon driver for NUVOTON NCT7904");
+#endif
+
+MODULE_AUTHOR("Sheng-Yuan Huang");
+MODULE_DESCRIPTION("NCT7904 driver");
 MODULE_LICENSE("GPL");
+
+
+
-- 
2.7.4

